<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kome1jisatori.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言个人操作系统笔记整理，欢迎参考，时不时更新。">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统笔记——第六章">
<meta property="og:url" content="https://kome1jisatori.github.io/2021/06/16/os-6/index.html">
<meta property="og:site_name" content="KomeijiSatoriのblog">
<meta property="og:description" content="前言个人操作系统笔记整理，欢迎参考，时不时更新。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%871.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%872.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%873.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%874.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%875.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%876.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%877.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%878.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%879.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8710.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8711.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8712.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8713.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8714.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8715.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8716.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8717.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8718.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8719.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8720.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8721.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8722.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8723.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8724.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8725.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8726.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8727.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8728.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8729.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8730.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8731.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8732.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8733.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8734.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8735.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8736.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8737.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8738.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8739.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8740.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8741.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8742.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%8743.png">
<meta property="article:published_time" content="2021-06-16T18:19:22.000Z">
<meta property="article:modified_time" content="2021-06-20T13:51:00.864Z">
<meta property="article:author" content="Komeiji Satori">
<meta property="article:tag" content="课堂笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kome1jisatori.github.io/2021/06/16/os-6/%E5%9B%BE%E7%89%871.png">

<link rel="canonical" href="https://kome1jisatori.github.io/2021/06/16/os-6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统笔记——第六章 | KomeijiSatoriのblog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KomeijiSatoriのblog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">地灵殿从零开始的学习生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">23</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kome1jisatori.github.io/2021/06/16/os-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Komeiji Satori">
      <meta itemprop="description" content="记录些有的没的的学习心得">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KomeijiSatoriのblog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统笔记——第六章
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-17 02:19:22" itemprop="dateCreated datePublished" datetime="2021-06-17T02:19:22+08:00">2021-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-20 21:51:00" itemprop="dateModified" datetime="2021-06-20T21:51:00+08:00">2021-06-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          
            <span id="/2021/06/16/os-6/" class="post-meta-item leancloud_visitors" data-flag-title="操作系统笔记——第六章" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/16/os-6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/16/os-6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>27k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>25 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
     
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>个人操作系统笔记整理，欢迎参考，时不时更新。  </p>
<span id="more"></span> 

<h1 id="第六章-输入输出系统"><a href="#第六章-输入输出系统" class="headerlink" title="第六章 输入输出系统"></a>第六章 输入输出系统</h1><h2 id="6-1-I-O系统的功能、模型和接口"><a href="#6-1-I-O系统的功能、模型和接口" class="headerlink" title="6.1 I/O系统的功能、模型和接口"></a>6.1 I/O系统的功能、模型和接口</h2><h3 id="6-1-1-I-O系统的基本功能"><a href="#6-1-1-I-O系统的基本功能" class="headerlink" title="6.1.1 I/O系统的基本功能"></a>6.1.1 I/O系统的基本功能</h3><p>&ensp;&ensp;&ensp;&ensp;I/O系统管理的主要对象：I/O设备和相应的设备控制器    </p>
<p>&ensp;&ensp;&ensp;&ensp;主要的任务<br>&ensp;&ensp;&ensp;&ensp;①完成用户提出的I/O请求<br>&ensp;&ensp;&ensp;&ensp;②提高I/O速率<br>&ensp;&ensp;&ensp;&ensp;③提高设备的利用率<br>&ensp;&ensp;&ensp;&ensp;④为更高层的进程方便地使用这些设备提供手段。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%871.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.隐藏物理设备的细节</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;原因：I/O设备种类繁多，互有差异<br>&ensp;&ensp;&ensp;&ensp;方法：使用设备控制器控制设备，用户仅使用抽象的I/O命令就可以使用设备。<br>&ensp;&ensp;&ensp;&ensp;设备控制器主要职责是控制一个或多个I/O设备，实现I/O与CPU之间的数据交换。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.与设备的无关性（独立性）</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;目的：隐藏物理设备的细节，方便用户使用特定设备<br>&ensp;&ensp;&ensp;&ensp;方法：使用抽象的逻辑设备名来使用设备  /dev/printer<br>&ensp;&ensp;&ensp;&ensp;设备独立性是指操作系统把所有外部设备统一当作成文件来看待，任何用户都可以象使用文件一样，操纵、使用这些设备，而不必知道它们的具体存在形式。OS不必知道具体的使用哪台打印机，也不必知道打印机的型号。方便用户使用，并且有效地提高OS的可移植性和易适应性，OS允许在不需要重新编译的情况下，增添新的设备驱动，方便新的I/O设备的安装，做到即插即用  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.提高处理机和I/O的利用率</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;原因：<br>&ensp;&ensp;&ensp;&ensp;I/O设备之间能够并行<br>&ensp;&ensp;&ensp;&ensp;CPU与I/O设备也能并行<br>&ensp;&ensp;&ensp;&ensp;方法：<br> &ensp;&ensp;&ensp;&ensp;一方面要求CPU能尽快响应用户请求使I/O设备尽快的运行起来<br>&ensp;&ensp;&ensp;&ensp;另一方面，尽量减少在I/O设备运行时，处理机的干预时间。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.对I/O设备进行控制</strong> </p>
<p>&ensp;&ensp;&ensp;&ensp;方式：<br>&ensp;&ensp;&ensp;&ensp;1）轮询的可编程I/O方式<br>&ensp;&ensp;&ensp;&ensp;利用I/O测试指令测试设备的闲忙，极大地浪费CPU<br>&ensp;&ensp;&ensp;&ensp;2）中断的可编程的I/O方式<br>&ensp;&ensp;&ensp;&ensp;当设备完成I/O操作，便以中断请求方式通知CPU，然后进行相应处理，浪费CPU<br>&ensp;&ensp;&ensp;&ensp;3）直接存储器访问方式<br>&ensp;&ensp;&ensp;&ensp;由DMA控制器送出内存地址和发出内存读、设备写或者设备读、内存写的控制信号完成内存与设备之间的直接数据传送，而不用CPU干预<br>&ensp;&ensp;&ensp;&ensp;4）I/O通道方式<br>&ensp;&ensp;&ensp;&ensp;通道是独立于CPU的、专门负责数据的输入输出传输工作的处理器，它对外部设备实统一管理，代替CPU对I/O操作进行控制，从而使I/O操作可以与CPU并行工作。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>5.确保对设备的正确共享</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;设备分类：<br>&ensp;&ensp;&ensp;&ensp;1）独占设备，互斥访问，打印机<br>&ensp;&ensp;&ensp;&ensp;2）共享设备，一段时间内运行多个进程同时访问的设备，磁盘  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>6.错误处理</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;故障分类：<br>&ensp;&ensp;&ensp;&ensp;1）临时性错误<br>&ensp;&ensp;&ensp;&ensp;2）持久性错误<br>&ensp;&ensp;&ensp;&ensp;对于错误的处理尽可能的在接近硬件的层面上解决，让上层用户感知不到错误的存在。       </p>
<h3 id="6-1-2-I-O系统的层次结构和模型"><a href="#6-1-2-I-O系统的层次结构和模型" class="headerlink" title="6.1.2 I/O系统的层次结构和模型"></a>6.1.2 I/O系统的层次结构和模型</h3><p>&ensp;&ensp;&ensp;&ensp;I/O软件下与硬件关系密切，上与文件系统，虚拟存储器系统和用户直接交互。为使复杂的I/O软件具有清晰的结构，更好的可移植性和易用性，目前普遍采用层次式的I/O系统。<br>&ensp;&ensp;&ensp;&ensp;目前I/O系统普遍采用层次结构，它将系统中的设备管理模块，分为若干个层次，每一层都是利用其下层提供的服务，完成输入输出功能中的某些子功能，并屏蔽这些功能实现的细节，向高层提供服务。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.I/O软件的层次结构</strong>  </p>
<p><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%872.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）用户层软件<br>&ensp;&ensp;&ensp;&ensp;实现与用户交互的接口，用户可直接调用在用户层提供的、与I/O操作有关的库函数，对设备进行操作。<br>&ensp;&ensp;&ensp;&ensp;（2）设备独立软件<br>&ensp;&ensp;&ensp;&ensp;用于实现用户程序与设备驱动器的统一接口、设备命名、设备的保护以及设备的分配与释放等，同时为设备管理和数据传送提供必要的存储空间。<br>&ensp;&ensp;&ensp;&ensp;应用程序独立于具体使用的物理设备（逻辑设备名）<br>&ensp;&ensp;&ensp;&ensp;（3）设备驱动程序<br>&ensp;&ensp;&ensp;&ensp;处于次底层，是进程和控制器之间的通信程序<br>&ensp;&ensp;&ensp;&ensp;功能：与硬件直接相关，用于具体实现系统对设备发出的操作指令，驱动I/O设备工作的驱动程序。<br>&ensp;&ensp;&ensp;&ensp;（4）中断处理程序<br>&ensp;&ensp;&ensp;&ensp;处于I/O系统的底层，直接与硬件进行交互<br>&ensp;&ensp;&ensp;&ensp;用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完后再恢复被中断进程的现场后，返回到被中断进程。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.I/O系统中各种模块之间的层次视图</strong>  </p>
<p><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%873.png">    </p>
<h3 id="6-1-3-I-O系统接口"><a href="#6-1-3-I-O系统接口" class="headerlink" title="6.1.3 I/O系统接口"></a>6.1.3 I/O系统接口</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.块设备接口</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）块设备：数据的存取和传输都是以数据块为单位的设备，如磁盘。基本特征是<strong>传输速率较高、可寻址</strong>。磁盘设备的I/O常采用<strong>DMA</strong>方式。<br>&ensp;&ensp;&ensp;&ensp;2）隐藏了磁盘的二维结构：块设备接口隐藏了磁盘地址是二维结构的情况：每个扇区的地址需要用磁道号和扇区号来表示。<br>&ensp;&ensp;&ensp;&ensp;3）将抽象命令映射为低层操作：块设备接口将上层发来的抽象命令，映射为设备能识别的较低层具体操作。  </p>
<p>&ensp;&ensp;&ensp;虚拟存储器系统也要用到块设备接口  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.流（字符）设备接口</strong>   </p>
<p>&ensp;&ensp;&ensp;1）字符设备：数据的存取和传输是以字符为单位的设备。如键盘、打印机等。基本特征是传<strong>输速率较低、不可寻址</strong>，常采用<strong>中断驱动方式</strong>。<br>&ensp;&ensp;&ensp;2）get和put操作：由于字符设备是不可寻址的，因而对它只能采取<strong>顺序存取</strong>方式。（用户程序）获取或输出字符的方法是采用get和put操作，get操作用于从字符缓冲区取得一个字符到内存，而put操作则用于把一个新字符输出到字符缓冲区。<br>&ensp;&ensp;&ensp;3） in-control指令：因字符设备的类型非常多，且差异甚大，系统以统一的方式提供了一种通用的in-control指令来处理它们（包含了许多参数，每个参数表示一个与具体设备相关的特定功能）。</p>
<p>&ensp;&ensp;&ensp;大多数流设备都属于独占设备，必须采用互斥方式实现贡献。   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.网络通信接口</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在现代OS中，都提供了面向网络的功能。<br>&ensp;&ensp;&ensp;&ensp;还需要通过某种方式，把计算机连接到网络上。<br>&ensp;&ensp;&ensp;&ensp;操作系统也必须提供相应的网络软件和网络通信接口，使计算机能通过网络与网络上的其它计算机进行通信，或上网浏览。  </p>
<h2 id="6-2-I-O设备和设备控制器"><a href="#6-2-I-O设备和设备控制器" class="headerlink" title="6.2 I/O设备和设备控制器"></a>6.2 I/O设备和设备控制器</h2><h3 id="6-2-1-I-O设备"><a href="#6-2-1-I-O设备" class="headerlink" title="6.2.1 I/O设备"></a>6.2.1 I/O设备</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.I/O设备类型</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;1）按使用特性分类<br>&ensp;&ensp;&ensp;&ensp;①存储设备：也称外存、辅存。<br>&ensp;&ensp;&ensp;&ensp;②I/O设备：分为输入设备、输出设备和交互式设备。<br>&ensp;&ensp;&ensp;&ensp;2）按传输速率分类<br>&ensp;&ensp;&ensp;&ensp;①低速设备：其传输速率仅为每秒钟几个字节至数百个字节的一类设备，如键盘、鼠标器。<br>&ensp;&ensp;&ensp;&ensp;②中速设备：传输速率在每秒钟数千个字节至数十万个字节的一类设备，如行式打印机、激光打印机等。<br>&ensp;&ensp;&ensp;&ensp;③高速设备：传输速率在数十万字节至千兆字节的一类设备，如磁带机、磁盘机、光盘机等  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.设备与控制器之间的接口</strong>  </p>
<p>通常，设备并不直接与CPU进行通信，而是与设备控制器进行通信，因此，在I/O设备中应还有与设备控制器之间的接口。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%874.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;1）数据信号线：<br>&ensp;&ensp;&ensp;&ensp;用于在设备和设备控制器之间传送数据信号。<br>&ensp;&ensp;&ensp;&ensp;2）控制信号线：<br>&ensp;&ensp;&ensp;&ensp;①设备控制器向I/O设备发送控制信号时的通路。<br>&ensp;&ensp;&ensp;&ensp;②规定了设备将要执行的操作，比如：读、写、执行磁头移动等。<br>&ensp;&ensp;&ensp;&ensp;3）状态信号线：<br>&ensp;&ensp;&ensp;&ensp;①用于传送指示设备当前状态的信号。<br>&ensp;&ensp;&ensp;&ensp;②设备当前状态有：正在读（或写），设备已读（或写）完成，并准备好新的数据传送。  </p>
<h3 id="6-2-2-设备控制器"><a href="#6-2-2-设备控制器" class="headerlink" title="6.2.2 设备控制器"></a>6.2.2 设备控制器</h3><p>&ensp;&ensp;&ensp;&ensp;设备控制器的主要功能是，控制一个或多个I/O设备,以实现I/O设备和计算机之间的数据交换.它是CPU与I/O设备之间的接口,它接收从CPU发来的命令,并去控制I/O设备工作,以使处理机从繁忙的设备控制事务中解脱出来。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.设备控制器的基本功能</strong> </p>
<p>&ensp;&ensp;&ensp;&ensp;(1) 接收和识别命令<br>&ensp;&ensp;&ensp;&ensp;设备控制器能接收并识别处理机发来的多种命令，并对所接收的命令进行译码。<br>&ensp;&ensp;&ensp;&ensp;例如：磁盘控制器可以接收CPU发来的read、write、format等15条命令，相应地磁盘控制器中有多个寄存器和命令译码器。<br>&ensp;&ensp;&ensp;&ensp;(2) 数据交换<br>&ensp;&ensp;&ensp;&ensp;实现CPU与控制器之间、控制器与设备之间的数据交换。前者通过数据总线，由CPU并行地把数据写入控制器，或从控制器中并行地读出数据，后者则是设备将数据输入到控制器中，或从控制器传送给设备。为此，在控制器中必须设置数据寄存器。<br>&ensp;&ensp;&ensp;&ensp;(3) 标识和报告<br>&ensp;&ensp;&ensp;&ensp;设备的状态控制器应记下设备的状态供CPU了解。<br>&ensp;&ensp;&ensp;&ensp;例如：仅当该设备处于发送就绪状态时，CPU才能启动控制器从设备中读出数据，为此，要在设备控制器中设置一个状态寄存器<br>&ensp;&ensp;&ensp;&ensp;(4) 地址识别<br>&ensp;&ensp;&ensp;&ensp;能够识别其所控制的每个设备的地址。系统中的每一个设备都有一个地址，控制器能识别他所控制的每一个设备的地址设备控制器其中配置地址译码器<br>&ensp;&ensp;&ensp;&ensp;(5) 数据缓冲区<br>&ensp;&ensp;&ensp;&ensp;缓和CPU、内存与I/O设备的速度差异的矛盾故在控制器中必须设置一缓冲区。<br> &ensp;&ensp;&ensp;&ensp;(6) 差错控制<br>&ensp;&ensp;&ensp;&ensp;兼管对由I/O设备传送来的数据，进行差错检测，保证数据输入的正确性。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.设备控制器的组成</strong><br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%875.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;设备控制器由以下三部分组成：</p>
<p>&ensp;&ensp;&ensp;&ensp;1) 设备控制器与处理机的接口<br>&ensp;&ensp;&ensp;&ensp;用于实现CPU与设备控制器之间的通信，接口中共有三类信号线：数据线、地址线和控制线。数据线通常与数据、控制/状态两类寄存器相连接<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%876.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;2) 设备控制器与设备的接口<br>&ensp;&ensp;&ensp;&ensp;控制器中有一个或多个设备接口。在每个接口中都存在数据、控制和状态三种类型的信号。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%877.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;3) I/O逻辑：<br>&ensp;&ensp;&ensp;&ensp;I/O逻辑用于实现对设备的控制，接收CPU命令和地址译码。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%878.png">    </p>
<h3 id="6-2-3-内存映像I-O"><a href="#6-2-3-内存映像I-O" class="headerlink" title="6.2.3 内存映像I/O"></a>6.2.3 内存映像I/O</h3><p>&ensp;&ensp;&ensp;&ensp;驱动程序将抽象I/O命令，转换出的一系列具体的命令、参数等数据，装入设备控制器的相应寄存器，由控制器来执行这些命令，具体实施对I/O设备的控制。<br>&ensp;&ensp;&ensp;&ensp;两种方法：利用特定的I/O指令和内存映像I/O  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.利用特定的I/O指令</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;访问内存和访问设备需要两种不同的指令，也是该方法的主要缺点。<br>&ensp;&ensp;&ensp;&ensp;例如，为了将CPU寄存器中的内容，复制到控制器寄存器中：<br> &ensp;&ensp;&ensp;&ensp;io-store  cpu-reg, dev-no, dev-reg<br>&ensp;&ensp;&ensp;&ensp;如果是将CPU寄存器中的内容，存入内存的某个单元（k）中：<br>&ensp;&ensp;&ensp;&ensp;Store  cpu-reg, k<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%879.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.内存映像I/O</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;该方式统一了对内存和对控制器的访问的方法，简化了I/O的编程。<br>&ensp;&ensp;&ensp;&ensp;在编址上不再区分内存单元地址和设备控制器中的寄存器地址，都采用k。当k值处于0—n-1范围时，被认为是内存地址，若k大于等于n时，被认为是某个控制器的寄存器地址。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8710.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;由图所示，当k=n时，是表示设备控制器0的第1个寄存器opcode的地址。因此，如果要想将CPU寄存器中内容，传送到控制器0的第1个寄存器opcode，只需要用下面的一般的存储指令。<br>&ensp;&ensp;&ensp;&ensp;Store  cpu-reg, n  </p>
<h3 id="6-2-4-I-O通道"><a href="#6-2-4-I-O通道" class="headerlink" title="6.2.4 I/O通道"></a>6.2.4 I/O通道</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.I/O通道的引入</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;引入目的：解脱CPU对I/O的组织、管理。<br>&ensp;&ensp;&ensp;&ensp;CPU只需发送I/O命令给通道，通道通过调用内存中的相应通道程序完成任务。<br>&ensp;&ensp;&ensp;&ensp;通道：一种特殊的执行I/O指令的处理机，但指令类型单一，硬件较简单，与CPU共享内存，可以有自己的总线。<br>&ensp;&ensp;&ensp;&ensp;四级连接方式：主机-通道-设备控制器-I/O设备  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.通道类型</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;根据信息交换方式，分成三类：<br>&ensp;&ensp;&ensp;&ensp;（1）字节多路通道<br>&ensp;&ensp;&ensp;&ensp;按字节交叉方式工作，含有多个非分配型子通道，每个子通道连接一台I/O设备，子通道采用<strong>时间片轮转</strong>的方式共享主通道。<strong>不适于高速设备</strong>。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8711.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）数组选择通道<br>&ensp;&ensp;&ensp;&ensp;可以连接多台<strong>高速设备</strong>，只含有一个分配型子通道，一段时间内执行一道通道程序。<br>&ensp;&ensp;&ensp;&ensp;当某台设备占用通道后，便一直由它独占，直到该设备传输完毕释放通道。通道利用率低。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（3）数组多路通道<br>&ensp;&ensp;&ensp;&ensp;结合数组选择通道的高速和字节多路通道的分时并行结合起来的一种新通道。<br>&ensp;&ensp;&ensp;&ensp;多子通道不是以时间片的方式，而是按需分配，数据成组传输。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.“瓶颈”问题</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;通道价格昂贵，数量较少，多个I/O设备共享一个通道，造成“瓶颈”。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8712.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;解决“瓶颈”方法：增加设备到主机间的通路而不是增加通道  </p>
<h2 id="6-3-中断机构和中断处理程序"><a href="#6-3-中断机构和中断处理程序" class="headerlink" title="6.3 中断机构和中断处理程序"></a>6.3 中断机构和中断处理程序</h2><p>&ensp;&ensp;&ensp;&ensp;中断在操作系统中有着特殊重要的地位，它是多道程序得以实现的基础，因为<strong>进程之间的切换是通过中断来完成的</strong><br>&ensp;&ensp;&ensp;&ensp;另一方面，中断也是设备管理的基础，为了提高处理机的利用率和实现CPU与I/O设备并行执行，也必须有中断的支持。它是整个I/O系统的基础。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.中断和陷入</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;(1) 中断：CPU对I/O设备发来的中断信号的一种响应，中断是由外部设备引起的，又称外中断。<br>&ensp;&ensp;&ensp;&ensp;(2) 陷入：由CPU内部事件所引起的中断，通常把这类中断称为内中断或陷入（trap）。如地址越界、非法指令、电源故障等<br>&ensp;&ensp;&ensp;&ensp;中断和陷入的主要区别：信号的来源不同，CPU外部还是内部  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.中断向量表和中断优先级</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;(1) 中断向量表：为<strong>每种设备配以相应的中断处理程序</strong>，并把该程序的入口地址，放在中断向量表的一个表项中，并为每一个设备的中断请求，规定一个中断号，它直接对应于中断向量表的一个表项中。<br>&ensp;&ensp;&ensp;&ensp;(2) 中断优先级：系统根据不同中断信号源，对服务要求的紧急程度的不同，它们分别规定不同的优先级。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.对多中断源的处理方式</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1) 屏蔽（禁止）中断<br>&ensp;&ensp;&ensp;&ensp;所有中断都将按顺序依次处理。<br>&ensp;&ensp;&ensp;&ensp;当处理机正在处理一个中断时，将屏蔽掉所有新到的中断，让它们等待，直到处理机已完成本次中断的处理后，处理机再去检查并处理。<br>&ensp;&ensp;&ensp;&ensp;优点是简单，但不能用于对实时性要求较高的中断请求。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8713.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;2) 嵌套中断：在设置了中断优先级的系统中，通常按这样的规则来进行优先级控制<br>&ensp;&ensp;&ensp;&ensp;当同时有多个不同优先级的中断请求时，CPU优先响应最高优先级的中断请求；<br>&ensp;&ensp;&ensp;&ensp;高优先级的中断请求，可以抢占正在运行低优先级中断的处理机，该方式类似于基于优先级的抢占式进程调度。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8714.png">  </p>
<h3 id="6-3-2-中断处理程序"><a href="#6-3-2-中断处理程序" class="headerlink" title="6.3.2 中断处理程序"></a>6.3.2 中断处理程序</h3><p>&ensp;&ensp;&ensp;&ensp;中断处理程序的处理过程：<br>&ensp;&ensp;&ensp;&ensp;（1）测定是否有未响应的中断信号<br>&ensp;&ensp;&ensp;&ensp;每当设备完成一个字符（或数据块）的读入（输出），设备控制器便向处理机发送一个中断请求信号。请求处理机将设备已读入的数据传送到内存的缓冲区中，或请求处理机将要输出的数据传送给设备控制器。<br>&ensp;&ensp;&ensp;&ensp;程序每当<strong>执行完当前指令后</strong>，处理机都要测试是否有未响应的中断信号。<br>&ensp;&ensp;&ensp;&ensp;（2）保护被中断进程的CPU环境<br>&ensp;&ensp;&ensp;&ensp;从中断现场恢复到当前进程运行所需要的信息。通常由硬件将处理机状态字（PSW）和保存在程序计数器（PC）中下一条指令的地址保存在中断栈中。<br>&ensp;&ensp;&ensp;&ensp;把中断进程的CPU现场信息，即将包括所有CPU寄存器的内容压入中断栈。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8715.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;（3）转入相应的设备处理程序<br>&ensp;&ensp;&ensp;&ensp;处理机测试中断源，确定引起中断的I/O设备，将相应的设备中断处理程序的入口地址装入到PC中，使处理机转向中断处理程序。<br>&ensp;&ensp;&ensp;&ensp;（4）中断处理<br>&ensp;&ensp;&ensp;&ensp;首先从设备控制器中读出设备状态，以判别本次中断是正常完成或异常中断，视情况处理。<br>&ensp;&ensp;&ensp;&ensp;（5）恢复CPU现场并退出中断<br>&ensp;&ensp;&ensp;&ensp;当中断处理完成以后，需要恢复CPU的现场，退出中断。但是，此刻是否返回到被中断的进程，取决于：<br>&ensp;&ensp;&ensp;&ensp;1）本中断是否采用了屏蔽（禁止）中断方式，若是，则返回被中断的进程。<br>&ensp;&ensp;&ensp;&ensp;2）若采用的是嵌套方式，如果没有更高级的中断请求I/O，则返回中断的进程；反之，系统将处理优先级更高的中断请求。  </p>
<p>&ensp;&ensp;&ensp;&ensp;中断处理流程<br>&ensp;&ensp;&ensp;&ensp;①测定是否有未响应的中断信号<br>&ensp;&ensp;&ensp;&ensp;②保护被中断进程的CPU环境<br>&ensp;&ensp;&ensp;&ensp;③转入相应的设备处理程序<br>&ensp;&ensp;&ensp;&ensp;④中断处理<br>&ensp;&ensp;&ensp;&ensp;⑤恢复CPU的现场<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8716.png">  </p>
<h2 id="6-4-设备驱动程序"><a href="#6-4-设备驱动程序" class="headerlink" title="6.4 设备驱动程序"></a>6.4 设备驱动程序</h2><p>&ensp;&ensp;&ensp;&ensp;设备驱动程序是I/O系统的高层与设备控制器之间的通信程序，其主要任务：<br>&ensp;&ensp;&ensp;&ensp;①接收上层软件发来的抽象I/O要求，如read、write等命令；<br>&ensp;&ensp;&ensp;&ensp;②再把它转化为具体要求，发送给设备控制器，启动设备去执行。<br>&ensp;&ensp;&ensp;&ensp;③反之，它也将由设备控制器发来的信号，传送给上层软件。  </p>
<h3 id="6-4-1-设备驱动程序概述"><a href="#6-4-1-设备驱动程序概述" class="headerlink" title="6.4.1 设备驱动程序概述"></a>6.4.1 设备驱动程序概述</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.设备驱动程序的功能</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）接收由与设备无关的软件发来的命令和参数，并将命令中的抽象要求，转换为与设备相关的低层操作序列；<br>&ensp;&ensp;&ensp;&ensp;（2）检查用户I/O请求的合法性，了解I/O设备的工作状态，传递与I/O设备操作有关的参数，设置设备的工作方式；<br>&ensp;&ensp;&ensp;&ensp;（3）发出I/O命令，如果设备空闲，便立即启动I/O设备，完成指定的I/O操作；如果设备忙碌，则将请求者挂在设备队列上等待；<br>&ensp;&ensp;&ensp;&ensp;（4）及时响应由设备控制器发来的中断请求，并根据其中断类型，调用相应的中断处理程序进行处理。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.设备驱动程序的特点</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;(1)驱动程序是与设备无关的软件和设备控制器之间通信和转换的程序。<br>&ensp;&ensp;&ensp;&ensp;(2)驱动程序，与设备控制器和I/O设备的硬件特性，紧密相关。<br>&ensp;&ensp;&ensp;&ensp;(3)驱动程序与I/O设备所采用的I/O控制方式紧密相关。<br>&ensp;&ensp;&ensp;&ensp;(4)由于驱动程序与硬件紧密相关，因而其中的一部分必须用汇编语言编写。<br>&ensp;&ensp;&ensp;&ensp;(5)驱动程序应允许可重入，一个正在运行的驱动程序常会在一次调用完成前被再次调用。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.设备处理方式</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;(1)为每一类设备设置一个进程，专门用于执行这类设备的I/O操作。这种方式比较适合于较大的系统；<br>&ensp;&ensp;&ensp;&ensp;(2)在整个系统中设置一个I/O进程，专门用于执行系统中所有各类设备的I/O操作。也可以设置一个输入进程和一个输出进程，分别处理系统中的输入或输出操作；<br>&ensp;&ensp;&ensp;&ensp;(3)不设置专门的设备处理进程，而只为各类设备设置相应的设备驱动程序，供用户或系统进程调用。这种方式目前用得较多。  </p>
<h3 id="6-4-2-设备驱动程序的处理过程"><a href="#6-4-2-设备驱动程序的处理过程" class="headerlink" title="6.4.2 设备驱动程序的处理过程"></a>6.4.2 设备驱动程序的处理过程</h3><p>&ensp;&ensp;&ensp;&ensp;(1)将抽象要求转换为具体要求<br>&ensp;&ensp;&ensp;&ensp;如：将抽象要求中的盘块号转换为磁盘的盘面、 磁道号及扇区。<br>&ensp;&ensp;&ensp;&ensp;(2)对服务请求进行校验<br>&ensp;&ensp;&ensp;&ensp;如：用户试图请求从打印机输入数据，系统应予以拒绝。<br>&ensp;&ensp;&ensp;&ensp;(3)检查设备的状态<br>&ensp;&ensp;&ensp;&ensp;如：为了向某设备写入数据，应先检查该设备是否处于接收就绪状态。<br>&ensp;&ensp;&ensp;&ensp;(4)传送必要的参数<br>&ensp;&ensp;&ensp;&ensp;在确定设备处于就绪状态后，还需传送必要的参数。<br>&ensp;&ensp;&ensp;&ensp;(5)启动I/O设备<br>&ensp;&ensp;&ensp;&ensp;完成准备工作之后，驱动程序可以向控制器中的命令寄存器传送相应的控制命令。驱动程序阻塞，在设备控制器的控制下进行I/O操作，直到中断到来时才将它唤醒。    </p>
<h3 id="6-4-3-对I-O设备的控制方式"><a href="#6-4-3-对I-O设备的控制方式" class="headerlink" title="6.4.3 对I/O设备的控制方式"></a>6.4.3 对I/O设备的控制方式</h3><p>&ensp;&ensp;&ensp;&ensp;I/O控制方式的宗旨：尽量减少主机对I/O控制的干预，把主机从繁杂的I/O控制事务中解脱出来，以便更多地去完成数据处理任务。  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）轮询的可编程I/O<br>&ensp;&ensp;&ensp;&ensp;利用I/O测试指令测试设备的闲忙，极大地浪费CPU<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8717.png"><br>&ensp;&ensp;&ensp;&ensp;2）中断的可编程的I/O<br>&ensp;&ensp;&ensp;&ensp;当设备完成I/O操作，便以中断请求方式通知CPU，然后进行相应处理，浪费CPU<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8718.png"><br>&ensp;&ensp;&ensp;&ensp;3）直接存储器访问<br>&ensp;&ensp;&ensp;&ensp;由DMA控制器送出内存地址和发出内存读、设备写或者设备读、内存写的控制信号完成内存与设备之间的直接数据传送，而不用CPU干预。仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的。数据传输的基本单位是数据块。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8719.png"><br>&ensp;&ensp;&ensp;&ensp;4）I/O通道<br>&ensp;&ensp;&ensp;&ensp;通道是独立于CPU的、专门负责数据的输入输出传输工作的处理器，它对外部设备实统一管理，代替CPU对I/O操作进行控制，从而使I/O操作可以与CPU并行工作。  </p>
<h2 id="6-5-与设备无关的I-O软件"><a href="#6-5-与设备无关的I-O软件" class="headerlink" title="6.5 与设备无关的I/O软件"></a>6.5 与设备无关的I/O软件</h2><p>&ensp;&ensp;&ensp;&ensp;设备独立性的基本含义：<br>&ensp;&ensp;&ensp;&ensp;应用程序中所使用的设备，不局限于使用某个具体的物理设备，也称为设备无关性。<br>&ensp;&ensp;&ensp;&ensp;为了实现设备独立性，必须再在设备驱动程序之上设置一层软件，称为与设备无关的I/O软件，或设备独立性软件。 </p>
<h3 id="6-5-1-与设备无关软件的基本概念"><a href="#6-5-1-与设备无关软件的基本概念" class="headerlink" title="6.5.1 与设备无关软件的基本概念"></a>6.5.1 与设备无关软件的基本概念</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.以物理设备名使用设备</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;早期OS中，应用程序用物理设备名使用设备，也即程序与系统中的物理设备直接相关。<br>&ensp;&ensp;&ensp;&ensp;问题：<br>&ensp;&ensp;&ensp;&ensp;当程序请求的物理设备被占用时，即使系统中还用相同设备空闲，也无法将设备分配给该应用程序。<br>&ensp;&ensp;&ensp;&ensp;当程序所需设备在系统中已经被更新时，该应用程序将再也无法在该系统上运行。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.引入了逻辑设备名</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;逻辑设备是抽象的设备名。<br>&ensp;&ensp;&ensp;&ensp;/dev/printer<br>&ensp;&ensp;&ensp;&ensp;(1)是抽象的设备名，易于实现设备的灵活分配，例如，/dev/printer，只是说明使用打印机打印，具体并没有指出使用哪台打印机输出。<br>&ensp;&ensp;&ensp;&ensp;(2)I/O重定向：指用于I/O操作的设备可以更换（重定向），而不必改变应用程序。例如：调试程序时，输出信息到显示器，调试结束后，输出结果到打印机。它具有很大的实用价值。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.逻辑设备名到物理设备名的转换</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;因系统只识别物理设备名，所以在实际执行中，需要实现逻辑设备名到物理设备名的转换。这类似与存储器管理中的逻辑地址和物理地址的概念。<br>&ensp;&ensp;&ensp;&ensp;因此，需要在系统中配置一张逻辑设备表用于转换。  </p>
<h3 id="6-5-2-与设备无关的软件"><a href="#6-5-2-与设备无关的软件" class="headerlink" title="6.5.2 与设备无关的软件"></a>6.5.2 与设备无关的软件</h3><p>&ensp;&ensp;&ensp;&ensp;与设备无关的软件是I/O系统最高层软件，在其下面是设备驱动程序，但它和设备驱动程序之间的界限，将随<strong>操作系统和设备的不同而有所差异</strong>。总的来说，在与设备无关的软件中，包括了执行所有设备公有操作的软件，具体有如下几项。    </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.设备驱动程序的统一接口</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;为使所有驱动程序具有统一接口，一方面要求每个驱动程序与OS之间有相同或相近接口；另一方面，要求将抽象设备名转换为物理设备名并进一步找到相应物理设备的驱动程序入口。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.缓冲管理</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;缓解设备与CPU之间的速度不匹配问题。分为单缓冲区，双缓冲区，循环缓冲区，公用缓冲池等。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.差错控制</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）暂时性错误（2）持久性错误  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.对独占设备的分配和回收</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;由系统统一分配，不允许进程自行使用。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>5.独立于设备的逻辑数据块</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;不同类型设备的数据交换单位是不同的，传输速率也各不相同。即使同一类型设备，其数据交换单位的大小也是由差异的。设备独立性软件能隐藏这些差异。  </p>
<h3 id="6-5-3-设备分配"><a href="#6-5-3-设备分配" class="headerlink" title="6.5.3 设备分配"></a>6.5.3 设备分配</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.设备分配中的数据结构</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）设备控制表DCT<br>&ensp;&ensp;&ensp;&ensp;在用于设备分配的数据结构中，记录了对设备或控制器进行控制所需的信息。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8720.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;2）控制器控制表（COCT），通道控制表(CHCT)和系统设备表(SDT)<br>&ensp;&ensp;&ensp;&ensp;（1）控制器控制表COCT ：<br>&ensp;&ensp;&ensp;&ensp;为每一个控制器都设置一张，记录控制器情况。<br>&ensp;&ensp;&ensp;&ensp;（2）通道控制表（CHCT)：<br>&ensp;&ensp;&ensp;&ensp;为每一个通道都设置一张，记录通道情况。<br>&ensp;&ensp;&ensp;&ensp;（3）系统设备表SDT：<br>&ensp;&ensp;&ensp;&ensp;这是系统范围的数据结构，记录系统中全部设备的情况，每个设备占一个表目。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8721.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.设备分配时应考虑的因素</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）设备的固有属性<br>&ensp;&ensp;&ensp;&ensp;（1）独占设备的分配策略。将该设备分配给进程后，便由进程独占，直至该进程释放。<br>&ensp;&ensp;&ensp;&ensp;（2）共享设备的分配策略。可同时分配给多个进程，注意进程访问次序的合理调度。<br>&ensp;&ensp;&ensp;&ensp;（3）虚拟设备的分配策略。虚拟设备属于可共享的设备。可同时分配给多个进程使用  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）设备分配算法<br>&ensp;&ensp;&ensp;&ensp;（1）FIFO （2）优先级高者优先  </p>
<p>&ensp;&ensp;&ensp;&ensp;3）设备分配中的安全性<br>&ensp;&ensp;&ensp;&ensp;安全分配(同步)：每当进程发出一个I/O请求后，即阻塞，直到其I/O完成。打破了死锁条件。<br>&ensp;&ensp;&ensp;&ensp;缺点：CPU、I/O 是串行工作的，进程进展缓慢。<br>&ensp;&ensp;&ensp;&ensp;不安全分配（异步）：需进行安全性检查，进程执行效率相对较高。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.独占设备的分配程序</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）基本的设备分配程序<br>&ensp;&ensp;&ensp;&ensp;（1）分配设备<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8722.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）分配控制器<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8723.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;（3）分配通道<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8724.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;只有在设备、控制器和通道三者都分配成功时，这次的I/O请求才算成功，便可启动I/O设备进行数据传输  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）设备分配程序的改进  </p>
<p>&ensp;&ensp;&ensp;&ensp;基本分配的缺点：<br>&ensp;&ensp;&ensp;&ensp;进程是以物理设备名提出I/O请求的。如果所指定的设备已分配给其它进程，则分配失败。或者说上面的设备分配程序，不具有与设备无关性。<br>&ensp;&ensp;&ensp;&ensp;改进：为获得设备的独立性，进程应使用逻辑设备名请求I/O。系统首先从SDT中，找出第一个该类设备的DCT。若该设备忙，又查找第二个该类设备的DCT，仅当所有该类设备都忙时，才把进程，挂在该类设备的等待队列上。而只要有一个该类设备可用，系统便进一步计算分配该设备的安全性。如安全，便可把设备分配给它。  </p>
<h3 id="6-5-4-逻辑设备名到物理设备名映射的实现"><a href="#6-5-4-逻辑设备名到物理设备名映射的实现" class="headerlink" title="6.5.4 逻辑设备名到物理设备名映射的实现"></a>6.5.4 逻辑设备名到物理设备名映射的实现</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.逻辑设备表（LUT：Logical Unit Table）</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在逻辑设备表的每个表目中包含了三项：逻辑设备名、物理设备名和设备驱动程序的入口地址。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8725.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.逻辑设备表的设置问题</strong>    </p>
<p>⑴ 在整个系统中只设置一张LUT，这种方式主要用于单用户系统中。不允许用户使用相同的逻辑设备名<br>⑵ 为每个用户设置一张LUT，当用户登入系统时，为其建立一个进程，同时也建立一张LUT，并将该表放入进程的PCB中。在多用户系统中配置了一张<strong>系统设备表</strong>。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8726.png">   </p>
<h2 id="6-6-用户层的I-O软件"><a href="#6-6-用户层的I-O软件" class="headerlink" title="6.6 用户层的I/O软件"></a>6.6 用户层的I/O软件</h2><p>一般而言，大部分的I/O软件都放在操作系统内部，但仍有一小部分在用户层，其中包括与用户程序链接在一起的库函数，以及完全运行于内核之外的假脱机系统等。  </p>
<h3 id="6-6-1-系统调用与库函数"><a href="#6-6-1-系统调用与库函数" class="headerlink" title="6.6.1 系统调用与库函数"></a>6.6.1 系统调用与库函数</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.系统调用</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;为使诸进程能有条不紊地使用I/O设备，且能保护设备的安全性，不允许运行在用户态的应用进程，去直接调用运行在核心态（系统态）的OS过程。<br>&ensp;&ensp;&ensp;&ensp;应用进程在运行时，又必须取得OS所提供的服务。<br>&ensp;&ensp;&ensp;&ensp;OS在用户层中引入了系统调用，应用程序可以通过它，间接调用OS中的I/O过程，对I/O设备进行操作。  </p>
<p>&ensp;&ensp;&ensp;&ensp;当应用程序需要执行某种I/O操作时，在该程序中必须使用系统调用。OS捕获到应用程序中的系统调用后，便将CPU的状态从用户态转换到核心态，然后转向操作系统中相应过程，由该过程完成所需的I/O操作。执行完成后，系统又将CPU状态从核心态转换到用户态，返回到应用程序继续执行。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8727.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.库函数</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在C语言以及UNIX系统中，系统调用与各系统调用所使用的库函数之间几乎是一一对应的。C语言中，首先提供了与系统调用相对应的库函数。<br>&ensp;&ensp;&ensp;&ensp;标准C库函数提供的I/O操作函数如fopen, fread, fwrite, fclose, fflush, fseek等，需包含头文件stdio.h。<br>&ensp;&ensp;&ensp;&ensp;内核和库函数之间的关系：内核提供了操作系统的基本功能，而库函数扩展了OS内核，使用户能方便取得操作系统的服务。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.系统调用库函数</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）系统调用是为了方便应用使用操作系统的接口，而库函数是为了方便人们编写应用程序而引出的，比如你自己编写一个函数其实也可以说就是一个库函数。<br>&ensp;&ensp;&ensp;&ensp;2）系统调用可以理解为内核提供给我们在用户态用的接口函数，可以认为是某种内核的库函数。<br>&ensp;&ensp;&ensp;&ensp;3）read就是系统调用,而fread就是C标准库函数。<br>&ensp;&ensp;&ensp;&ensp;4）写程序直接使用的是库函数，而库函数内部可能就是调用的同名系统调用。  </p>
<h3 id="6-6-2-假脱机-Spooling-系统"><a href="#6-6-2-假脱机-Spooling-系统" class="headerlink" title="6.6.2 假脱机(Spooling)系统"></a>6.6.2 假脱机(Spooling)系统</h3><p>&ensp;&ensp;&ensp;&ensp;在20世纪50年代，为了缓和CPU的高速性与I/O设备低速性间的矛盾，而引入了脱机输入、脱机输出技术。该技术是利用专门的外围控制机，先将低速I/O设备上的数据，传送到高速磁盘上，或者相反。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.假脱机技术</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;用两道程序模拟外围控制机功能。<br>&ensp;&ensp;&ensp;&ensp;一道模拟脱机输入时的外围控制机功能，把低速I/O设备上的数据传送到高速磁盘。另一道模拟脱机输出时外围机的控制机功能，把数据从磁盘传送到低速输出设备上。<br>&ensp;&ensp;&ensp;&ensp;我们把这种在联机情况下实现的同时外围操作的技术，称为SPOOLing(Simultaneaus Periphernal Operating OnLine)技术，或称为假脱机技术。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8728.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.SPOOLing的组成</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;SPOOLing系统主要由以下四部分组成<br>&ensp;&ensp;&ensp;&ensp;1）输入井和输出井。这是磁盘上开辟出来的两个区域。输入井和输出井中的数据一般以文件形式组织，称为井文件。<br>&ensp;&ensp;&ensp;&ensp;2）输入缓冲区和输出缓冲区。这是内存中开辟出来的两个区域，用于缓和CPU和磁盘之间速度不匹配的矛盾。<br>&ensp;&ensp;&ensp;&ensp;3）输入进程和输出进程。输入进程用于模拟脱机输入时的外围机而输出进程用于模拟脱机输出时的外围机。<br>&ensp;&ensp;&ensp;&ensp;4）井管理程序。用于控制作业与井之间的信息交换。当作业执行过程中向某台设备发出I/O请求时，由OS调用井管理程序，由其控制从输入井读取信息或将信息输出至输出井。  </p>
<p><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8729.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.SPOOLing系统的特点</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）提高了I/O速度<br>&ensp;&ensp;&ensp;&ensp;2）将独占设备改造为共享设备<br>&ensp;&ensp;&ensp;&ensp;3）实现了虚拟设备功能    </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.假脱机打印机系统</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;打印机属于独占设备。利用假脱机技术，可将它改造为一台可供多个用户共享的打印设备，从而提高设备的利用率，也方便了用户。<br>&ensp;&ensp;&ensp;&ensp;假脱机打印系统的构成：<br>&ensp;&ensp;&ensp;&ensp;1）磁盘缓冲区<br>&ensp;&ensp;&ensp;&ensp;2）打印缓冲区<br>&ensp;&ensp;&ensp;&ensp;3）假脱机管理进程和假脱机打印进程<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8730.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;当用户进程请求打印输出时,SPOOLing系统同意为它打印输出,但并不真正立即把打印机分配给用户进程,而由假脱机管理进程为它做两件事:<br>&ensp;&ensp;&ensp;&ensp;①在输出井中为之请求一个空闲磁盘块区,并将要打印的数据送入其中。<br>&ensp;&ensp;&ensp;&ensp;②再为用户进程申请一张空白的用户请求打印表,并将用户的打印要求填入其中,再将该表挂在请求打印队列上。<br>&ensp;&ensp;&ensp;&ensp;①假脱机打印进程真正完成打印输出过程:<br>&ensp;&ensp;&ensp;&ensp;如果打印机空闲,该进程将从请求打印队列的队首取出一张请求打印表,根据表中的要求将要打印的数据,从输出井传送到输出缓冲区,再由打印机进行打印。<br>&ensp;&ensp;&ensp;&ensp;②打印完毕后,该进程再查看请求打印队列中是否还有等待打印的请求表,如此下去,直至请求打印队列为空,假脱机打印进程才将自己阻塞起来。仅当下次再由打印请求时,假脱机打印进程才被唤醒。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>5.守护进程</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;守护进程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。守护进程是一种很有用的进程。<br>利用守护进程实现打印机：<br>&ensp;&ensp;&ensp;&ensp;①为打印机建立一个守护进程，由它执行一部分原来由假脱机管理进程功能的功能。<br>&ensp;&ensp;&ensp;&ensp;②由请求进程生成一份要求打印的文件，并将用户请求打印文件放入假脱机文件队列（目录）中。<br>&ensp;&ensp;&ensp;&ensp;把一台独占设备改造为可为多个进程共享的设备：<br>&ensp;&ensp;&ensp;&ensp;凡是需要将独占设备改造为可供多个进程共享的设备时，都要为该设备配置一个守护进程和一个假脱机文件队列（目录）。<br>&ensp;&ensp;&ensp;&ensp;守护进程是允许使用该独占设备的唯一进程，所有其它进程都不能直接使用该设备，只能将对该设备的使用要求写入一份文件中，放在假脱机目录中。由守护进程按照目录中的文件，依次来完成诸进程对该设备的请求。  </p>
<h2 id="6-7-缓冲区管理"><a href="#6-7-缓冲区管理" class="headerlink" title="6.7 缓冲区管理"></a>6.7 缓冲区管理</h2><p>&ensp;&ensp;&ensp;&ensp;现代OS中，几乎所有I/O设备与处理机交换设备时都用到了缓冲区。缓冲区是一个存储区域，它可以由专门的硬件寄存器组成，但成本较高。一般只在对速度要求很高的场合使用。一般情况下，都是利用内存作为缓冲区。   </p>
<h3 id="6-7-1-缓冲的引入"><a href="#6-7-1-缓冲的引入" class="headerlink" title="6.7.1 缓冲的引入"></a>6.7.1 缓冲的引入</h3><p>&ensp;&ensp;&ensp;&ensp;1）缓和CPU与I/O设备间速度不匹配的矛盾<br>&ensp;&ensp;&ensp;&ensp;2）减少对CPU的中断频率，放宽对CPU中断响应时间的限制<br>&ensp;&ensp;&ensp;&ensp;3）解决数据粒度不匹配的问题<br>&ensp;&ensp;&ensp;&ensp;4）提高CPU和I/O设备之间的并行性<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8731.png">   </p>
<h3 id="6-7-2-单缓冲区和双缓冲区"><a href="#6-7-2-单缓冲区和双缓冲区" class="headerlink" title="6.7.2 单缓冲区和双缓冲区"></a>6.7.2 单缓冲区和双缓冲区</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.单缓冲区</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在单缓冲情况下，每当用户进程发出一I/O请求时，操作系统便在主存中为之分配一缓冲区，如下图所示。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8732.png"><br>&ensp;&ensp;&ensp;&ensp;系统对每一块数据的处理时间表示为Max(C，T)+M。<br>&ensp;&ensp;&ensp;&ensp;T:从磁盘把一块数据送至缓冲区的时间<br>&ensp;&ensp;&ensp;&ensp;M:OS将缓冲区中的数据传送到用户区的时间<br>&ensp;&ensp;&ensp;&ensp;C:CPU对这一块数据的处理时间  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.双缓冲区</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;也称为缓冲对换(Buffer Swapping)。<br>&ensp;&ensp;&ensp;&ensp;在设备输入时，先将数据送入第一缓冲区，装满后便转向第二缓冲区。此时操作系统可以从第一缓冲区中移出数据，并送入用户进程。接着由CPU对数据进行计算。在双缓冲时，系统处理一块数据的时间可以粗略地认为是Max(C，T) 。实际上是MAX(C+M,T) 内存的移动时间M忽略不计<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8733.png">   </p>
<p>如果在实现两台机器之间通信时仅配置了单缓冲区，则任一时刻只能实现单向数据传输。为了实现双向数据传输，必须在两台机器中都设置双缓冲区。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8734.png">  </p>
<h3 id="6-7-3-环形缓冲区"><a href="#6-7-3-环形缓冲区" class="headerlink" title="6.7.3 环形缓冲区"></a>6.7.3 环形缓冲区</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.环形缓冲区的组成</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）多个缓冲区：在环形缓冲中包括多个缓冲区，其每个缓冲区的大小相同。<br>&ensp;&ensp;&ensp;&ensp;作为输入的多缓冲区可分为三种类型:<br>&ensp;&ensp;&ensp;&ensp;①用于装输入数据的空缓冲区R<br>&ensp;&ensp;&ensp;&ensp;②已装满数据的缓冲区G<br>&ensp;&ensp;&ensp;&ensp;③计算进程正在使用的现行工作缓冲区C  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）多个指针：用于指示计算进程下一个可用缓冲区G的指针Nextg、 指示输入进程下次可用的空缓冲区R的指针Nexti，用于指示计算进程正在使用的缓冲区C的指针Current。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8735.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.环形缓冲区的使用</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;(1)Getbuf过程：<br>&ensp;&ensp;&ensp;&ensp;计算进程调用Getbuf过程使用缓冲区中的数据。<br>&ensp;&ensp;&ensp;&ensp;该过程将由指针Nextg所指示的缓冲区提供给进程使用，相应地，须把它改为现行工作缓冲区，并令Current指针指向该缓冲区的第一个单元，同时将Nextg移向下一个G缓冲区。<br>&ensp;&ensp;&ensp;&ensp;(2)Releasebuf过程：<br>&ensp;&ensp;&ensp;&ensp;当计算进程把C缓冲区中的数据提取完毕时，便调用Releasebuf过程，将缓冲区C释放。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.进程之间的同步问题</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;(1) Nexti指针追赶上Nextg指针：<br>&ensp;&ensp;&ensp;&ensp;这意味着输入进程输入数据的速度大于计算进程处理数据的速度，已把全部可用的空缓冲区装满，再无缓冲区可用。这种情况被称为<strong>系统受计算限制</strong>。<br>&ensp;&ensp;&ensp;&ensp;(2) Nextg指针追赶上Nexti指针：<br>&ensp;&ensp;&ensp;&ensp;这意味着输入数据的速度低于计算进程处理数据的速度，使全部装有输入数据的缓冲区都被抽空，再无装有数据的缓冲区供计算进程提取数据。这种情况被称为<strong>系统受I/O限制</strong>。  </p>
<h3 id="6-7-4-缓冲池"><a href="#6-7-4-缓冲池" class="headerlink" title="6.7.4 缓冲池"></a>6.7.4 缓冲池</h3><p>&ensp;&ensp;&ensp;&ensp;上述的缓冲区是专门为特定的生产者和消费者设置的，它们属于专用缓冲。<br>&ensp;&ensp;&ensp;&ensp;当系统较大时，应该有许多这样的循环缓冲，这不仅要消耗大量的内存空间，而且其利用率不高。<br>&ensp;&ensp;&ensp;&ensp;为了提高缓冲区的利用率，目前广泛流行既可用于输入又可用于输出的公用缓冲池，在池中设置了多个可供若干个进程共享的缓冲区。<br>&ensp;&ensp;&ensp;&ensp;缓冲池与缓冲区的区别：缓冲区仅仅是一组内存块的链表，而缓冲池则包含了一个管理的数据结构和一组操作函数的管理机制，用于管理多个缓冲区。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.缓冲池的组成</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;三个队列：<br>&ensp;&ensp;&ensp;&ensp;1）空缓冲队列emq<br>&ensp;&ensp;&ensp;&ensp;2）输入队列inq<br>&ensp;&ensp;&ensp;&ensp;3）输出队列outq<br>&ensp;&ensp;&ensp;&ensp;四种工作缓冲区：<br>&ensp;&ensp;&ensp;&ensp;1）用于收容输入数据的工作缓冲区<br>&ensp;&ensp;&ensp;&ensp;2）用于提取输入数据的工作缓冲区<br>&ensp;&ensp;&ensp;&ensp;3）用于收容输出数据的工作缓冲区<br>&ensp;&ensp;&ensp;&ensp;4）用于提取输出数据的工作缓冲区  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.Getbuf过程和Putbuf过程</strong>   </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Getbuf</span><span class="params">(<span class="keyword">unsigned</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Wait (RS(type));</span><br><span class="line">   Wait(MS(type));   B(number)=Takebuf(type);</span><br><span class="line">   Signal(MS(type));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Putbuf</span><span class="params">(type, number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Wait(MS(type));</span><br><span class="line">   Addbuf(type, number) ;</span><br><span class="line">   Signal(MS(type));</span><br><span class="line">    Signal(RS(type));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;缓冲池中的队列本身是临界资源，过关进程在访问一个队列时需互斥同步。为了实现互斥访问队列，可为每个队列设置一个互斥信号量MS(type)。实现同步信号量RS(type)  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.缓冲区的工作方式</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1)收容输入:输入进程调用Getbuf(emq)，从空缓冲区队首摘下一个缓冲区，把它作为收容输入工作缓冲区hin，再调用PutBuf(inq,hin)过程，将它挂在输入队列inq队列上。<br>&ensp;&ensp;&ensp;&ensp;2)提取输入：计算进程调用Getbuf(inq)，从输入缓冲区队首摘下一个缓冲区，把它作为提取输入工作缓冲区sin，输入提取完毕后，再调用PutBuf(emq,sin)过程，将sin挂在空队列emq队列上。<br>&ensp;&ensp;&ensp;&ensp;3)收容输出:计算进程调用Getbuf(emq)，从空缓冲区队首摘下一个缓冲区，把它作为收容输出工作缓冲区hout，再调用PutBuf(outq,hout)过程，将它挂在输出队列hout队列上。<br>&ensp;&ensp;&ensp;&ensp;4)提取输出:输出进程调用Getbuf(outq)，从输出缓冲区队首摘下一个缓冲区，把它作为提取输出工作缓冲区sout，输出提取完毕后，再调用PutBuf(emq,sout)过程，将sout挂在空队列emq队列上。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8736.png">    </p>
<h2 id="6-8-磁盘存储器的性能和调度"><a href="#6-8-磁盘存储器的性能和调度" class="headerlink" title="6.8 磁盘存储器的性能和调度"></a>6.8 磁盘存储器的性能和调度</h2><p>&ensp;&ensp;&ensp;&ensp;磁盘存储器是计算机系统中最为重要的存储设备。<br>&ensp;&ensp;&ensp;&ensp;磁盘I/O速度的高低和磁盘系统的可靠性，将直接影响到系统的性能。可以通过多种途径改善磁盘系统的性能。具体包括：<br>&ensp;&ensp;&ensp;&ensp;①选择好的磁盘调度算法，以减少磁盘寻道时间<br>&ensp;&ensp;&ensp;&ensp;②提高磁盘I/O速度<br>&ensp;&ensp;&ensp;&ensp;③采取冗余技术，提高磁盘可靠性  </p>
<h3 id="6-6-1-磁盘性能简述"><a href="#6-6-1-磁盘性能简述" class="headerlink" title="6.6.1 磁盘性能简述"></a>6.6.1 磁盘性能简述</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.数据的组织和格式</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;磁盘设备中，可包含一个或多个盘片，每片分两面，每面又可分成若干条磁道(典型值为500<del>2000条磁道)，磁道之间有必要的空隙。<br>&ensp;&ensp;&ensp;&ensp;每条磁道上可存储相同数目的二进制位。这样磁盘密度即每英寸中所存储的位数，显然是内层磁道的密度较外层磁道的密度高。<br>&ensp;&ensp;&ensp;&ensp;每条磁道又分成若干个扇区，其典型值为10</del>100个扇区。每个扇区的大小相当于一个盘块。各扇区之间同样要保留一定的间隙。<br>&ensp;&ensp;&ensp;&ensp;一个物理记录存储在一个扇区上，磁盘上能存储的物理块数目是由扇区数，磁道数以及磁盘面数所决定的。<br>&ensp;&ensp;&ensp;&ensp;例如：一个10GB的磁盘，有8个双面可存储盘片，共16个存储面，每面有16383个磁道，63个扇区。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8737.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;为在磁盘上存储数据，必须将磁盘格式化。<br>&ensp;&ensp;&ensp;&ensp;温盘(温彻斯特)的一条磁道含有30个固定大小的扇区，每个扇区容量为600个字节。其中，512字节用于存放数据，其余用于存放控制信息。每个扇区包括两个字段：<br>&ensp;&ensp;&ensp;&ensp;①标识符字段<br>&ensp;&ensp;&ensp;&ensp;其中一个字节的SYNCH具有特定的位图像，作为该字段的定界符。利用磁道号、磁头号及扇区号三者来标识一个扇区; CRC字段用于段校验。<br>&ensp;&ensp;&ensp;&ensp;②数据字段<br>&ensp;&ensp;&ensp;&ensp;存放512个字节的数据。<br>&ensp;&ensp;&ensp;&ensp;每个磁道的不同扇区，每个扇区的不同字段之间，为了方便辨识，都设置了间距。<br>&ensp;&ensp;&ensp;&ensp;在磁盘格式化后，一般要对磁盘进行分区。在逻辑上，每个分区就是一个独立的逻辑磁盘。每个分区的起始扇区和大小都记录在磁盘0扇区的主引导记录分区表中。在这个分区表中必须有一个分区被标记成活动的（即引导块），以保证能够从硬盘引导系统。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8738.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.磁盘的类型</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）固定头磁盘：<br>&ensp;&ensp;&ensp;&ensp;这种磁盘在每条磁道上都有一读/写磁头，所有的磁头都被装在一刚性磁臂中。通过这些磁头可访问所有各磁道，并进行并行读/写，有效地提高了磁盘的I/O速度。这种结构的磁盘主要用于大容量磁盘上。<br>&ensp;&ensp;&ensp;&ensp;（2）移动头磁盘：<br>&ensp;&ensp;&ensp;&ensp;每一个盘面仅配有一个磁头，也被装入磁臂中。为能访问该盘面上的所有磁道，该磁头必须能移动以进行寻道。可见，移动磁头仅能以串行方式读/写，致使其I/O速度较慢；但由于其结构简单，故仍广泛应用于中小型磁盘设备中。在微型机上配置的温盘和软盘，都采用移动磁头结构。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.磁盘访问时间</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;磁盘在工作时，以恒定速率旋转。为了读或写，磁头必须能移动到所要求的磁道上，并等待所要求的扇区的开始位置旋转到磁头下，然后再开始读或写数据。对磁盘的访问时间，包括以下三部分：<br>&ensp;&ensp;&ensp;&ensp;1）寻道时间Ts<br>&ensp;&ensp;&ensp;&ensp;把磁臂(磁头)从当前位置移动到指定磁道上所经历的时间。该时间是启动磁臂的时间s与磁头移动n条磁道所花费的时间之和，即：<br>&ensp;&ensp;&ensp;&ensp;Ts =m*n+s<br>&ensp;&ensp;&ensp;&ensp;m是一常数，它与磁盘驱动器的速度有关。对一般磁盘，m=0.2；对高速磁盘，m≤0.1,磁臂启动时间约为2ms。对一般的温盘，其寻道时间将随寻道距离的增大而增大，大体上是5-30ms<br>&ensp;&ensp;&ensp;&ensp;2）旋转时间Tτ<br>&ensp;&ensp;&ensp;&ensp;Tτ是指定扇区移动到磁头下面所经历的时间。对于硬盘，一般的旋转速度为15000r/min,每转需时4ms. 平均旋转延迟时间Tτ为2ms. 对于软盘，其旋转速度为300或600r/min，这样，平均Tτ为50~100ms。<br>&ensp;&ensp;&ensp;&ensp;3）传输时间Tt<br>&ensp;&ensp;&ensp;&ensp;是指把数据从磁盘读出，或向磁盘写入数据所经历的时间。 Tt的大小与每次所读/写的字节数b及旋转速度有关：<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8739.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;r为磁盘以秒计的旋转速度；N为一条磁道上的字节数。当一次读/写的字节数相当于半条磁道上的字节数时， Tt与Tτ相同。<br>&ensp;&ensp;&ensp;&ensp;因此，可将访问时间Ta表示为:<br>&ensp;&ensp;&ensp;&ensp;Ta = Ts +1/2r+b/rN<br>&ensp;&ensp;&ensp;&ensp;由上式可以看出，在访问时间中，寻道 时间和旋转延迟时间，基本上都与所读/写数据的多少无关，而且它通常是占据了访问时间的大头。<br>&ensp;&ensp;&ensp;&ensp;例如:我们假定寻道时间和旋转延迟时间平均为20ms，而磁道的传输速率为10MB/s，如果传输10KB字节，此时总的访问时间为21ms，传输时间所占比例是相当的小。  </p>
<h3 id="6-6-2-早期的磁盘调度算法"><a href="#6-6-2-早期的磁盘调度算法" class="headerlink" title="6.6.2 早期的磁盘调度算法"></a>6.6.2 早期的磁盘调度算法</h3><p>当有多个进程都请求访问磁盘时，采用一种适当的磁盘调度算法，使各进程对磁盘的平均访问(主要是寻道)时间最小。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.先来先服务（FCFS）</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;最简单的磁盘调度算法。根据进程请求访问磁盘的先后次序进行调度。<br>&ensp;&ensp;&ensp;&ensp;优点: 公平、简单。每个进程的请求都能依次得到处理，不会出现某一进程的请求长期得不到满足的情况。但由于未对寻道进行优化，致使平均寻道时间可能较长。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8740.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.最短寻道时间优先（SSTF）</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;首先选择要求访问的磁道与当前磁头所在的磁道，距离最近的进程，以使每次的寻道时间最短。但这种算法不能保证平均寻道时间最短。<br>&ensp;&ensp;&ensp;&ensp;首先选择要求访问的磁道与当前磁头所在的磁道，距离最近的进程，以使每次的寻道时间最短。但这种算法不能保证平均寻道时间最短。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8741.png">    </p>
<h3 id="6-8-3-基于扫描的磁盘调度算法"><a href="#6-8-3-基于扫描的磁盘调度算法" class="headerlink" title="6.8.3 基于扫描的磁盘调度算法"></a>6.8.3 基于扫描的磁盘调度算法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.扫描算法</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;SSTF算法虽然获得较好的寻道性能，但它可能导致某些进程发生“饥饿”(Starvation)。<br>&ensp;&ensp;&ensp;&ensp;对SSTF算法略加修改后所形成的SCAN算法，即可防止老进程出现饥饿现象。<br>&ensp;&ensp;&ensp;&ensp;该算法不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向。<br>&ensp;&ensp;&ensp;&ensp;例如：当磁头正在自里向外移动时，SCAN算法所选择的下一个访问对象应既在当前磁道之外，又是距离最近的磁道。 这样自里向外地访问，直至再无更外的磁道需要访问时，才将磁臂换向，自外向里移动。<br>&ensp;&ensp;&ensp;&ensp;这种算法中磁头移动的规律颇似电梯的运行，故又常称为电梯调度算法。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8742.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.循环扫描算法（CSCAN）</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;SCAN算法既能获得较好的性能，又能访止进程饥饿，广泛用于大、中、小型机和网络中的磁盘调度。　<br>&ensp;&ensp;&ensp;&ensp;问题：当磁头刚从里向外移动过某一磁道时，恰有一进程请求访问此磁道，这时该进程必须等待，待磁头从里向外，然后再从外向里扫描完所有要访问的磁道后，才处理该进程的请求，致使该进程的请求被严重地推迟。<br>&ensp;&ensp;&ensp;&ensp;CSCAN算法规定磁头单向移动。例如，只自里向外移动，当磁头移到最外的磁道时，磁头立即返回到最里的欲访磁道，即将最小磁道号紧接着最大磁道号构成循环，进行扫描。采用循环扫描方式后，上述请求进程的请求延迟，将从原来的2T减T+Smax<br>&ensp;&ensp;&ensp;&ensp;T为由里向外或由外向里扫描完所有要访问的磁道所需的寻道时间，而Smax是将磁头从最外面被访问的磁道直接移到最里边欲访问的磁道所需的寻道时间(或相反)。<br><img src="/2021/06/16/os-6/%E5%9B%BE%E7%89%8743.png">     </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.NStepSCAN 和 FSCAN</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）NStepSCAN算法<br>&ensp;&ensp;&ensp;&ensp;在SSTF、SCAN及CSCAN几种调度算法中，都可能出现磁臂停留在某处不动的情况。这一现象称为磁臂粘着  (Armstickiness)。<br>&ensp;&ensp;&ensp;&ensp;N步SCAN算法是将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法依次处理这些子队列<br>&ensp;&ensp;&ensp;&ensp;每处理一个队列时，又是按SCAN算法，对一个队列处理完后又处理其它队列。当处理某子队列时，如果又出现新的磁盘I/O请求，便将新请求进程放入其他队列，这样就可避免出现粘着现象。<br>&ensp;&ensp;&ensp;&ensp;当N值取得很大时，会使N步扫描算法的性能，接近于SCAN算法的性能，当N=1时，N步SCAN算法退化为FCFS算法。</p>
<p>&ensp;&ensp;&ensp;&ensp;2）FSCAN算法<br>&ensp;&ensp;&ensp;&ensp;FSCAN算法实质上是N步SCAN算法的简化。它只将磁盘请求访问队列分成两个子队列。一是当前所有请求磁盘I/O的进程形成的队列，由磁盘调度按SCAN算法进行处理。另一个队列则是在扫描期间，新出现的所有请求磁盘I/O进程的队列，放入另一等待处理的请求队列。这样，所有的新请求都将被推迟到下一次扫描时处理。  </p>
<p>练习ppt 第六章 168-176</p>

    </div>

    
    
    
<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------以上<i class="fa fa-paw"></i>（或许会有不定时更新）-------------</div>
    
</div>

  
</div>
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Komeiji Satori
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://kome1jisatori.github.io/2021/06/16/os-6/" title="操作系统笔记——第六章">https://kome1jisatori.github.io/2021/06/16/os-6/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/" rel="tag"># 课堂笔记</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/06/15/os-5/" rel="prev" title="操作系统笔记——第五章">
      <i class="fa fa-chevron-left"></i> 操作系统笔记——第五章
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/06/19/os-7/" rel="next" title="操作系统笔记——第七章">
      操作系统笔记——第七章 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F"><span class="nav-text">第六章 输入输出系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-I-O%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD%E3%80%81%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="nav-text">6.1 I&#x2F;O系统的功能、模型和接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-I-O%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="nav-text">6.1.1 I&#x2F;O系统的基本功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-2-I-O%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%92%8C%E6%A8%A1%E5%9E%8B"><span class="nav-text">6.1.2 I&#x2F;O系统的层次结构和模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-3-I-O%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3"><span class="nav-text">6.1.3 I&#x2F;O系统接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-I-O%E8%AE%BE%E5%A4%87%E5%92%8C%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-text">6.2 I&#x2F;O设备和设备控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-I-O%E8%AE%BE%E5%A4%87"><span class="nav-text">6.2.1 I&#x2F;O设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-text">6.2.2 设备控制器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-3-%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8FI-O"><span class="nav-text">6.2.3 内存映像I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-4-I-O%E9%80%9A%E9%81%93"><span class="nav-text">6.2.4 I&#x2F;O通道</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E4%B8%AD%E6%96%AD%E6%9C%BA%E6%9E%84%E5%92%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-text">6.3 中断机构和中断处理程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-text">6.3.2 中断处理程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-text">6.4 设备驱动程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-1-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%A6%82%E8%BF%B0"><span class="nav-text">6.4.1 设备驱动程序概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-2-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="nav-text">6.4.2 设备驱动程序的处理过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-3-%E5%AF%B9I-O%E8%AE%BE%E5%A4%87%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-text">6.4.3 对I&#x2F;O设备的控制方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%97%A0%E5%85%B3%E7%9A%84I-O%E8%BD%AF%E4%BB%B6"><span class="nav-text">6.5 与设备无关的I&#x2F;O软件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-1-%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%97%A0%E5%85%B3%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">6.5.1 与设备无关软件的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-2-%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%97%A0%E5%85%B3%E7%9A%84%E8%BD%AF%E4%BB%B6"><span class="nav-text">6.5.2 与设备无关的软件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-3-%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D"><span class="nav-text">6.5.3 设备分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-4-%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%90%8D%E5%88%B0%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%90%8D%E6%98%A0%E5%B0%84%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">6.5.4 逻辑设备名到物理设备名映射的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-%E7%94%A8%E6%88%B7%E5%B1%82%E7%9A%84I-O%E8%BD%AF%E4%BB%B6"><span class="nav-text">6.6 用户层的I&#x2F;O软件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-1-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8E%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-text">6.6.1 系统调用与库函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-2-%E5%81%87%E8%84%B1%E6%9C%BA-Spooling-%E7%B3%BB%E7%BB%9F"><span class="nav-text">6.6.2 假脱机(Spooling)系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-7-%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="nav-text">6.7 缓冲区管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-1-%E7%BC%93%E5%86%B2%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-text">6.7.1 缓冲的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-2-%E5%8D%95%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E5%8F%8C%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">6.7.2 单缓冲区和双缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-3-%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">6.7.3 环形缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-4-%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="nav-text">6.7.4 缓冲池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-8-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E5%92%8C%E8%B0%83%E5%BA%A6"><span class="nav-text">6.8 磁盘存储器的性能和调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-1-%E7%A3%81%E7%9B%98%E6%80%A7%E8%83%BD%E7%AE%80%E8%BF%B0"><span class="nav-text">6.6.1 磁盘性能简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-2-%E6%97%A9%E6%9C%9F%E7%9A%84%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">6.6.2 早期的磁盘调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-8-3-%E5%9F%BA%E4%BA%8E%E6%89%AB%E6%8F%8F%E7%9A%84%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">6.8.3 基于扫描的磁盘调度算法</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Komeiji Satori"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Komeiji Satori</p>
  <div class="site-description" itemprop="description">记录些有的没的的学习心得</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kome1jisatori" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kome1jisatori" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=740775405&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;740775405&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      膜大佬的链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://sherlockcoder.xyz/" title="http:&#x2F;&#x2F;sherlockcoder.xyz" rel="noopener" target="_blank">不朽之存在的首页</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://datawhalechina.github.io/leeml-notes/#/" title="https:&#x2F;&#x2F;datawhalechina.github.io&#x2F;leeml-notes&#x2F;#&#x2F;" rel="noopener" target="_blank">机器学习笔记(LeeML-Notes)</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备 - 2021020302 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KomeijiSatori</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">244k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:42</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '8NhM2OcimmX1hgpelhxOhQK8-gzGzoHsz',
      appKey     : 'bQ1303bPFHzcUrkoBzb39dgO',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>



  <script type="text/javascript" color="0,0,0" opacity='0.5' zIndex="-1" count="150" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true},"log":false});</script></body>
</html>
