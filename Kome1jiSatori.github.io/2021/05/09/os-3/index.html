<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kome1jisatori.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="var NexT &#x3D; window.NexT || {};     var CONFIG &#x3D; {&quot;hostname&quot;:&quot;kome1jisatori.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;scheme&quot;:&quot;Mist&quot;,&quot;version&quot;:&quot;7.8.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;">
<meta property="og:type" content="website">
<meta property="og:title" content="KomeijiSatoriのblog">
<meta property="og:url" content="https://kome1jisatori.github.io/Kome1jiSatori.github.io/2021/05/09/os-3/index.html">
<meta property="og:site_name" content="KomeijiSatoriのblog">
<meta property="og:description" content="var NexT &#x3D; window.NexT || {};     var CONFIG &#x3D; {&quot;hostname&quot;:&quot;kome1jisatori.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;scheme&quot;:&quot;Mist&quot;,&quot;version&quot;:&quot;7.8.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%871.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%872.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%873.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%874.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%875.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%876.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%877.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%878.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%879.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%8710.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%8711.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%8712.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%8713.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%8714.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%8715.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%8716.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%8717.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%8718.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%8719.png">
<meta property="og:image" content="https://kome1jisatori.github.io/images/avatar.jpg">
<meta property="og:image" content="https://kome1jisatori.github.io/images/cc-by-nc-sa.svg">
<meta property="article:published_time" content="2021-07-18T01:45:49.453Z">
<meta property="article:modified_time" content="2021-07-18T01:45:49.453Z">
<meta property="article:author" content="Komeiji Satori">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%871.png">

<link rel="canonical" href="https://kome1jisatori.github.io/Kome1jiSatori.github.io/2021/05/09/os-3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title> | KomeijiSatoriのblog
</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KomeijiSatoriのblog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">地灵殿从零开始的学习生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">17</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="zh-CN">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">
</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
          
            <li><a href="/Kome1jiSatori.github.io/">KOME1JISATORI.GITHUB.IO</a></li>
            <li><a href="/Kome1jiSatori.github.io/2021/">2021</a></li>
            <li><a href="/Kome1jiSatori.github.io/2021/05/">05</a></li>
            <li><a href="/Kome1jiSatori.github.io/2021/05/09/">09</a></li>
          <li>OS-3</li>
        
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
          <!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kome1jisatori.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言个人操作系统笔记整理，欢迎参考，时不时更新。">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统笔记——第三章">
<meta property="og:url" content="https://kome1jisatori.github.io/2021/05/09/os-3/index.html">
<meta property="og:site_name" content="KomeijiSatoriのblog">
<meta property="og:description" content="前言个人操作系统笔记整理，欢迎参考，时不时更新。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%871.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%872.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%873.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%874.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%875.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%876.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%877.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%878.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%879.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%8710.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%8711.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%8712.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%8713.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%8714.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%8715.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%8716.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%8717.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%8718.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%8719.png">
<meta property="article:published_time" content="2021-05-09T22:02:49.000Z">
<meta property="article:modified_time" content="2021-06-20T13:51:04.620Z">
<meta property="article:author" content="Komeiji Satori">
<meta property="article:tag" content="课堂笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kome1jisatori.github.io/2021/05/09/os-3/%E5%9B%BE%E7%89%871.png">

<link rel="canonical" href="https://kome1jisatori.github.io/2021/05/09/os-3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统笔记——第三章 | KomeijiSatoriのblog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KomeijiSatoriのblog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">地灵殿从零开始的学习生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">17</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kome1jisatori.github.io/2021/05/09/os-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Komeiji Satori">
      <meta itemprop="description" content="记录些有的没的的学习心得">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KomeijiSatoriのblog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统笔记——第三章
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-10 06:02:49" itemprop="dateCreated datePublished" datetime="2021-05-10T06:02:49+08:00">2021-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-20 21:51:04" itemprop="dateModified" datetime="2021-06-20T21:51:04+08:00">2021-06-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          
            <span id="/2021/05/09/os-3/" class="post-meta-item leancloud_visitors" data-flag-title="操作系统笔记——第三章" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/05/09/os-3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/05/09/os-3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
     
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>个人操作系统笔记整理，欢迎参考，时不时更新。  </p>
<span id="more"></span>

<h1 id="第三章-处理机调度与死锁"><a href="#第三章-处理机调度与死锁" class="headerlink" title="第三章 处理机调度与死锁"></a>第三章 处理机调度与死锁</h1><h2 id="3-1-处理机调度的层次和调度算法的目标"><a href="#3-1-处理机调度的层次和调度算法的目标" class="headerlink" title="3.1 处理机调度的层次和调度算法的目标"></a>3.1 处理机调度的层次和调度算法的目标</h2><h3 id="3-1-1-处理机调度的层次"><a href="#3-1-1-处理机调度的层次" class="headerlink" title="3.1.1 处理机调度的层次"></a>3.1.1 处理机调度的层次</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.高级调度</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;又称长程调度或作业调度，它的调度对象是作业将外存作业调入内存，创建PCB等，插入就绪队列。一般用于批处理系统，分/实时系统一般直接入内存，无此环节。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.低级调度</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;又称进程调度或短程调度，调度对象是进程。进程调度是最基本的一种调度，在多道批处理、分时和实时三种类型的OS中，都必须配置这级调度。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.中级调度</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;中级调度又称为内存调度。引入中级调度的主要目的是，提高内存利用率和系统吞吐量。中级调度实际上就是存储器管理中的对换功能。<br>&ensp;&ensp;&ensp;&ensp;三种调度中，进程调度运行频率最高，在分时系统中通常是10~100ms便进行一次进程调度，因而进程调度算法不能太复杂。<br>&ensp;&ensp;&ensp;&ensp;作业调度往往是发生在一个（批）作业运行完毕，退出系统，而需要重新调入一个（批）作业进入时，帮作业调度的周期较长，大约几分钟一次。中级调度的运行频率，介于上述两种调度之间。  </p>
<p><img src="/2021/05/09/os-3/%E5%9B%BE%E7%89%871.png">  </p>
<h3 id="3-1-2-处理机调度算法的目标"><a href="#3-1-2-处理机调度算法的目标" class="headerlink" title="3.1.2 处理机调度算法的目标"></a>3.1.2 处理机调度算法的目标</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.处理机调度算法的共同目标</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）资源利用率。为提高系统的资源利用率，应使系统中的处理机和其它所有资源尽可能的保持忙碌状态。其中CPU的利用率可计算如下：<img src="/2021/05/09/os-3/%E5%9B%BE%E7%89%872.png"><br>&ensp;&ensp;&ensp;&ensp;（2）公平性。指应使诸进程都获得合理的CPU时间，不会发生进程饥饿现象。公平性是相对的。<br>&ensp;&ensp;&ensp;&ensp;（3）平衡性。由于系统中可能具有多种类型的进程，有的属于计算型作业，有的属于I/O型。为使CPU和各种外设经常处于忙碌状态，调度算法应尽可能保证系统资源使用的平衡性。<br>&ensp;&ensp;&ensp;&ensp;（4）策略强制执行。对于所制定的各种策略，如果需要，必须予以正确执行。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.批处理系统的目标</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）平均周转时间短。<br>&ensp;&ensp;&ensp;&ensp;周转时间：指作业被提交给系统开始，到作业完成为止的时间间隔。包括①作业在外存上的等待时间；②进程在就绪队列中等待时间；③进程在CPU上执行时间；④等待I/O时间。<br>&ensp;&ensp;&ensp;&ensp;对于每个用户，都希望自己的周转时间最短。作为计算机系统的管理者，则希望能使平均周转时间最短。  </p>
<p>平均周转时间可描述为：<img src="/2021/05/09/os-3/%E5%9B%BE%E7%89%873.png"><br>为了进一步反映调度的性能，描述各进程在其周转时间中，等待和执行时间的具体分配情况，往往使用带权周转时间。<br><img src="/2021/05/09/os-3/%E5%9B%BE%E7%89%874.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）系统吞吐量高。<br>&ensp;&ensp;&ensp;&ensp;吞吐量指在<strong>单位时间内系统完成的作业数</strong>。它与批处理作业的平均长度有关。如果单纯为了获得高的吞吐量，应尽量多的选择短作业运行。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（3）处理机利用率高<br>&ensp;&ensp;&ensp;&ensp;如果单纯为使处理机利用率高，应尽量选择计算量大的作业来运行。可以看出，上述要求之间存在着一定的矛盾。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.分时系统的目标</strong>（非重点，可略）  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）响应时间快。<br>&ensp;&ensp;&ensp;&ensp;响应时间：指从用户通过键盘提交一个请求开始，到系统首次产生响应为止的时间间隔。包括：键盘请求送入处理机时间；处理机处理请求时间；形成响应送回终端时间。<br>&ensp;&ensp;&ensp;&ensp;（2）均衡性。系统响应时间的快慢应与用户所请求服务的复杂性相适应。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.实时系统的目标</strong>（非重点，可略） </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）截止时间的保证。<br>&ensp;&ensp;&ensp;&ensp;截止时间：某任务必须开始执行的最迟时间，或必须完成的最迟时间。对于HRT任务，调度算法必须保证对截止时间的要求。对于SRT任务，调度算法应基本保证截止时间的要求。<br>&ensp;&ensp;&ensp;&ensp;（2）可预测性。  </p>
<h2 id="3-2-作业与作业调度"><a href="#3-2-作业与作业调度" class="headerlink" title="3.2 作业与作业调度"></a>3.2 作业与作业调度</h2><h3 id="3-2-1-批处理系统中的作业"><a href="#3-2-1-批处理系统中的作业" class="headerlink" title="3.2.1 批处理系统中的作业"></a>3.2.1 批处理系统中的作业</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.作业和作业步</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）作业：包含通常的程序和数据，配作业说明书，系统根据该说明书对程序的运行进行控制。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）作业步：作业运行经过的，相对独立又相互关联的加工步骤。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.作业控制块</strong> </p>
<p>&ensp;&ensp;&ensp;&ensp;作业控制块：它是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。<br>&ensp;&ensp;&ensp;&ensp;JCB中的内容：作业标识，用户名称，作业账号，作业类型，作业状态，调度信息，资源需求，资源使用情况。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.作业运行的三个阶段和三种状态</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;作业从进入系统到运行结束，通常需要经历收容、运行和完成三个阶段。相应作业也就有“后备状态”、“运行状态”和“完成状态”。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）收容阶段：操作员把用户提交的作业通过某种方式或SPOOLING系统输入到硬盘上，再为该作业建立JCB，并把它放入<strong>作业后备队列</strong>中。后备状态。<br>&ensp;&ensp;&ensp;&ensp;（2）运行阶段：当作业被作业调度选中后，便为它分配必要的资源和建立进程，并将它放入就绪队列。一个<strong>作业从第一次进入就绪状态开始，直到它运行结束前，在此期间都处于运行状态</strong>。<br>&ensp;&ensp;&ensp;&ensp;（3）完成阶段：当作业运行完成、或发生异常情况而提前结束时，作业便进入完成阶段，相应的作业状态为完成状态。  </p>
<h3 id="3-2-2-作业调度的主要任务"><a href="#3-2-2-作业调度的主要任务" class="headerlink" title="3.2.2 作业调度的主要任务"></a>3.2.2 作业调度的主要任务</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.接纳多少个作业（内存驻留数）</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;太多―――&gt;    周转时间T长<br>&ensp;&ensp;&ensp;&ensp;太少―――&gt;    系统效率低</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.接纳哪些作业</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;接纳哪些作业:接纳策略,取决于采用何种调度算法、FCFS、短作业优先等。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>作业调度仅存在于批处理系统中</strong>。  </p>
<h3 id="3-2-3-先来先服务和短作业优先调度算法"><a href="#3-2-3-先来先服务和短作业优先调度算法" class="headerlink" title="3.2.3 先来先服务和短作业优先调度算法"></a>3.2.3 先来先服务和短作业优先调度算法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.先来先服务调度算法（FCFS）</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;非剥夺式的调度算法；<br>&ensp;&ensp;&ensp;&ensp;以<strong>等待时间</strong>为主要的调度指标；<br>&ensp;&ensp;&ensp;&ensp;总是选择就绪队列的队首作业运行；<br>&ensp;&ensp;&ensp;&ensp;是一种最简单的调度算法，既可用于作业调度，也可用于进程调度。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.短作业优先算法（SJF）</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;以要求服务时间为主要的调度指标<br>&ensp;&ensp;&ensp;&ensp;优点：<br>&ensp;&ensp;&ensp;&ensp;（1）有效地降低作业的平均等待时间，缩短平均周转时间和平均带权周转时间（从而提高了系统吞吐量）<br>&ensp;&ensp;&ensp;&ensp;缺点：<br>&ensp;&ensp;&ensp;&ensp;（1）不利于长作业，会出现饿死现象；<br>&ensp;&ensp;&ensp;&ensp;（2）未考虑紧迫程度，不能保证紧迫性作业(进程)会被及时处理；<br>&ensp;&ensp;&ensp;&ensp;（3）该算法不一定能真正做到短作业优先调度。进程运行时间不易确定，通常采用近似估算方法值；<br>&ensp;&ensp;&ensp;&ensp;（4）必须预知作业的运行时间。  </p>
<h3 id="3-2-4-优先级调度算法和高响应比调度算法"><a href="#3-2-4-优先级调度算法和高响应比调度算法" class="headerlink" title="3.2.4 优先级调度算法和高响应比调度算法"></a>3.2.4 优先级调度算法和高响应比调度算法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.优先级调度算法（PSA）</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;从后备队列中选择若干个优先级最高的作业，调入内存运行。<br>&ensp;&ensp;&ensp;&ensp;从就绪队列中选择一个优先级最高的进程，让其获得处理器并执行。   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.响应比优先调度算法（HRRN）</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;非剥夺式的调度算法。<br>&ensp;&ensp;&ensp;&ensp;综合考虑等待时间和服务时间为调度指标<br>&ensp;&ensp;&ensp;&ensp;响应比Rp=（等待时间＋服务时间）/服务时间= 1+ tw/ts<br>&ensp;&ensp;&ensp;&ensp;（1）tw（等待时间）相同的进程，短作业RP大。<br>&ensp;&ensp;&ensp;&ensp;（2）ts（服务时间）相同的进程间相当于FCFS<br>&ensp;&ensp;&ensp;&ensp;（3）长作业等待一段时间仍能得到服务。<br>&ensp;&ensp;&ensp;&ensp;总是选择响应比较高的作业（进程）运行<br>&ensp;&ensp;&ensp;&ensp;可用于作业调度，也可用于进程调度<br>&ensp;&ensp;&ensp;&ensp;优点：介于FCFS和SJF算法之间的一种拆衷的算法。长短兼顾<br>&ensp;&ensp;&ensp;&ensp;缺点：需计算Rp，增加系统开销  </p>
<p>习题：ppt（第三章 27-32）  </p>
<h2 id="3-3-进程调度"><a href="#3-3-进程调度" class="headerlink" title="3.3 进程调度"></a>3.3 进程调度</h2><h3 id="3-3-1-进程调度的任务、机制和方式"><a href="#3-3-1-进程调度的任务、机制和方式" class="headerlink" title="3.3.1 进程调度的任务、机制和方式"></a>3.3.1 进程调度的任务、机制和方式</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.进程调度的任务</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;进程调度的任务主要有：<br>&ensp;&ensp;&ensp;&ensp;（1）保存处理机的现场信息。在进行调度时首先需要保存当前进程的处理机现场信息。<br>&ensp;&ensp;&ensp;&ensp;（2）按某种算法选取进程。调度程序按照某种算法从就绪队列中选取一个进程，并准备把处理机分配给它。<br>&ensp;&ensp;&ensp;&ensp;（3）把处理机分配给进程。由分派程序把处理机分配给该进程。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.进程调度机制</strong>     </p>
<p>&ensp;&ensp;&ensp;&ensp;为了实现进程调度，在进程调度机制中，应具有：<br>&ensp;&ensp;&ensp;&ensp;（1）排队器。每当一个进程变为就绪状态，排队器便将它插入到相应的就绪队列。<br>&ensp;&ensp;&ensp;&ensp;（2）分派器。分派器依据进程调度程序所选出的进程，将其从就绪队列取出，然后进行从分派器到新选出进程间的上下文切换，将处理机分配给新选出的进程。<br>&ensp;&ensp;&ensp;&ensp;（3）上下文切换器。在处理机进行切换时，会发生两对上下文的切换。<br>&ensp;&ensp;&ensp;&ensp;第一对上下文切换时，OS将保存当前进程的上下文，再装入分派程序的上下文。<br>&ensp;&ensp;&ensp;&ensp;第二对上下文切换是移除分派程序的上下文，而把新选进程的CPU现场信息装入到处理机各个相应寄存器中，以便新选进程的运行。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.进程调度方式</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）非抢占方式<br>&ensp;&ensp;&ensp;&ensp;系统一旦把处理器分配给某进程后，该进程就占有处理器一直运行下去，直到该进程完成或因发生事件而阻塞，才退出处理器。<br>&ensp;&ensp;&ensp;&ensp;在这种方式下，引起进程调度的原因可归结为：<br>&ensp;&ensp;&ensp;&ensp;① 正在执行的进程运行完毕或无法再继续；<br>&ensp;&ensp;&ensp;&ensp;② 正在执行的进程提出I/O请求而暂停；<br>&ensp;&ensp;&ensp;&ensp;③ 在通信或同步中，执行了某种原语操作，如Block。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）抢占方式<br>&ensp;&ensp;&ensp;&ensp;允许调度程序根据某种原则，去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程。<br>&ensp;&ensp;&ensp;&ensp;抢占原则：<br>&ensp;&ensp;&ensp;&ensp;① 优先权原则<br>&ensp;&ensp;&ensp;&ensp;② 短进程原则<br>&ensp;&ensp;&ensp;&ensp;③ 时间片原则  </p>
<h3 id="3-3-2-轮转调度算法"><a href="#3-3-2-轮转调度算法" class="headerlink" title="3.3.2 轮转调度算法"></a>3.3.2 轮转调度算法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.轮转法的基本原理</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;系统将所有的就绪进程按进入就绪队列的先后次序排列。每次调度时把CPU分配给队首进程，让其执行一个时间片，当时间片用完，由计时器发出时钟中断，调度程序则暂停该进程的执行，使其退出处理器，并将它送到就绪队列的末尾，等待下一轮调度执行。<br>&ensp;&ensp;&ensp;&ensp;原则：将CPU时间划分为若干时间片，进程被调度到后，占用一个时间片，多个进程循环轮转占用CPU。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.进程切换时机</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）若一个时间片尚未用完，正在运行的进程已完成，就立即激活调度程序，将它从就绪队列删除，在重新调度并启动一个新的时间片。<br>&ensp;&ensp;&ensp;&ensp;（2）在一个时间片用完时，计时器中断处理程序被激活。如果进程尚未运行完毕，调度程序将之送往就绪队列的末尾。剥夺式调度算法  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.时间片大小的确定</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;过长－&gt;退化为FCFS算法，进程在一个时间片内都执行完，响应时间长。<br>&ensp;&ensp;&ensp;&ensp;过短－&gt;用户的一次请求需要多个时间片才能处理完，切换次数增加，系统开销大。  </p>
<p>例题ppt（第三章 42-47）  </p>
<h3 id="3-3-3-优先级调度算法"><a href="#3-3-3-优先级调度算法" class="headerlink" title="3.3.3 优先级调度算法"></a>3.3.3 优先级调度算法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.优先级调度算法的类型</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）非抢占式优先权算法<br>&ensp;&ensp;&ensp;&ensp;（2）抢占式优先权算法，实时性更好。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.优先级的类型</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）静态优先权：优先数在进程创建时确定，整个运行期不变不再变化。确定进程优先级的依据：①进程类型②进程对资源的需求③用户要求。简单，开销小，但低优先权作业可能长期不被调度。<br>&ensp;&ensp;&ensp;&ensp;（2）动态优先权：系统在运行的过程中，不断地调整进程的优先数。防止长作业长期垄断处理机。  </p>
<p>例题ppt（第三章 50）   </p>
<h3 id="3-3-4-多队列调度算法"><a href="#3-3-4-多队列调度算法" class="headerlink" title="3.3.4 多队列调度算法"></a>3.3.4 多队列调度算法</h3><p>&ensp;&ensp;&ensp;&ensp;该算法将系统中的进程就绪队列从一个拆分为若干个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法，一个就绪队列中的进程可以设置不同的优先级，不同的就绪队列本身也可以设置不同的优先级。</p>
<h3 id="3-3-5-多级反馈队列调度算法"><a href="#3-3-5-多级反馈队列调度算法" class="headerlink" title="3.3.5 多级反馈队列调度算法"></a>3.3.5 多级反馈队列调度算法</h3><p>（非重点）<br>多级反馈队列算法是时间片轮转算法和优先级算法的综合和发展。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.调度机制</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）系统中设置多个就绪队列，分别赋予不同的优先级，并逐级降低。为不同队列所规定的时间片长度不同，优先权越高的队列分配的时间片越小。依次逐级加倍。<br>&ensp;&ensp;&ensp;&ensp;（2）新进程进入内存后，先投入队列1的末尾，按FCFS算法排队调度；若按队列1的一个时间片未能执行完，则降低投入到队列2的末尾。如果在队列2的时间片内未能完成，则降低投入到队列3……；如此下去，降低到最后的队列，则按“时间片轮转”算法调度直到完成。<br>&ensp;&ensp;&ensp;&ensp;（3）仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾。 </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.调度算法的性能</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）终端型作业用户<br>&ensp;&ensp;&ensp;&ensp;提供高的响应时间。<br>&ensp;&ensp;&ensp;&ensp;（2）短批处理作业用户<br>&ensp;&ensp;&ensp;&ensp;在第一个或前2个时间片中即可完成，平均周转时间短。<br>&ensp;&ensp;&ensp;&ensp;（3）长批处理作业用户<br>&ensp;&ensp;&ensp;&ensp;不会饥饿。  </p>
<h3 id="3-3-6-基于公平原则的调度算法"><a href="#3-3-6-基于公平原则的调度算法" class="headerlink" title="3.3.6 基于公平原则的调度算法"></a>3.3.6 基于公平原则的调度算法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.保证调度算法</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;保证调度算法是另一种类型的调度算法，它向用户所作出的保证并不是优先运行，而是明确的性能保证，该算法可以做到调度的公平性。  </p>
<p>&ensp;&ensp;&ensp;&ensp;在实施公平调度算法时系统必须具备这样一些功能：<br>&ensp;&ensp;&ensp;&ensp;（1）跟踪计算每个进程自创建以来已经执行的处理时间。<br>&ensp;&ensp;&ensp;&ensp;（2）计算每个进程应获得的处理机时间，即自创建以来的时间除以n<br>&ensp;&ensp;&ensp;&ensp;（3）计算进程获得处理机时间的比率，即进程实际执行的处理时间和应获得的处理机时间之比<br>&ensp;&ensp;&ensp;&ensp;（4）比较各进程获得处理机时间的比率。<br>&ensp;&ensp;&ensp;&ensp;（5）调度程序应选择比率最小的进程将处理机分配给它，并让该进程一直运行，直到超过最接近它的进程比率为止。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.公平分享调度算法</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;分配给每个进程相同的处理机时间，显然，对诸进程而言，是体现了一定程度的公平，但如果各个用户所拥有的进程数不同，就会发生对用户的不公平问题。<br>&ensp;&ensp;&ensp;&ensp;调度的公平性主要是针对用户而言，然而调度又是以进程为单位的，所以，必须考虑每个用户所拥有的进程数目。</p>
<h2 id="3-4-实时调度"><a href="#3-4-实时调度" class="headerlink" title="3.4 实时调度"></a>3.4 实时调度</h2><h3 id="3-4-1-实现实时调度的基本条件"><a href="#3-4-1-实现实时调度的基本条件" class="headerlink" title="3.4.1 实现实时调度的基本条件"></a>3.4.1 实现实时调度的基本条件</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.提供必要的信息</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;为实现实时调度，系统应向调度程序提供相关任务的信息：<br>&ensp;&ensp;&ensp;&ensp;（1）就绪时间，是指某任务成为就绪状态的起始时间，在周期任务的情况下，它是事先预知的一串时间序列。<br>&ensp;&ensp;&ensp;&ensp;（2）开始截止时间和完成截止时间。<br>&ensp;&ensp;&ensp;&ensp;（3）处理时间，一个任务从开始执行，直至完成时所需要的时间。<br>&ensp;&ensp;&ensp;&ensp;（4）资源要求，任务执行时所需的一组资源。<br>&ensp;&ensp;&ensp;&ensp;（5）优先级，如果某任务的开始截止时间错过，势必引起故障，则应为该任务赋予“绝对优先级”；如果其开始截止时间的错过，并对任务的继续运行无重大影响，则可为其赋予“相对优先级”，供调度程序参考。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 系统处理能力强</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在实时系统中，通常都有着多个实时任务。若处理机的处理能力不够强，则有可能因处理机忙不过来而使某些实时任务不能得到及时处理，从而导致发生难以预料的后果。假定系统中有m个周期性的硬实时任务，它们的处理时间可表示为Ci，周期时间表示为Pi，则在单处理机情况下，必须满足下面的限制条件：系统才是可调度的。<br><img src="/2021/05/09/os-3/%E5%9B%BE%E7%89%875.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 采用抢占式调度机制</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在含有硬实时任务的实时系统中，广泛采用抢占机制。当一个优先权更高的任务到达时，允许将当前任务暂时挂起，而令高优先权任务立即投入运行，这样便可满足该硬实时任务对截止时间的要求。但这种调度机制比较复杂。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4. 具有快速切换机制</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;(1) 对外部中断的快速响应能力。为使在紧迫的外部事件请求中断时系统能及时响应，要求系统具有快速硬件中断机构，还应使禁止中断的时间间隔尽量短， 以免耽误时机(其它紧迫任务)。<br>&ensp;&ensp;&ensp;&ensp;(2) 快速的任务分派能力。在完成任务调度后，便应进行任务切换。为了提高分派程序进行任务切换时的速度， 应使系统中的每个运行功能单位适当的小，以减少任务切换的时间开销。  </p>
<h3 id="3-4-2-实时调度算法的分类"><a href="#3-4-2-实时调度算法的分类" class="headerlink" title="3.4.2 实时调度算法的分类"></a>3.4.2 实时调度算法的分类</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 非抢占式调度算法</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;(1) 非抢占式轮转调度算法。    秒级<br> &ensp;&ensp;&ensp;&ensp;用于工业生产的群控系统中。<br>&ensp;&ensp;&ensp;&ensp;(2) 非抢占式优先调度算法。    秒-毫秒级<br>&ensp;&ensp;&ensp;&ensp;用于有一定时间要求的实时控制系统之中。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 抢占式调度算法</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;(1)基于时钟中断抢占的优先权调度算法   毫秒级<br>&ensp;&ensp;&ensp;&ensp;基于时钟中断抢占<br>&ensp;&ensp;&ensp;&ensp;(2)立即抢占的优先权调度算法     毫秒-微秒级<br>&ensp;&ensp;&ensp;&ensp;只要不在临界区即抢占（中断引发）<br><img src="/2021/05/09/os-3/%E5%9B%BE%E7%89%876.png">    </p>
<h3 id="3-4-3-最早截止时间优先算法（EDF）"><a href="#3-4-3-最早截止时间优先算法（EDF）" class="headerlink" title="3.4.3 最早截止时间优先算法（EDF）"></a>3.4.3 最早截止时间优先算法（EDF）</h3><p>&ensp;&ensp;&ensp;&ensp;根据任务的截止时间来确定任务的优先级，截止时间越早，优先级越高，就绪队列中任务按其截止时间排列，队首任务先分配处理机，可以是抢占式或非抢占式。 </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 非抢占式调度方式用于非周期实时任务</strong><br><img src="/2021/05/09/os-3/%E5%9B%BE%E7%89%877.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 抢占式调度方式用于周期实时任务</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;有两个周期性任务，任务A的周期时间为20ms，每个周期处理时间为10ms；任务B的周期时间为50ms，每个周期处理时间为25ms。两个任务的到达时间，最后期限和执行时间如下图：<br><img src="/2021/05/09/os-3/%E5%9B%BE%E7%89%878.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）固定优先级调度（A有较高优先级）<br><img src="/2021/05/09/os-3/%E5%9B%BE%E7%89%879.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）固定优先级调度（B有较高优先级）<br><img src="/2021/05/09/os-3/%E5%9B%BE%E7%89%8710.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;（3）使用最早截止时间优先抢占调度算法<br><img src="/2021/05/09/os-3/%E5%9B%BE%E7%89%8711.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;固定优先级调度（A有较高优先级）时，B任务易错过截止最后期限；<br>&ensp;&ensp;&ensp;&ensp;固定优先级调度（B有较高优先级）时，A任务易错过截止最后期限，同时可能出现CPU空闲，降低系统效率。<br>&ensp;&ensp;&ensp;&ensp;在该例中利用最早截止完成时间优先算法可以满足系统要求  </p>
<h3 id="3-4-4-最低松弛度优先算法（LLF）"><a href="#3-4-4-最低松弛度优先算法（LLF）" class="headerlink" title="3.4.4 最低松弛度优先算法（LLF）"></a>3.4.4 最低松弛度优先算法（LLF）</h3><p>&ensp;&ensp;&ensp;&ensp;松弛度：由任务的完成截止时间决定。<br>&ensp;&ensp;&ensp;&ensp;松弛度＝完成截止时间－运行还需要时间－当前时刻<br>&ensp;&ensp;&ensp;&ensp;例如：若A进程需在200ms时完成，其本身运行需要100ms，当前时刻是10ms，则A的松弛度为：200－100－10＝90<br>该算法根据松弛度（任务紧急程度）来确定任务的优先级。<br>&ensp;&ensp;&ensp;&ensp;松弛度愈高，优先级愈低。<br>&ensp;&ensp;&ensp;&ensp;主要用于可抢占的调度方式中  </p>
<p>例题ppt（第三章 78-81）  </p>
<h3 id="3-4-5-优先级倒置"><a href="#3-4-5-优先级倒置" class="headerlink" title="3.4.5 优先级倒置"></a>3.4.5 优先级倒置</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 优先级倒置的形成</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;优先级倒置：即高优先级进程（线程）被低优先级进程（线程）延迟或阻塞。</p>
<p>&ensp;&ensp;&ensp;&ensp;示例：三个完全独立的进程P1，P2和P3，P1的优先级最高，P2次之，P3最低。P1和P3通过共享的一个临界资源进行交互。程序代码如下：<br>&ensp;&ensp;&ensp;&ensp;P1：… P(mutex); CS-1; V(mutex); …<br>&ensp;&ensp;&ensp;&ensp;P2:  … Program…<br>&ensp;&ensp;&ensp;&ensp;P3:  … P(mutex); CS-3; V(mutex); …<br>&ensp;&ensp;&ensp;&ensp;优先级：P1&gt;P2&gt;P3<br><img src="/2021/05/09/os-3/%E5%9B%BE%E7%89%8712.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;假如P3最先执行，在执行了P(mutex)后，进入到临界区CS-3。<br>&ensp;&ensp;&ensp;&ensp;在时刻a, P2就绪，因为它比P3优先级高，所以P2抢占了P3的处理机而运行。<br>&ensp;&ensp;&ensp;&ensp;在时刻b，P1就绪，因为它的优先级比P2高，所以P1抢占P2的处理机而运行。<br>&ensp;&ensp;&ensp;&ensp;在时刻c, P1 执行P(mutex)操作，试图进入临界区CS-1，但因为临界资源被P3占用，故P1阻塞，由P2继续运行直至时刻d。接着P3运行直至时刻e退出临界区进而唤醒P1，P1抢占P3处理机而运行。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 优先级倒置的解决方法</strong>  </p>
<p>（1）P3在进入临界区后所占用的处理机就不允许被抢占，<br>（2）当高优先级进入P1要进入临界区时，如果已有一个低优先级进程P3正在使用该临界区资源，此时一方面P1被阻塞，另一方面由P3继承P1的优先级并一直保持到P3退出临界区，以此来保证中间优先级进程插入申请处理机，延缓P3退出临界区。<br><img src="/2021/05/09/os-3/%E5%9B%BE%E7%89%8713.png">     </p>
<h2 id="3-5-死锁概述"><a href="#3-5-死锁概述" class="headerlink" title="3.5 死锁概述"></a>3.5 死锁概述</h2><h3 id="3-5-1-资源问题"><a href="#3-5-1-资源问题" class="headerlink" title="3.5.1 资源问题"></a>3.5.1 资源问题</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 可重用性资源和消耗性资源</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）可重用性资源：是一种可供用户重复使用的资源，它具有如下性质：<br>&ensp;&ensp;&ensp;&ensp;① 每一个可重用性资源中的单元只能分配一个进程使用，不允许多个进程共享；<br>&ensp;&ensp;&ensp;&ensp;② 进程使用可重用性资源时，按申请资源-&gt;使用资源-&gt;释放资源的顺序；<br>&ensp;&ensp;&ensp;&ensp;③ 每一类可重用资源中的单元数目是固定的，进程在运行期间既不能创建也不能删除它。  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）消耗性资源：又称为临时性资源，它是在进程运行期间，由进程动态创建和消耗的，具有如下性质：<br>&ensp;&ensp;&ensp;&ensp;①每一类消耗性资源中的单元数目在进程运行期间是可以变化的；<br>&ensp;&ensp;&ensp;&ensp;② 进程在运行期间，可以创造可消耗性资源；<br>&ensp;&ensp;&ensp;&ensp;③进程在运行期间，可以消耗可消耗性资源而不用归还。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.可抢占性资源和不可抢占性资源</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）可抢占性资源：分配给某进程后又可以被其他进程或系统抢占的资源。如处理机、内存。这类资源不会引起死锁的。  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）不可抢占资源：一旦分配给某进程后不能强行收回，只能由进程自行释放的资源。如刻录机和打印机等。  </p>
<h3 id="3-5-2-计算机系统中的死锁"><a href="#3-5-2-计算机系统中的死锁" class="headerlink" title="3.5.2 计算机系统中的死锁"></a>3.5.2 计算机系统中的死锁</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.竞争不可抢占性资源引起死锁</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;系统中所拥有的不可抢占资源数量往往不足以满足多个进程运行的需要，使得进程在运行的过程中，会因争夺资源而陷入僵局。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.竞争可消耗资源引起死锁</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;如消息通信按下述顺序进行，则不会发生死锁：<br>&ensp;&ensp;&ensp;&ensp;P1：…send(S1)；receive(S2)；…<br>&ensp;&ensp;&ensp;&ensp;P2：…send(S2)；Request(S1)；… </p>
<p>&ensp;&ensp;&ensp;&ensp;若按下述顺序，则可能发生死锁：<br>&ensp;&ensp;&ensp;&ensp;P1：… receive(S2)；send(S1)；…<br>&ensp;&ensp;&ensp;&ensp;P2：… receive(S1)；send(S2)；…  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.进程推进顺序不当引起的死锁</strong><br>合法的推进路线：①②③     不合法的推进线路：④<br><img src="/2021/05/09/os-3/%E5%9B%BE%E7%89%8714.png">  </p>
<h3 id="3-5-3-死锁的必要条件和处理方法"><a href="#3-5-3-死锁的必要条件和处理方法" class="headerlink" title="3.5.3 死锁的必要条件和处理方法"></a>3.5.3 死锁的必要条件和处理方法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.死锁的定义</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵局状态，若无外力作用，它们将无法再向前推进。<br>&ensp;&ensp;&ensp;&ensp;<strong>如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的</strong>。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.死锁的必要条件</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;(1) 互斥条件：进程所竞争的资源必须被互斥的使用（资源性质决定<br>&ensp;&ensp;&ensp;&ensp;(2) 请求和保持条件：当前已拥有资源的进程，仍能申请新的资源；而且当该进程因新的资源被其他的进程占用而阻塞时，它对自己已获得的资源仍保持不放（阻塞仍然保留<br>&ensp;&ensp;&ensp;&ensp;(3) 不可抢占条件：进程已获得的资源，只能在使用完时自行释放资源（不可抢占别的进程已占有的资源<br>&ensp;&ensp;&ensp;&ensp;(4) 循环等待条件：存在一个至少包括两个进程的循环等待链，链中的每个进程都正在等待下一个进程所占有的资源<br>&ensp;&ensp;&ensp;&ensp;四个条件必须同时存在才有可能发生死锁，有一个不成立也不能发生死锁。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.处理死锁的方法</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）预防死锁：设置限制条件，破坏产生死锁的四个必要条件中的一个或几个条件。<br>&ensp;&ensp;&ensp;&ensp;2）避免死锁：在每次的资源动态分配过程中，对系统能够满足的资源申请进行安全性检查 ，根据结果决定是否进行此次分配。<br>&ensp;&ensp;&ensp;&ensp;3）检测死锁：允许系统发生死锁，但设置检测机构，及时检测出死锁的发生。<br>&ensp;&ensp;&ensp;&ensp;4）解除死锁：外力推动解除死锁。具体方法有：撤消或挂起死锁进程、剥夺资源等。<br>&ensp;&ensp;&ensp;&ensp;3和4一般搭配使用<br>&ensp;&ensp;&ensp;&ensp;上述的四种方法，从（1）到（4）对死锁的防范程度逐渐减弱，但对应的事资源利用率的提高，以及进程因资源因素而阻塞的频度下降（即并发程度提高）。</p>
<h2 id="3-6-预防死锁"><a href="#3-6-预防死锁" class="headerlink" title="3.6 预防死锁"></a>3.6 预防死锁</h2><h3 id="3-6-1-破坏“请求和保持”条件"><a href="#3-6-1-破坏“请求和保持”条件" class="headerlink" title="3.6.1 破坏“请求和保持”条件"></a>3.6.1 破坏“请求和保持”条件</h3><p>&ensp;&ensp;&ensp;&ensp;为了能破坏该条件，系统必须保证做到：当一个进程在请求资源时，它不能持有不可抢占资源。 </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.第一种协议</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;进程必须在运行前一次性地申请运行期间所需的全部资源，这样进程在整个运行期间不会再提出资源请求，从而摒弃了请求和保持条件。<br>&ensp;&ensp;&ensp;&ensp;优点：简单，易于实现，安全<br>&ensp;&ensp;&ensp;&ensp;缺点：<br>&ensp;&ensp;&ensp;&ensp;（1）资源浪费严重。降低进程并发度。<br>&ensp;&ensp;&ensp;&ensp;（2）使进程经常会发生饥饿现象   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.第二种协议</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的，且已用毕的全部资源，然后再请求新的所需资源。  </p>
<h3 id="3-6-2-破坏“不可抢占”条件"><a href="#3-6-2-破坏“不可抢占”条件" class="headerlink" title="3.6.2 破坏“不可抢占”条件"></a>3.6.2 破坏“不可抢占”条件</h3><p>&ensp;&ensp;&ensp;&ensp;允许进程逐个申请资源，当进程新的资源请求未满足时，必须释放已占有的资源，待以后需要时再重新申请。<br>&ensp;&ensp;&ensp;&ensp;此策略表明进程已占有的资源可被暂时释放，即被抢占了，从而摒弃“不抢占”条件。  </p>
<p>&ensp;&ensp;&ensp;&ensp;缺点：<br>&ensp;&ensp;&ensp;&ensp;（1）复杂，实现困难且代价大。<br>&ensp;&ensp;&ensp;&ensp;（2）延长了进程的周转时间，增加系统开销  </p>
<h3 id="3-6-3-破坏“循环等待”条件"><a href="#3-6-3-破坏“循环等待”条件" class="headerlink" title="3.6.3 破坏“循环等待”条件"></a>3.6.3 破坏“循环等待”条件</h3><p>&ensp;&ensp;&ensp;&ensp;系统给每类资源赋予一个序号，每一个进程严格按照序号递增的顺序请求资源，释放则相反。此方法不可能形成资源占有与请求的环路，从而破坏循环等待条件。总有一个进程占据了较高序号的资源，此后它继续申请的资源必然是空闲的，因此进程可以一直向前推进。</p>
<p>&ensp;&ensp;&ensp;&ensp;优点：相对而言，系统利用率高，系统吞吐量大。<br>&ensp;&ensp;&ensp;&ensp;缺点：<br>&ensp;&ensp;&ensp;&ensp;（1）限制设备扩充。系统事先确定资源序号，限制了新类型设备的增加。<br>&ensp;&ensp;&ensp;&ensp;（2）限制了进程对资源的请求，编程困难。<br>&ensp;&ensp;&ensp;&ensp;（3）资源浪费。当进程使用顺序与资源序号不相符时，也会造成资源浪费。   </p>
<h2 id="3-7-避免死锁"><a href="#3-7-避免死锁" class="headerlink" title="3.7 避免死锁"></a>3.7 避免死锁</h2><p>&ensp;&ensp;&ensp;&ensp;避免死锁同样是属于事先预防的策略，但并不是事先采取某种限制措施，破坏产生死锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。<br>&ensp;&ensp;&ensp;&ensp;这种方法所施加的限制条件较弱，可能获得较好的系统性能，目前常用此方法来避免发生死锁。<br>&ensp;&ensp;&ensp;&ensp;死锁避免方法中将系统状态分为安全状态和不安全状态，只要系统始终都处于安全状态便可避免死锁的发生。  </p>
<h3 id="3-7-1-系统安全状态"><a href="#3-7-1-系统安全状态" class="headerlink" title="3.7.1 系统安全状态"></a>3.7.1 系统安全状态</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.安全状态</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在该方法中，允许进程动态申请资源，系统在进行资源分配前，先计算资源分配的安全性。若安全便将资源分配给进程，否则进程等待。<br>&ensp;&ensp;&ensp;&ensp;安全状态是指系统能按某种顺序如 (P1、P2… 、Pn) 来为每个进程 Pi 分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺利完成，则称此时的系统状态为安全状态，称序列 ( P1、P2、…、Pn ) 为安全序列。<br>&ensp;&ensp;&ensp;&ensp;若某一时刻系统中无法找到这样一个安全序列，则称此时的系统状态为不安全状态。<br>&ensp;&ensp;&ensp;&ensp;虽然并非所有不安全状态都必然会转为死锁状态，但当系统进入不安全状态后，便可能进而进入死锁状态；反之，只要系统处于安全状态，便不会进入死锁状态，因此避免死锁的实质是使系统不进入不安全状态。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.安全状态实例</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;假定系统中有三个进程P1，P2和P3，共有12台磁带机。进程P1共需要10台，P2和P3各需要4台和9台。假设在T0时刻，进程的资源分配情况如下：<br><img src="/2021/05/09/os-3/%E5%9B%BE%E7%89%8715.png">   </p>
<p>这时系统是安全的，因为可以找到一个安全序列（P2，P1, P3），即按此顺序分配资源，就可以使每个进程顺利完成。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 由安全状态向不安全状态的转换</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;若在T0之后，又将1个资源分配给了P3，则系统进入了不安全状态。<br><img src="/2021/05/09/os-3/%E5%9B%BE%E7%89%8716.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;一个系统开始处于安全状态，当有进程请求一个可用资源时，系统需对该进程的请求进行检测，若将资源分配给进程后系统仍然处于安全状态，才将该资源分配给进程   </p>
<h3 id="3-7-2-利用银行家算法避免死锁"><a href="#3-7-2-利用银行家算法避免死锁" class="headerlink" title="3.7.2 利用银行家算法避免死锁"></a>3.7.2 利用银行家算法避免死锁</h3><p>&ensp;&ensp;&ensp;&ensp;最具代表性的死锁避免算法是Dijkstra的银行家算法。之所以这样命名是因为该算法原本是为银行系统设计的。<br>&ensp;&ensp;&ensp;&ensp;为实现银行家算法，每一个新进程在进入系统时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应该超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，在进一步计算在将这些资源分配后，是否会使系统处于不安全状态。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 银行家算法中的数据结构</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）可利用资源向量Available<br>&ensp;&ensp;&ensp;&ensp;可利用资源向量Available是一个含有m个元素的数组，其中每一个元素代表一类资源的空闲资源数目<br>&ensp;&ensp;&ensp;&ensp;如果Available[j]＝K，表示系统中现有空闲的Rj类资源K个。  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）最大需求矩阵Max<br>&ensp;&ensp;&ensp;&ensp;最大需求矩阵Max是一个n×m的矩阵，定义了系统中每个进程对m类资源的最大需求数目。<br>&ensp;&ensp;&ensp;&ensp;如果Max[i，j]＝K ，表示进程i需要Rj类资源的最大数目为K。  </p>
<p>&ensp;&ensp;&ensp;&ensp;3）分配矩阵Allocation<br>&ensp;&ensp;&ensp;&ensp;分配矩阵Allocation是一个n×m 的矩阵，定义了系统中每一类资源当前已分配给每一个进程的资源数目。<br>&ensp;&ensp;&ensp;&ensp;如果Allocation[i，j]＝K ，表示进程i当前已分到Rj类资源的数目为K。  </p>
<p>&ensp;&ensp;&ensp;&ensp;4）需求矩阵Need<br>&ensp;&ensp;&ensp;&ensp;需求矩阵Need是一个n×m 的矩阵，它定义了系统中每一个进程还需要的各类资源数目。<br>&ensp;&ensp;&ensp;&ensp;如果Need[i，j]＝K，表示进程i还需要Rj类资源K个。Need[i，j]＝Max[i，j]－Allocation[i，j]  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 银行家算法</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;设Requesti是进程Pi的请求向量，Requesti[j]＝K表示进程Pi请求分配Rj类资源K个。<br>&ensp;&ensp;&ensp;&ensp;当Pi发出资源请求后，系统按下述步骤进行检查：<br>&ensp;&ensp;&ensp;&ensp;（1）若Requesti [j]≤Need[i,j], 转（2），否则错误返回；<br>&ensp;&ensp;&ensp;&ensp;（2）若Requesti [j]≤Available[j], 转（3）否则进程等待；<br>&ensp;&ensp;&ensp;&ensp;（3）假设系统分配了资源，则有：<br> &ensp;&ensp;&ensp;&ensp;Available[j]=Available[j]-Requesti[j];<br> &ensp;&ensp;&ensp;&ensp;Allocation[i,j]=Allocation[i,j]+Requesti[j];<br> &ensp;&ensp;&ensp;&ensp;Need[i,j]=Need[i,j]-Requesti[j]<br>&ensp;&ensp;&ensp;&ensp;（4）执行安全性算法，若系统新状态是安全的，则分配完成，若系统新状态是不安全的，则恢复原状态，进程等待  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 安全性算法</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）设置两个向量<br>&ensp;&ensp;&ensp;&ensp;工作向量Work：表示系统可提供给进程继续运行的各类空闲资源数目，含有m个元素，执行安全性算法开始时，Work＝Available。<br>&ensp;&ensp;&ensp;&ensp;Finish：表示系统是否有足够的资源分配给进程，使之运行完成，开始时，Finish[i]＝false；当有足够资源分配给进程Pi时，令Finish[i]＝true。<br>&ensp;&ensp;&ensp;&ensp;2） 从进程集合中找到一个能满足下述条件的进程：<br>&ensp;&ensp;&ensp;&ensp;Finish[i]= false；<br>&ensp;&ensp;&ensp;&ensp;Need[i,j]≤Work[j]；<br>&ensp;&ensp;&ensp;&ensp;如找到则执行步骤3；否则执行步骤4。<br>&ensp;&ensp;&ensp;&ensp;3）当进程Pi获得资源后，可顺利执行直到完成，并释放出分配给它的资源，故应执行：<br>&ensp;&ensp;&ensp;&ensp;Work[j]＝Work[j] ＋ Allocation[i,j]；<br>&ensp;&ensp;&ensp;&ensp;Finish[i]＝true；<br>&ensp;&ensp;&ensp;&ensp;goto step 2；<br>&ensp;&ensp;&ensp;&ensp;4）若所有进程的Finish[i]都为true ，则表示系统处于安全状态；否则，系统处于不安全状态。   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4. 银行家算法示例</strong><br>ppt（第三章  123-132）/ 书p121</p>
<h2 id="3-8-死锁的检测与解除"><a href="#3-8-死锁的检测与解除" class="headerlink" title="3.8 死锁的检测与解除"></a>3.8 死锁的检测与解除</h2><p>&ensp;&ensp;&ensp;&ensp;如果在系统中，既不采取死锁预防措施，也未配有死锁避免算法，系统很可能发生死锁。在这种情况下，系统应当提供两个算法：<br>&ensp;&ensp;&ensp;&ensp;（1）死锁检测算法。该算法用于检测系统状态，以确定系统中是否发生了死锁。<br>&ensp;&ensp;&ensp;&ensp;（2）死锁解除算法。当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。  </p>
<h3 id="3-8-1-死锁的检测"><a href="#3-8-1-死锁的检测" class="headerlink" title="3.8.1 死锁的检测"></a>3.8.1 死锁的检测</h3><p>&ensp;&ensp;&ensp;&ensp;系统必须：①保存有关资源的请求和分配信息;②提供一种算法，以利用这些信息来检测系统是否已进入死锁状态。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 资源分配图</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;系统死锁，可利用资源分配图来描述。该图是由一组结点N和一组边E所组成的一个二元组G=（N, E），它具有下述的形式定义和限制：<br>&ensp;&ensp;&ensp;&ensp;N：结点集，分为P，R两部分，P={P1,P2,…,Pn}进程结点；R={R1,R2,…,Rm}资源结点  ；E：边的集合，其元素为有序二元组(Pi,Rj)是资源请求边，由进程Pi指向资源Rj，它表示进程Pi请求一个单位的Rj资源。 (Rj,Pi)是资源分配边，由资源Rj指向进程Pi，它表示把一个单位资源Rj分配给进程Pi。<br><img src="/2021/05/09/os-3/%E5%9B%BE%E7%89%8717.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 死锁定理</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）资源分配图的简化：<br>&ensp;&ensp;&ensp;&ensp;①找一个既不阻塞又非孤立点进程结点，使进程获得所需资源继续运行，直至运行完毕，再释放其所占有的全部资源，即消去此进程的所有请求边和分配边，将其变为孤立结点<br>&ensp;&ensp;&ensp;&ensp;②再把相应的资源分配给一个等待该资源的进程，即将某进程的申请边变为分配边<br>&ensp;&ensp;&ensp;&ensp;③重复以上步骤，若所有进程成为孤立结点，称该图是可完全简化的，否则称该图是不可完全简化的。  </p>
<p>&ensp;&ensp;&ensp;&ensp;所有的简化顺序，都将得到相同的不可简化图<br>&ensp;&ensp;&ensp;&ensp;死锁状态的充分条件是：当且仅当资源分配图是不可完全简化的。（死锁定理）<br><img src="/2021/05/09/os-3/%E5%9B%BE%E7%89%8718.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 死锁检测中的数据结构</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;①可利用资源向量Available：表示m类资源中每类资源的可用数目。<br>&ensp;&ensp;&ensp;&ensp;②请求矩阵Request：表示每个进程当前对各类资源的请求数目。<br>&ensp;&ensp;&ensp;&ensp;③分配矩阵Allocation：表示每个进程当前已分配的资源数目。<br>&ensp;&ensp;&ensp;&ensp;④工作向量Work：表示系统当前可提供资源数。<br>&ensp;&ensp;&ensp;&ensp;⑤剩下的进程集合L：记录当前已不占用资源的进程。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Work=Available; </span><br><span class="line">L=&#123;Li|Allocationi=<span class="number">0</span>∩Requesti=<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> all  LiL <span class="keyword">do</span><span class="comment">//若占用资源</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span>（Requesti≤Work）</span><br><span class="line">      &#123;</span><br><span class="line">           Work=Work+Allocationi;</span><br><span class="line">           L=L∪ Li;<span class="comment">//不占用的</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">deadlock=~(L==&#123;p1,p2,…pn&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="3-8-2-死锁的解除"><a href="#3-8-2-死锁的解除" class="headerlink" title="3.8.2 死锁的解除"></a>3.8.2 死锁的解除</h3><p>&ensp;&ensp;&ensp;&ensp;一旦检测出系统中出现了死锁，就应将陷入死锁的进程从死锁状态中解脱出来，常用的死锁解除方法有两种：  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）抢占资源：从其他进程那里抢占足够数量的资源给死锁进程，以解除死锁状态。  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）终止进程法：终止系统中的一个或多个死锁进程，直至打破循环环路，使系统从死锁状态解脱出来。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 终止进程的方法</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）终止所有死锁进程<br>&ensp;&ensp;&ensp;&ensp;最简单的方法是撤消全部死锁进程，使系统恢复到正常状态。但这种做法付出的代价太大。<br>&ensp;&ensp;&ensp;&ensp;2）逐个终止进程<br>&ensp;&ensp;&ensp;&ensp;按照某种顺序逐个撤消死锁进程，直到有足够的资源供其他未被撤消的进程使用，消除死锁状态为止。这种方法的代价也很大。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 付出代价最小的死锁解除算法（了解）</strong><br><img src="/2021/05/09/os-3/%E5%9B%BE%E7%89%8719.png">  </p>

    </div>

    
    
    
<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------以上<i class="fa fa-paw"></i>（或许会有不定时更新）-------------</div>
    
</div>

  
</div>
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Komeiji Satori
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://kome1jisatori.github.io/2021/05/09/os-3/" title="操作系统笔记——第三章">https://kome1jisatori.github.io/2021/05/09/os-3/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/" rel="tag"># 课堂笔记</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/08/os-2/" rel="prev" title="操作系统笔记——第二章">
      <i class="fa fa-chevron-left"></i> 操作系统笔记——第二章
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/10/os-4/" rel="next" title="操作系统笔记——第四章">
      操作系统笔记——第四章 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81"><span class="nav-text">第三章 处理机调度与死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%92%8C%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="nav-text">3.1 处理机调度的层次和调度算法的目标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="nav-text">3.1.1 处理机调度的层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="nav-text">3.1.2 处理机调度算法的目标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E4%BD%9C%E4%B8%9A%E4%B8%8E%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6"><span class="nav-text">3.2 作业与作业调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%BD%9C%E4%B8%9A"><span class="nav-text">3.2.1 批处理系统中的作业</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1"><span class="nav-text">3.2.2 作业调度的主要任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E5%92%8C%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">3.2.3 先来先服务和短作业优先调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4-%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E5%92%8C%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">3.2.4 优先级调度算法和高响应比调度算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-text">3.3 进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E4%BB%BB%E5%8A%A1%E3%80%81%E6%9C%BA%E5%88%B6%E5%92%8C%E6%96%B9%E5%BC%8F"><span class="nav-text">3.3.1 进程调度的任务、机制和方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">3.3.2 轮转调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">3.3.3 优先级调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-%E5%A4%9A%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">3.3.4 多队列调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-5-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">3.3.5 多级反馈队列调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-6-%E5%9F%BA%E4%BA%8E%E5%85%AC%E5%B9%B3%E5%8E%9F%E5%88%99%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">3.3.6 基于公平原则的调度算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="nav-text">3.4 实时调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9D%A1%E4%BB%B6"><span class="nav-text">3.4.1 实现实时调度的基本条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">3.4.2 实时调度算法的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-3-%E6%9C%80%E6%97%A9%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%88EDF%EF%BC%89"><span class="nav-text">3.4.3 最早截止时间优先算法（EDF）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-4-%E6%9C%80%E4%BD%8E%E6%9D%BE%E5%BC%9B%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%88LLF%EF%BC%89"><span class="nav-text">3.4.4 最低松弛度优先算法（LLF）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-5-%E4%BC%98%E5%85%88%E7%BA%A7%E5%80%92%E7%BD%AE"><span class="nav-text">3.4.5 优先级倒置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E6%AD%BB%E9%94%81%E6%A6%82%E8%BF%B0"><span class="nav-text">3.5 死锁概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98"><span class="nav-text">3.5.1 资源问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%AD%BB%E9%94%81"><span class="nav-text">3.5.2 计算机系统中的死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-3-%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="nav-text">3.5.3 死锁的必要条件和处理方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="nav-text">3.6 预防死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-1-%E7%A0%B4%E5%9D%8F%E2%80%9C%E8%AF%B7%E6%B1%82%E5%92%8C%E4%BF%9D%E6%8C%81%E2%80%9D%E6%9D%A1%E4%BB%B6"><span class="nav-text">3.6.1 破坏“请求和保持”条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-2-%E7%A0%B4%E5%9D%8F%E2%80%9C%E4%B8%8D%E5%8F%AF%E6%8A%A2%E5%8D%A0%E2%80%9D%E6%9D%A1%E4%BB%B6"><span class="nav-text">3.6.2 破坏“不可抢占”条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-3-%E7%A0%B4%E5%9D%8F%E2%80%9C%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E2%80%9D%E6%9D%A1%E4%BB%B6"><span class="nav-text">3.6.3 破坏“循环等待”条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-text">3.7 避免死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-1-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81"><span class="nav-text">3.7.1 系统安全状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-2-%E5%88%A9%E7%94%A8%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-text">3.7.2 利用银行家算法避免死锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A7%A3%E9%99%A4"><span class="nav-text">3.8 死锁的检测与解除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-1-%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="nav-text">3.8.1 死锁的检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-2-%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E9%99%A4"><span class="nav-text">3.8.2 死锁的解除</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Komeiji Satori" src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Komeiji Satori</p>
  <div class="site-description" itemprop="description">记录些有的没的的学习心得</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kome1jisatori" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kome1jisatori" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=740775405&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;740775405&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      膜大佬的链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://sherlockcoder.xyz/" title="http:&#x2F;&#x2F;sherlockcoder.xyz" rel="noopener" target="_blank">不朽之存在的首页</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://datawhalechina.github.io/leeml-notes/#/" title="https:&#x2F;&#x2F;datawhalechina.github.io&#x2F;leeml-notes&#x2F;#&#x2F;" rel="noopener" target="_blank">机器学习笔记(LeeML-Notes)</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备 - 2021020302 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KomeijiSatori</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">205k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:06</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '8NhM2OcimmX1hgpelhxOhQK8-gzGzoHsz',
      appKey     : 'bQ1303bPFHzcUrkoBzb39dgO',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>



  <script type="text/javascript" color="0,0,0" opacity="0.5" zindex="-1" count="150" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true},"log":false});</script></body>
</html>

      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/Kome1jiSatori.github.io/">KOME1JISATORI.GITHUB.IO</a></li>
            <li><a href="/Kome1jiSatori.github.io/2021/">2021</a></li>
            <li><a href="/Kome1jiSatori.github.io/2021/05/">05</a></li>
            <li><a href="/Kome1jiSatori.github.io/2021/05/09/">09</a></li>
          <li>OS-3</li>
        
  </ul>

    
    
    


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">KomeijiSatoriのblog</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">
          操作系统笔记——第三章
        </span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81"><span class="nav-text">第三章 处理机调度与死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1%E5%92%8C%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="nav-text">3.1 处理机调度的层次和调度算法的目标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="nav-text">3.1.1 处理机调度的层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="nav-text">3.1.2 处理机调度算法的目标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E4%BD%9C%E4%B8%9A%E4%B8%8E%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6"><span class="nav-text">3.2 作业与作业调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E4%BD%9C%E4%B8%9A"><span class="nav-text">3.2.1 批处理系统中的作业</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1"><span class="nav-text">3.2.2 作业调度的主要任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%E5%92%8C%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">3.2.3 先来先服务和短作业优先调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4-%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E5%92%8C%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">3.2.4 优先级调度算法和高响应比调度算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-text">3.3 进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E4%BB%BB%E5%8A%A1%E3%80%81%E6%9C%BA%E5%88%B6%E5%92%8C%E6%96%B9%E5%BC%8F"><span class="nav-text">3.3.1 进程调度的任务、机制和方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">3.3.2 轮转调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">3.3.3 优先级调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-%E5%A4%9A%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">3.3.4 多队列调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-5-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">3.3.5 多级反馈队列调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-6-%E5%9F%BA%E4%BA%8E%E5%85%AC%E5%B9%B3%E5%8E%9F%E5%88%99%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">3.3.6 基于公平原则的调度算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="nav-text">3.4 实时调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9D%A1%E4%BB%B6"><span class="nav-text">3.4.1 实现实时调度的基本条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">3.4.2 实时调度算法的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-3-%E6%9C%80%E6%97%A9%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%88EDF%EF%BC%89"><span class="nav-text">3.4.3 最早截止时间优先算法（EDF）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-4-%E6%9C%80%E4%BD%8E%E6%9D%BE%E5%BC%9B%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%88LLF%EF%BC%89"><span class="nav-text">3.4.4 最低松弛度优先算法（LLF）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-5-%E4%BC%98%E5%85%88%E7%BA%A7%E5%80%92%E7%BD%AE"><span class="nav-text">3.4.5 优先级倒置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E6%AD%BB%E9%94%81%E6%A6%82%E8%BF%B0"><span class="nav-text">3.5 死锁概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98"><span class="nav-text">3.5.1 资源问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%AD%BB%E9%94%81"><span class="nav-text">3.5.2 计算机系统中的死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-3-%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="nav-text">3.5.3 死锁的必要条件和处理方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="nav-text">3.6 预防死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-1-%E7%A0%B4%E5%9D%8F%E2%80%9C%E8%AF%B7%E6%B1%82%E5%92%8C%E4%BF%9D%E6%8C%81%E2%80%9D%E6%9D%A1%E4%BB%B6"><span class="nav-text">3.6.1 破坏“请求和保持”条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-2-%E7%A0%B4%E5%9D%8F%E2%80%9C%E4%B8%8D%E5%8F%AF%E6%8A%A2%E5%8D%A0%E2%80%9D%E6%9D%A1%E4%BB%B6"><span class="nav-text">3.6.2 破坏“不可抢占”条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-3-%E7%A0%B4%E5%9D%8F%E2%80%9C%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E2%80%9D%E6%9D%A1%E4%BB%B6"><span class="nav-text">3.6.3 破坏“循环等待”条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-text">3.7 避免死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-1-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81"><span class="nav-text">3.7.1 系统安全状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-2-%E5%88%A9%E7%94%A8%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-text">3.7.2 利用银行家算法避免死锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A7%A3%E9%99%A4"><span class="nav-text">3.8 死锁的检测与解除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-1-%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="nav-text">3.8.1 死锁的检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-2-%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E9%99%A4"><span class="nav-text">3.8.2 死锁的解除</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Komeiji Satori"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Komeiji Satori</p>
  <div class="site-description" itemprop="description">记录些有的没的的学习心得</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kome1jisatori" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kome1jisatori" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=740775405&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;740775405&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      膜大佬的链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://sherlockcoder.xyz/" title="http:&#x2F;&#x2F;sherlockcoder.xyz" rel="noopener" target="_blank">不朽之存在的首页</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://datawhalechina.github.io/leeml-notes/#/" title="https:&#x2F;&#x2F;datawhalechina.github.io&#x2F;leeml-notes&#x2F;#&#x2F;" rel="noopener" target="_blank">机器学习笔记(LeeML-Notes)</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备 - 2021020302 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KomeijiSatori</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">205k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:06</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '8NhM2OcimmX1hgpelhxOhQK8-gzGzoHsz',
      appKey     : 'bQ1303bPFHzcUrkoBzb39dgO',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>



  <script type="text/javascript" color="0,0,0" opacity='0.5' zIndex="-1" count="150" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true},"log":false});</script></body>
</html>
