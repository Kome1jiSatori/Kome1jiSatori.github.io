<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kome1jisatori.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="var NexT &#x3D; window.NexT || {};     var CONFIG &#x3D; {&quot;hostname&quot;:&quot;kome1jisatori.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;scheme&quot;:&quot;Mist&quot;,&quot;version&quot;:&quot;7.8.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;">
<meta property="og:type" content="website">
<meta property="og:title" content="KomeijiSatoriのblog">
<meta property="og:url" content="https://kome1jisatori.github.io/Kome1jiSatori.github.io/2021/05/08/os-2/index.html">
<meta property="og:site_name" content="KomeijiSatoriのblog">
<meta property="og:description" content="var NexT &#x3D; window.NexT || {};     var CONFIG &#x3D; {&quot;hostname&quot;:&quot;kome1jisatori.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;scheme&quot;:&quot;Mist&quot;,&quot;version&quot;:&quot;7.8.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%871.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%872.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%873.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%874.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%875.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%876.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%877.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%878.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%879.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8710.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8711.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8712.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8713.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8714.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8715.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8716.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8717.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8718.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8719.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8720.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8721.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8722.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8723.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8724.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8725.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8726.png">
<meta property="og:image" content="https://kome1jisatori.github.io/images/avatar.jpg">
<meta property="og:image" content="https://kome1jisatori.github.io/images/cc-by-nc-sa.svg">
<meta property="article:published_time" content="2021-07-18T01:45:49.431Z">
<meta property="article:modified_time" content="2021-07-18T01:45:49.431Z">
<meta property="article:author" content="Komeiji Satori">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%871.png">

<link rel="canonical" href="https://kome1jisatori.github.io/Kome1jiSatori.github.io/2021/05/08/os-2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title> | KomeijiSatoriのblog
</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KomeijiSatoriのblog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">地灵殿从零开始的学习生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">22</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="zh-CN">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">
</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
          
            <li><a href="/Kome1jiSatori.github.io/">KOME1JISATORI.GITHUB.IO</a></li>
            <li><a href="/Kome1jiSatori.github.io/2021/">2021</a></li>
            <li><a href="/Kome1jiSatori.github.io/2021/05/">05</a></li>
            <li><a href="/Kome1jiSatori.github.io/2021/05/08/">08</a></li>
          <li>OS-2</li>
        
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
          <!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kome1jisatori.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言个人操作系统笔记整理，欢迎参考，时不时更新。">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统笔记——第二章">
<meta property="og:url" content="https://kome1jisatori.github.io/2021/05/08/os-2/index.html">
<meta property="og:site_name" content="KomeijiSatoriのblog">
<meta property="og:description" content="前言个人操作系统笔记整理，欢迎参考，时不时更新。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%871.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%872.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%873.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%874.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%875.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%876.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%877.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%878.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%879.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8710.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8711.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8712.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8713.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8714.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8715.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8716.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8717.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8718.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8719.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8720.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8721.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8722.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8723.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8724.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8725.png">
<meta property="og:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%8726.png">
<meta property="article:published_time" content="2021-05-08T22:02:49.000Z">
<meta property="article:modified_time" content="2021-06-20T13:51:04.619Z">
<meta property="article:author" content="Komeiji Satori">
<meta property="article:tag" content="课堂笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kome1jisatori.github.io/2021/05/08/os-2/%E5%9B%BE%E7%89%871.png">

<link rel="canonical" href="https://kome1jisatori.github.io/2021/05/08/os-2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统笔记——第二章 | KomeijiSatoriのblog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KomeijiSatoriのblog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">地灵殿从零开始的学习生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">17</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kome1jisatori.github.io/2021/05/08/os-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Komeiji Satori">
      <meta itemprop="description" content="记录些有的没的的学习心得">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KomeijiSatoriのblog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统笔记——第二章
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-09 06:02:49" itemprop="dateCreated datePublished" datetime="2021-05-09T06:02:49+08:00">2021-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-20 21:51:04" itemprop="dateModified" datetime="2021-06-20T21:51:04+08:00">2021-06-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          
            <span id="/2021/05/08/os-2/" class="post-meta-item leancloud_visitors" data-flag-title="操作系统笔记——第二章" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/05/08/os-2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/05/08/os-2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>33k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>30 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
     
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>个人操作系统笔记整理，欢迎参考，时不时更新。  </p>
<span id="more"></span>

<h1 id="第二章-进程管理"><a href="#第二章-进程管理" class="headerlink" title="第二章 进程管理"></a>第二章 进程管理</h1><h2 id="2-1-前趋图和程序执行"><a href="#2-1-前趋图和程序执行" class="headerlink" title="2.1 前趋图和程序执行"></a>2.1 前趋图和程序执行</h2><h3 id="2-1-1-前趋图"><a href="#2-1-1-前趋图" class="headerlink" title="2.1.1 前趋图"></a>2.1.1 前趋图</h3><p>&ensp;&ensp;&ensp;&ensp;前趋图定义<br>&ensp;&ensp;&ensp;&ensp;定义：前趋图是一个有向无循环图,记为 DAG(Directed Acyclic Graph) ，用于描述进程之间执行的前后顺序。<br>&ensp;&ensp;&ensp;&ensp;表示方式：<br>&ensp;&ensp;&ensp;&ensp;（1）p1–&gt;p2<br>&ensp;&ensp;&ensp;&ensp;（2）–&gt;={(p1,p2)| p1 必须在p2开始前完成}<br>&ensp;&ensp;&ensp;&ensp;节点表示：一条语句，一个程序段，一个进程，节点上的权重表示该进程的程序量或执行时间。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%871.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;下图就不是前趋图，<strong>前趋图中不应出现循环</strong><br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%872.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;因为存在前趋关系: S2→S3 和 S3 →S2  </p>
<h3 id="2-1-2-程序的顺序执行及其特征"><a href="#2-1-2-程序的顺序执行及其特征" class="headerlink" title="2.1.2 程序的顺序执行及其特征"></a>2.1.2 程序的顺序执行及其特征</h3><p>&ensp;&ensp;&ensp;&ensp;单道程序环境下，程序段执行有固定的时序，仅当前一操作完成后，才能执行后继操作。<br>&ensp;&ensp;&ensp;&ensp;例如，进行计算时，总需要首先输入数据，然后进行计算，最后才能打印计算结果。假如用I表示输入，C表示计算，P表示打印，并且用箭头表示操作的先后次序。则输入数据，计算数据，打印计算结果这样一段程序。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%873.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;对于程序段中的多条语句来说，也有一个执行顺序问题，如对于包含下述三条语句的程序段：<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%874.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;一切顺序执行的程序都具有下列特性：<br>&ensp;&ensp;&ensp;&ensp;（1）顺序性。即每一操作都必须在上一个操作结束之后开始。<br>&ensp;&ensp;&ensp;&ensp;（2）封闭性。程序运行时独占全机资源；资源的状态（除初始状态外）只有本程序才能改变它。程序一旦开始运行，其执行结果不受外界因素影响。<br>&ensp;&ensp;&ensp;&ensp;（3）可再现性。只要执行时的环境和初始条件相同，程序不论是连续执行还是“走走停停”地执行，都将获得相同的结果。  </p>
<h3 id="2-1-3-程序的并发执行及其特征"><a href="#2-1-3-程序的并发执行及其特征" class="headerlink" title="2.1.3 程序的并发执行及其特征"></a>2.1.3 程序的并发执行及其特征</h3><p>&ensp;&ensp;&ensp;&ensp;程序的两种执行方式：顺序执行、并发执行。<br>&ensp;&ensp;&ensp;&ensp;现在的操作系统多为并发执行（多道处理系统），具有许多新的特征。<br>&ensp;&ensp;&ensp;&ensp;引入并发执行的目的是为了<strong>提高资源利用率</strong>。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>并发</strong>与<strong>并行</strong>概念的区别：<br>&ensp;&ensp;&ensp;&ensp;concurrency,parallel</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.程序的并发执行</strong><br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%875.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;该例中存在下述前趋关系：<br>&ensp;&ensp;&ensp;&ensp;Ii→Ci ，Ii→Ii+1 ， Ci→Pi， Ci→Ci+1， Pi→Pi+1<br>&ensp;&ensp;&ensp;&ensp;而Ii+1和Ci及Pi-1是重迭的，亦即Ii+1和Ci及Pi-1可以并发执行。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.并发程序的特征</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）间断性：进程“时走时停”<br>&ensp;&ensp;&ensp;&ensp;（2）非封闭性：多个程序共享资源<br>&ensp;&ensp;&ensp;&ensp;（3）不可再现性：由于失去了封闭性，也失去了可在现性  </p>
<p>&ensp;&ensp;&ensp;&ensp;例：有2个循环程序A和B，它们共享变量N；<br>&ensp;&ensp;&ensp;&ensp;程序A：N=N+1；程序B: Print(N)；N=0<br>&ensp;&ensp;&ensp;&ensp;若程序A,B以不同的速度运行有以下三种不同的结果（假定某时刻变量Ｎ的值为ｎ）  </p>
<p>&ensp;&ensp;&ensp;&ensp;N:=N+1在Print(N)和N=0之前，得到的N值分别为：n+1, n+1, 0<br>&ensp;&ensp;&ensp;&ensp;N:=N+1在Print(N)和N=0之后，得到的N值分别为：n, 0, 1<br>&ensp;&ensp;&ensp;&ensp;N:=N+1在Print(N)和N=0之间，得到的N值分别为：n, n+1, 0  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.顺序执行与并发执行特征对比</strong><br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%876.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;程序的并发执行引发的问题  </p>
<ul>
<li>如何协调各程序的执行顺序？</li>
<li>多个执行程序共享系统资源，程序之间可能会相互影响，甚至影响输出结果。</li>
<li>选择哪些、多少个程序进入内存执行？</li>
<li>内存中的执行程序谁先执行？</li>
<li>内存如何有效分配？           </li>
</ul>
<h2 id="2-2-进程的描述"><a href="#2-2-进程的描述" class="headerlink" title="2.2 进程的描述"></a>2.2 进程的描述</h2><h3 id="2-2-1-进程的定义和特征"><a href="#2-2-1-进程的定义和特征" class="headerlink" title="2.2.1 进程的定义和特征"></a>2.2.1 进程的定义和特征</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.进程的定义</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;通常的<strong>程序</strong>不能参与并发执行，为了让程序能并发执行，人们引入<strong>进程</strong>的概念对并发执行的程序加以描述和控制。<br>&ensp;&ensp;&ensp;&ensp;比较典型的进程定义有：<br>&ensp;&ensp;&ensp;&ensp;⑴进程是程序的一次执行。<br>&ensp;&ensp;&ensp;&ensp;⑵进程是一个程序及其数据在处理机上顺序执行时所发生的活动。<br>&ensp;&ensp;&ensp;&ensp;⑶进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。<br>&ensp;&ensp;&ensp;&ensp;本教材定义进程为：<strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</strong><br>&ensp;&ensp;&ensp;&ensp;资源分配：获得除了处理机以外的资源<br>&ensp;&ensp;&ensp;&ensp;资源调度：获得处理机资源  </p>
<p>&ensp;&ensp;&ensp;&ensp;进程与程序<br>&ensp;&ensp;&ensp;&ensp;程序：静态概念，是指令和数据的集合，可长期存储。<br>&ensp;&ensp;&ensp;&ensp;进程与程序对应关系：<br>&ensp;&ensp;&ensp;&ensp;一个程序可以对应一个进程或多个进程。<br>&ensp;&ensp;&ensp;&ensp;一个进程可以对应一个程序，或者一段程序。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%877.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;引入进程带来的问题<br>&ensp;&ensp;&ensp;&ensp;1）增加了空间开销：为进程建立数据结构<br>&ensp;&ensp;&ensp;&ensp;2）额外的时间开销：管理和协调、跟踪、填写和更新有关数据结构、切换进程、保护现场。<br>&ensp;&ensp;&ensp;&ensp;3）更难控制：<br>&ensp;&ensp;&ensp;&ensp;①协调多个进程竞争和共享资源。<br>&ensp;&ensp;&ensp;&ensp;②预防解决多个进程因为竞争资源而出现故障。<br>&ensp;&ensp;&ensp;&ensp;③处理机的竞争尤为突出。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.进程的特征</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）动态性：动态性是进程的最基本特征。表现在，进程由创建而产生，由调度而执行，由撤销而消亡。即进程具有一定的生命周期。（而程序是静态的）。<br>&ensp;&ensp;&ensp;&ensp;2）独立性：各进程的地址空间相互独立，互不干扰。<br>&ensp;&ensp;&ensp;&ensp;3）并发性：指多个进程实体同存于内存中，且能在一段时间内同时运行。并发性是进程的重要特征。<br>&ensp;&ensp;&ensp;&ensp;4）异步性：指进程按各自独立的、不可预知的速度向前推进  </p>
<p>&ensp;&ensp;&ensp;其它：<br>&ensp;&ensp;&ensp;&ensp;1）为使程序能独立运行，为之配置一进程控制块，即PCB（Process Control Block)。<br>&ensp;&ensp;&ensp;&ensp;2）进程是一个动态的实体，随着程序中指令的执行而不断地变化。在某个时刻进程的内容被称为进程映像。<br>&ensp;&ensp;&ensp;&ensp;3）进程由程序段、相关数据段和PCB三部分构成。  </p>
<h3 id="2-2-2-进程的基本状态及其转换"><a href="#2-2-2-进程的基本状态及其转换" class="headerlink" title="2.2.2 进程的基本状态及其转换"></a>2.2.2 进程的基本状态及其转换</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.进程的三种基本状态</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）就绪状态：进程已分配到除CPU以外的所有必要资源，只要获得CPU，便可立即执行，此时的状态称为就绪状态。一个系统中处于就绪状态的进程有多个，通常排成一个就绪队列。<br>&ensp;&ensp;&ensp;&ensp;2）执行状态：进程已获得CPU，其程序正在执行。单处理机系统中，只有一个进程在执行；多处理机系统中，可以是多个进程在同时执行。<br>&ensp;&ensp;&ensp;&ensp;3）阻塞状态：正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，这种状态称为阻塞状态（等待状态或封锁状态）。处于阻塞状态的进程也可排成队列。导致进程阻塞的事件有：请求I/O，申请缓冲空间等。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.三种基本状态的转换</strong> </p>
<p>&ensp;&ensp;&ensp;&ensp;进程在运行过程中灰经常发生状态的转换。例如，处于就绪状态的进程，在调度程序为之分配了处理及之后便可执行，相应地，其状态就由就绪态转变为执行态；正在执行的进程如果因分配给它的时间片已完而被剥夺处理机暂停执行时，其状态便由执行态转为就绪；如果因发生某事件，致使当前进程的执行受阻（如进程访问某临界资源，而该资源正在被其它进程访问时），则该进程状态将由执行变为阻塞。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%878.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.进程的创建状态和终止状态</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）创建状态  </p>
<p>&ensp;&ensp;&ensp;&ensp;创建过程一般包括多个步骤：①首先，为一个新进程创建PCB，并填写必要的管理信息；②然后为该进程分配运行时必须的资源；③最后把该进程转让就绪状态并插入就绪队列中。当新进程被创建时，如果该进程所必需的资源或其它信息，如主存资源尚未分配等。此时，<strong>进程已拥有了自己的PCB，但进程自身还未进入主存</strong>，即创建工作尚未完成，进程还不能被调度运行。<strong>该状态即为创建状态</strong>。  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）终止状态<br>&ensp;&ensp;&ensp;&ensp;进程的终止包含两个步骤：①首先，等待操作系统进行善后处理，②然后将其PCB清零，并将PCB空间返还系统。<br>&ensp;&ensp;&ensp;&ensp;如果进程到达了自然结束点，或出现了无法克服的错误，或被操作系统所终结，或是被其他有终止权的进程所终结，将进入终止状态。<br>&ensp;&ensp;&ensp;&ensp;虽然进入终止状态的进程不能再执行，但是在操作系统中依然保留一个记录，其中保持状态码和一些计时统计数据，供其他进程收集。一旦其他进程完成了对终止状态进程的信息提取之后，操作系统将删除该进程。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%879.png">   </p>
<h3 id="2-2-3-挂起操作和进程状态的转换"><a href="#2-2-3-挂起操作和进程状态的转换" class="headerlink" title="2.2.3 挂起操作和进程状态的转换"></a>2.2.3 挂起操作和进程状态的转换</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.挂起操作的引入</strong>  </p>
<p>挂起：当该操作作用于某个进程时，该进程将被挂起，意味着此时此刻该进程处于静止状态。如果进程正在执行。它将暂停执行。若原本处于就绪状态，则该进程此时暂不接受调度。与挂起操作相对应的操作是激活操作。<br>&ensp;&ensp;&ensp;&ensp;引入挂起操作的原因：  </p>
<ul>
<li>终端用户的请求：终端用户在自己的程序运行期间发现有可疑问题时，希望暂时使自己的程序静止下来。这种静止状态就是挂起状态。</li>
<li>父进程请求：父进程要求挂起自己的子进程，以便考查和修改；</li>
<li>负荷调节的需要：实时系统中负荷较重时，系统会把一些不重要的进程挂起；</li>
<li>操作系统的需要：操作系统希望挂起一些进程，以便检查运行中的资源使用情况。</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;挂起（Suspend）：把一个进程从内存转到外存；<br>&ensp;&ensp;&ensp;&ensp;激活（Activate）：把一个进程从外存转到内存；  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.引入挂起原语操作后三个进程状态的转换</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;活动就绪：进程在主存中并可以执行<br>&ensp;&ensp;&ensp;&ensp;活动阻塞：进程在主存中并等待一个事件<br>&ensp;&ensp;&ensp;&ensp;静止就绪：进程在辅存中，只要被载入主存就可以执行<br>&ensp;&ensp;&ensp;&ensp;静止阻塞：进程在辅存中并等待一个事件  </p>
<p>&ensp;&ensp;&ensp;&ensp;进程状态的转换<br>&ensp;&ensp;&ensp;&ensp;活动就绪 -&gt; 静止就绪<br>&ensp;&ensp;&ensp;&ensp;活动阻塞 -&gt; 静止阻塞<br>&ensp;&ensp;&ensp;&ensp;静止就绪 -&gt; 活动就绪<br>&ensp;&ensp;&ensp;&ensp;静止阻塞 -&gt; 活动阻塞<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8710.png">    </p>
<p><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8711.png">  </p>
<h3 id="2-2-4-进程管理中的数据结构"><a href="#2-2-4-进程管理中的数据结构" class="headerlink" title="2.2.4 进程管理中的数据结构"></a>2.2.4 进程管理中的数据结构</h3><p>&ensp;&ensp;&ensp;&ensp;一方面为了<strong>便于管理计算机资源，OS将它们抽象为各种数据结构</strong>，以及提供一组对资源进行<strong>操作</strong>的命令，用户可以通过这些数据结构和命令来执行相关操作。<br>&ensp;&ensp;&ensp;&ensp;另一方面，OS作为计算机资源的管理者，为了协调用户共享资源，它还<strong>需记录和查询各种资源的使用以及各类进程的运行情况信息。</strong>OS对于这些信息的组织和维护也是通过建立和维护各种数据结构的方式实现的。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.操作系统中用于管理控制的数据结构</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;计算机系统对每个资源和进程都设置了一个数据结构，称之为资源信息表或进程信息表，其中包含了资源或进程的标识，描述，状态等信息以及一批指针。<br>&ensp;&ensp;&ensp;&ensp;OS管理的这些数据结构一般可分为四类：内存表，设备表、文件表和进程表，其中进程表又称作进程控制块PCB。本章着重介绍PCB。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.进程控制块PCB的作用</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）<strong>作为独立运行的基本单位的标志。</strong>当一个程序配置了PCB后，就表示它是一个能在多道环境下独立运行的基本单位。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）<strong>能实现间断性运行方式。</strong>当程序阻塞时，保存现场，进程被再度调用时恢复现场。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（3）<strong>提供进程管理所需要的信息。</strong>在进程的整个生命周期，OS根据PCB实施对进程的控制和管理。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（4）<strong>提供进程调度所需要的信息。</strong>PCB提供了进程处于何种状态的信息，供进程调度使用。   </p>
<p>&ensp;&ensp;&ensp;&ensp;（5）<strong>实现与其它进程的同步与通信。</strong>PCB中具有用于实现进程同步的信号量和进程通信的区域或通信队列指针。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.进程管理块中的信息</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;（1）进程标识符。用于唯一的标识一个进程。<br>&ensp;&ensp;&ensp;&ensp;内部标识符：方便系统对进程的使用。在所有的操作系统中，都为每一个进程赋予一个唯一的数字标识符，它通常是一个进程的序号。<br>&ensp;&ensp;&ensp;&ensp;外部标识符：方便用户对进程的访问。由创建者提供，通常由字母数字组成。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）处理机状态信息。主要是由处理机的各种寄存器中的内容组成的。 处理机运行时，许多信息都存放在寄存器中。当处理机被中断时，所有这些信息都必须保存在PCB中，以便该进程重新执行时，能从断点继续执行。这些寄存器包括：①<strong>通用寄存器</strong>：用户可视寄存器，用于暂存信息，用户程序可以访问（8-32）②<strong>指令计数器</strong>：存放了要访问的下一条指令的地址；③<strong>程序状态字PSW</strong>:  其中包含了状态信息，如条件码、执行方式、终端屏蔽标志等；④<strong>用户栈指针</strong>：每个用户进程都有一个或若干个与之相关的系统栈，用于存放过程和系统调用参数及调用地址。栈指针指向栈顶。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（3）进程调度信息。在PCB中还存放一些与进程调度的信息，包括：①<strong>进程状态</strong>：指明进程的当前状态，作为进程调度和对换时的依据；②<strong>进程优先级</strong>：优先级高的进程应先获得处理机③<strong>进程调度所需的其它信息</strong>：与所采用的进程调度算法有关，比如，进程已等待CPU的时间总和、进程已执行的时间总和等；④<strong>事件</strong>：即阻塞原因，指进程由执行状态转变为阻塞状态所等待发生的事件。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（4）进程控制信息。①<strong>程序和数据的地址</strong>: 指进程的程序和数据所在的内存或外存地址，以便再调度到该程序执行时，能从PCB中找到其程序和数据；②<strong>进程同步和通信机制</strong>:指实现进程同步和通信必需的机制，如消息队列指针、信号量等；③<strong>资源清单</strong>：是一张列出了使用CPU以外的、进程所需的全部资源及已经分配到该进程的资源的清单；④<strong>链接指针</strong>：它给出了本进程（PCB）所在队列中的下一个进程的PCB的首地址。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.进程控制块的组织方式</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;为了能对系统中多个PCB有效的管理，应该用适当的方式将这些PCB组织起来。目前常用的方式有三种：  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）线性方式，即将所有的PCB组织在一张线性表中，将该表的首地址放在内存的一个专用区域中。<br>&ensp;&ensp;&ensp;&ensp;（2）链接方式，把具有相同状态进程的PCB链接成一个队列，诸如就绪队列，阻塞队列等。<br>&ensp;&ensp;&ensp;&ensp;（3）索引方式，根据所有进程状态的不同，建立几张索引表，例如就绪索引表，阻塞索引表等，并把各个索引表在内存的首地址记录在内存的一些专用单元中。在每个索引表的表项中，记录具有相应状态的某个PCB在PCB表中的地址。</p>
<h2 id="2-3-进程控制"><a href="#2-3-进程控制" class="headerlink" title="2.3 进程控制"></a>2.3 进程控制</h2><p>&ensp;&ensp;&ensp;&ensp;进程控制是进程管理中最基本的功能。它用于创建一个新进程，终止一个进程，还有负责进程运行中的状态转换。进程控制一般由OS的内核来完成。<br>&ensp;&ensp;&ensp;&ensp;进程控制一般由OS的内核中的原语来实现。<br>&ensp;&ensp;&ensp;&ensp;原语（Primitive）：是由若干条指令组成的，用于完成一定功能的一个过程。它是原子操作（Action Operation），指一个操作中的所有动作要么全做，要么全不做。是一个不可分割的基本单位，执行过程中不允许中断。原子操作需要常驻内存。  </p>
<h3 id="2-3-1-操作系统内核"><a href="#2-3-1-操作系统内核" class="headerlink" title="2.3.1 操作系统内核"></a>2.3.1 操作系统内核</h3><p>&ensp;&ensp;&ensp;&ensp;现代操作系统一般分为若干层次，通常将与硬件关系紧密的模块，各种常用设备的驱动以及运行频率较高的模块安排在紧靠硬件的软件层次中，将它们常驻内存，即所谓的OS内核。<br>&ensp;&ensp;&ensp;&ensp;安排原因：<br>&ensp;&ensp;&ensp;&ensp;对这些软件进行保护，防止遭受其它应用程序的破坏<br>&ensp;&ensp;&ensp;&ensp;可以提高OS的运行效率  </p>
<p>&ensp;&ensp;&ensp;&ensp;对应内核，处理机的执行状态分为系统态和用户态。<br>&ensp;&ensp;&ensp;&ensp;系统态：又称为管态，也称为内核态。它具有较高的特权，能执行一切指令，访问所有寄存器和存储区，传统的OS都在系统态运行。<br>&ensp;&ensp;&ensp;&ensp;用户态：又称为目态。它具有较低的特权，仅能执行规定的指令，访问指定的寄存器和存储区。<br>&ensp;&ensp;&ensp;&ensp;一般情况下，应用程序只能在<strong>用户态</strong>运行。  </p>
<p>&ensp;&ensp;&ensp;&ensp;OS内核功能：<br>&ensp;&ensp;&ensp;&ensp;1）支撑功能：提供给OS其它众多模块所需的一些基本功能，以便支撑这些模块工作。三种最基本的支撑功能是：①中断处理，②时钟管理和③原语操作。<br>&ensp;&ensp;&ensp;&ensp;2）资源管理功能：包含①进程管理，存储器管理和设备管理。  </p>
<h3 id="2-3-2-进程的创建"><a href="#2-3-2-进程的创建" class="headerlink" title="2.3.2 进程的创建"></a>2.3.2 进程的创建</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.进程的层次结构</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;在OS中，允许一个进程创建子进程，通常把创建进程的进程称为父进程，而被创建的进程称为子进程。子进程可以继续创建更多的孙进程，由此形成进程的层次结构。（Unix系统）<br>&ensp;&ensp;&ensp;&ensp;在windows中不存在进程的层次结构概念，所有的进程具有相同地位。一个进程创建另外进程时获得了一个句柄用来控制被创建的进程。但句柄是可以传递的。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.进程图</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;进程图：进程图是一个有向树，用来描述进程的家族关系<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8712.png"><br>&ensp;&ensp;&ensp;&ensp;子进程可继承父进程所分配到的资源；<br>&ensp;&ensp;&ensp;&ensp;子进程运行完毕后，将资源归还给父进程；<br>&ensp;&ensp;&ensp;&ensp;撤销父进程时，其所有的子进程也随之撤销。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.引起进程创建的事件</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）用户登录 在分时系统中，用户在终端键入登录命令后，如果是合法用户，系统将为该终端建立一个进程，并把它插入到就绪队列中。  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）作业调度 在批处理系统中，当作业调度程序按一定的算法调度到某作业时，便将该作业装入内存，为它分配必要的资源，并立即为它创建进程，再插入到就绪队列中。  </p>
<p>&ensp;&ensp;&ensp;&ensp;3）提供服务 当运行中的用户程序提出某种请求后，系统将专门创建一个进程来提供用户所需要的服务。例如，运行过程中要求打印，系统会创建一个打印进程与该用户进程并发执行。  </p>
<p>&ensp;&ensp;&ensp;&ensp;4）应用请求 指的是基于应用程序的需求，为它创建一个新进程，以便使新进程以并发运行方式完成特定任务。通过这种方式可以使得几个操作并发执行，以加速任务的完成。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.进程创建</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;一旦操作系统发现了要求创建进程的事件后，便调用进程创建原语Creat( )来创建进程。进程的创建需要经历以下步骤：<br>&ensp;&ensp;&ensp;&ensp;①申请空白PCB：为新进程分配一个唯一的进程ID,并申请一个空白的PCB。<br>&ensp;&ensp;&ensp;&ensp;②为新进程分配资源：为进程的程序代码、数据用户栈分配内存空间。<br>&ensp;&ensp;&ensp;&ensp;③初始化进程控制块：<br>&ensp;&ensp;&ensp;&ensp;（1）初始化标识信息，将系统分配的进程ID、父进程ID写入PCB。<br>&ensp;&ensp;&ensp;&ensp;（2）初始化处理机状态信息，将程序计数器指向程序的入口地址、栈指针指向栈顶。<br>&ensp;&ensp;&ensp;&ensp;（3）初始化处理机控制信息，设置进程状态、优先级等。  </p>
<p>&ensp;&ensp;&ensp;&ensp;④将新进程插入到就绪队列<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8713.png">   </p>
<h3 id="2-3-3-进程的终止"><a href="#2-3-3-进程的终止" class="headerlink" title="2.3.3 进程的终止"></a>2.3.3 进程的终止</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.引起进程终止的事件</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）正常结束<br>&ensp;&ensp;&ensp;&ensp;2）异常结束 指的是出现某些错误和故障而迫使进程终止。常见的异常有：越界错误；保护错；非法指令；特权指令错；运行超时；等待超时；算术运算错和I/O故障。<br>&ensp;&ensp;&ensp;&ensp;3）外界干预   指的是进程应外界的请求而终止执行。常见的干预包括：操作员或操作系统干预；父进程请求；父进程终止等。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.进程终止过程</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;1）根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态；  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度；  </p>
<p>&ensp;&ensp;&ensp;&ensp;3）若该进程还有子孙进程，还应将其所有子孙进程予以终止，以防他们成为不可控制的进程；  </p>
<p>&ensp;&ensp;&ensp;&ensp;4）将被终止进程所拥有的全部资源，或者归还给父进程，或者归还给系统；  </p>
<p>&ensp;&ensp;&ensp;&ensp;5）将被终止进程（它的PCB）从所在队列（或链表）中移出，等待其他程序来搜集信息。  </p>
<h3 id="2-3-4-进程的阻塞与唤醒"><a href="#2-3-4-进程的阻塞与唤醒" class="headerlink" title="2.3.4 进程的阻塞与唤醒"></a>2.3.4 进程的阻塞与唤醒</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.引起进程阻塞和唤醒的事件</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;1）请求共享资源失败 由于操作系统不能马上满足进程的请求，导致进程只能转变为阻塞状态等待；<br>&ensp;&ensp;&ensp;&ensp;2）等待某种操作的完成 如果某进程必须在一个已启动的操作完成后才能继续执行，则必须先将该进程阻塞，以等待该操作的完成；<br>&ensp;&ensp;&ensp;&ensp;3）新数据尚未到达；<br>&ensp;&ensp;&ensp;&ensp;4）等待新任务的到达 系统往往设置一些具有某种特定功能的系统进程，每当这种进程完成任务后，便把自己阻塞起来以等待新任务到来  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.进程阻塞过程</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;进程可通过调用阻塞原语block把自己阻塞。阻塞过程为：<br>&ensp;&ensp;&ensp;&ensp;1）调用block原语；<br>&ensp;&ensp;&ensp;&ensp;2）停止当前进程的执行；把PCB中的状态由“执行”改为“阻塞”；<br>&ensp;&ensp;&ensp;&ensp;3）将PCB插入到阻塞队列；<br>&ensp;&ensp;&ensp;&ensp;4）转调度程序进行重新调度，保留被阻塞进程的处理机状态<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8714.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.进程唤醒过程</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;当被阻塞进程所期待的事件出现时，如I/O完成或其所期待的数据已经到达，则由有关进程（比如，用完并释放了该I/O设备的进程）调用唤醒原语wakeup( )，将等待该事件的进程唤醒。其执行过程为：  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）把被阻塞进程从等待该事件的阻塞队列中移出，将其PCB中的现行状态由阻塞改为就绪；<br>&ensp;&ensp;&ensp;&ensp;2）将该PCB插入到就绪队列中。  </p>
<h3 id="2-3-5-进程的挂起与激活"><a href="#2-3-5-进程的挂起与激活" class="headerlink" title="2.3.5 进程的挂起与激活"></a>2.3.5 进程的挂起与激活</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.进程的挂起</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;当出现了引起进程挂起的事件时，系统将利用挂起原语suspend( )将指定进程或处于阻塞状态的进程挂起。其执行过程为：  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）检查被挂起进程的状态，若处于活动就绪状态，则将其改为静止就绪；对于活动阻塞状态的进程，则将其改为静止阻塞。<br>&ensp;&ensp;&ensp;&ensp;2)把该进程的PCB复制到某指定的内存区域；<br>&ensp;&ensp;&ensp;&ensp;3)若被挂起的进程正在执行，则转向调度程序重新调度。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8715.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.进程的激活</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;当发生激活进程的事件时，则可将在外存上处于静止就绪状态的进程换入内存。系统利用激活原语active( )将指定进程激活。其激活过程如下：  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）将进程从外存调入内存；<br>&ensp;&ensp;&ensp;&ensp;2）检查该进程的现行状态，若是静止就绪，便将之改为活动就绪；若为静止阻塞，则将其改为活动阻塞。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8716.png">     </p>
<h2 id="2-4-进程同步"><a href="#2-4-进程同步" class="headerlink" title="2.4 进程同步"></a>2.4 进程同步</h2><p>&ensp;&ensp;&ensp;&ensp;同步：并发进程在执行次序上的协调，以达到有效的资源共享和相互合作，使程序执行有可再现性。  </p>
<h3 id="2-4-1-进程同步的基本概念"><a href="#2-4-1-进程同步的基本概念" class="headerlink" title="2.4.1 进程同步的基本概念"></a>2.4.1 进程同步的基本概念</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.两种形式的制约关系</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在多道程序环境下，当程序并发执行时，可能存在以下两种形式的制约关系：</p>
<p>&ensp;&ensp;&ensp;&ensp;①间接制约关系：同处于一个系统的进程，必然共享着某种系统资源，如CPU, I/O等。间接制约关系源于这种资源共享。</p>
<p>&ensp;&ensp;&ensp;&ensp;②直接制约关系：这种制约关系主要源于进程间的合作。</p>
<p>&ensp;&ensp;&ensp;&ensp;间接制约：进行竞争－－独占分配到的部分或全部的共享资源，“互斥”<br>&ensp;&ensp;&ensp;&ensp;直接制约：进行协作－－等待来自其他进程的信息，“同步”  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.临界资源(Critical Resouce)</strong> </p>
<p>&ensp;&ensp;&ensp;&ensp;在一段时间内只允许一个进程访问的资源，即仅当一个进程访问完并释放该资源后，才允许另一个进程访问的资源，称为临界资源或独占资源。如：打印机、磁带机、共享变量、队列等。  </p>
<p>&ensp;&ensp;&ensp;&ensp;生产者－消费者问题：<br>&ensp;&ensp;&ensp;&ensp;生产者投放一个产品后，输入指针in加1：in = ( in + 1 ) % n （n是缓冲区个数，整型常量），in初值为0； 消费者每取出一个产品，输出指针out加1：out = ( out + 1 ) % n，out初值为0；<br>&ensp;&ensp;&ensp;&ensp;引入一个共享变量counter,初值为0。<br>&ensp;&ensp;&ensp;&ensp;▲生产者投放一个产品，counter加1，counter = n时不能再投放产品<br>&ensp;&ensp;&ensp;&ensp;▲消费者每取一个产品，counter减1，counter = 0时不能再取出产品   </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Var n： integer;   缓冲区的个数</span><br><span class="line">Type item=…;</span><br><span class="line">var buffer:<span class="built_in">array</span>[<span class="number">0</span>,<span class="number">1</span>,…,n<span class="number">-1</span>] of item;</span><br><span class="line">in, out: <span class="number">0</span>,<span class="number">1</span>, …, n<span class="number">-1</span>;</span><br><span class="line">counter: <span class="number">0</span>,<span class="number">1</span>,…,n; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">producer()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		produce an item in nextp;</span><br><span class="line">              …</span><br><span class="line">		<span class="keyword">while</span>(counter==n) no-op;</span><br><span class="line">		buffer[in]=nextp;</span><br><span class="line">		in:=(in+<span class="number">1</span>)% n;</span><br><span class="line">		counter++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(counter==<span class="number">0</span>) no-op;</span><br><span class="line">		nextc=buffer[out];</span><br><span class="line">		out=(out+<span class="number">1</span>) % n;</span><br><span class="line">		counter--;</span><br><span class="line">		consumer the item in nextc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&ensp;&ensp;&ensp;&ensp;<strong>3.临界区(Critical Section)</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;Critical section:把每个进程中访问临界资源的那段<strong>代码</strong>叫临界区(Critical Section)。只要每个进程互斥进入临界区、便可以实现对临界资源的互斥访问。<br>算法:  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	entry section; <span class="comment">//进入区：用于检查临界资源是否空闲，有无进程进入</span></span><br><span class="line">	critical section;</span><br><span class="line">	<span class="built_in">exit</span> section; <span class="comment">//退出区：用于释放临界资源，将访问标志复位</span></span><br><span class="line">	remainder section;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;<strong>4.同步机制遵循的规则（进入临界区的准则）</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）空闲让进：当临界资源空闲时，允许一个进程进入临界区。<br>&ensp;&ensp;&ensp;&ensp;2）忙则等待：临界资源正被访问时，其它进程必须等待，以保证对临界资源的互斥访问。<br>&ensp;&ensp;&ensp;&ensp;3）有限等待：应保证进程能在有限时间内能进入自己的临界区，以免陷入“死等”。<br>&ensp;&ensp;&ensp;&ensp;4）让权等待：如果进程不能进入自己的临界区、应立即释放处理机，以免陷入“忙等”。  </p>
<h3 id="2-4-2-硬件同步机制"><a href="#2-4-2-硬件同步机制" class="headerlink" title="2.4.2 硬件同步机制"></a>2.4.2 硬件同步机制</h3><p>&ensp;&ensp;&ensp;&ensp;虽然可以利用软件方法解决诸进程互斥进入临界区的问题，但有一定难度，并且存在很大的局限性，因而现在已很少采用。相应地，目前许多计算机已提供了一些特殊的硬件指令，允许对一个字中的内容进行检测和修正，或者是对两个字的内容进行交换等。可利用这些特殊的指令来解决临界区问题。实际上，在对临界区进行管理时，可以将标志看作一个锁，“锁开”进入，“锁关”等待，初始时锁是打开的。每个要进入临界区的进程必须先对锁进行测试，当锁未开时，则必须等待，直至锁被打开。反之，当锁是打开的时候，则应立即把其锁上，以阻止其它进程进入临界区。显然，为防止多个进程同时测试到锁为打开的情况，测试和关锁操作必须是连续的，不允许分开进行。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.关中断</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;实现方法：<br>&ensp;&ensp;&ensp;&ensp;在单处理机环境下，在进入临界区之后，关闭中断，直到离开临界区再打开中断。  </p>
<p>&ensp;&ensp;&ensp;&ensp;优点：<br>&ensp;&ensp;&ensp;&ensp;①进程在临界区执行期间，计算机不响应中断，不会引发调度，不会发生进程切换或线程切换。<br>&ensp;&ensp;&ensp;&ensp;②保证了对锁的测试和关锁操作的连续性和完整性，有效地保证了互斥。<br>&ensp;&ensp;&ensp;&ensp;缺点：<br>&ensp;&ensp;&ensp;&ensp;①滥用关中断权力可能导致严重后果；<br>&ensp;&ensp;&ensp;&ensp;②关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力；<br>&ensp;&ensp;&ensp;&ensp;③关中断方法也不适用于多CPU系统，因为，在一个处理器上关中断，并不能防止进程在其它处理器上执行相同临界段代码。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.利用Test-and-Set指令实现互斥</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;方法：<br>&ensp;&ensp;&ensp;&ensp;借助一条硬件指令“测试并建立”指令TS（Test-and-Set），该指令看作为一条原语。为每个临界资源设置一个布尔变量lock，lock初值为false，表示该临界资源空闲。TS指令的一般性描述：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">TS</span><span class="params">(boolean *lock)</span></span>&#123;</span><br><span class="line">    boolean old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock = TRUE;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;如果不能进入临界区，进行循环测试，TS指令实现互斥的循环结构描述：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="keyword">while</span> <span class="title">TS</span><span class="params">(&amp;lock)</span></span>;</span><br><span class="line">    cirtical section;</span><br><span class="line">    lock=FALSE;</span><br><span class="line">…</span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE)</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 利用Swap指令实现进程互斥</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;含义:对换指令，在Intel 80x86又称为XCHG指令，用于交换两个字的内容。其处理过程描述如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(boolean *a, boolean *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	boolean temp;</span><br><span class="line">	temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;互斥访问临界资源的方法:<br>&ensp;&ensp;&ensp;&ensp;为每个临界资源设置一个全局的布尔变量lock，其初值为false，在每个进程中再利用一个局部布尔变量key。利用Swap指令实现进程互斥的循环进程:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    key=TRUE;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        swap(&amp;lock, &amp;key);</span><br><span class="line">       &#125; <span class="keyword">while</span> (key!=FALSE)</span><br><span class="line">   critical section;</span><br><span class="line">   lock=FALSE;</span><br><span class="line">   …</span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;利用硬件指令的出现的问题:<br>&ensp;&ensp;&ensp;&ensp;“忙等”，即进程在进入不了临界区时，不放弃处理器，而不断地进行测试。<br>&ensp;&ensp;&ensp;&ensp;结果:<br>&ensp;&ensp;&ensp;&ensp;不符合“让权等待”，造成处理机浪费<br>&ensp;&ensp;&ensp;&ensp;解决方法:<br>&ensp;&ensp;&ensp;&ensp;信号量机制    </p>
<h3 id="2-4-3-信号量机制"><a href="#2-4-3-信号量机制" class="headerlink" title="2.4.3 信号量机制"></a>2.4.3 信号量机制</h3><p>&ensp;&ensp;&ensp;&ensp;原理：进程通过传递信号进行合作，可迫使某进程在某个位置暂时停止执行（阻塞等待），直到它收到一个可以“向前推进”的信号（被唤醒）。<br>&ensp;&ensp;&ensp;&ensp;信号量(Semaphores)是一种卓越的进程同步工具。目前有：整型信号量、记录型信号量和信号量集。<br>&ensp;&ensp;&ensp;&ensp;信号量可以用于单处理机、多处理机和网络中的互斥访问问题。<br>&ensp;&ensp;&ensp;&ensp;信号量机制是由Dijkstra提出的一种实现进程同步与互斥的通用方法，包括信号量s以及对信号量的两个原子操作wait和signal。早期这两个原语被称为P(s),V(s)操作。（P、V分别是荷兰语的pass(passeren)和increment(verhoog) 。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 整型信号量</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;最初由Dijkstra把整型信号量定义为一个用于表示资源数目的整型量S，它与一般整型量不同，除初始化外，仅能通过两个标准的原子操作wait和signal来访问（即P、V）。</p>
<p>&ensp;&ensp;&ensp;&ensp;(1)定义一个信号量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var s:semaphore=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;(2)等待信号量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Wait(s)&#123;</span><br><span class="line">	<span class="keyword">while</span>(s&lt;= <span class="number">0</span>) ;</span><br><span class="line">	s--;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;(3)通知信号量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signal(s)&#123;</span><br><span class="line">	s++;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 记录型信号量</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;因整型机制不断测试不满足“让权等待”而引入  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span> value;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">process_control_block</span>  *<span class="title">list</span>;</span></span><br><span class="line">&#125;semaphore;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;list:为进程链表，用于链接所有等待该类资源的进程。<br>&ensp;&ensp;&ensp;&ensp;用wait(s)和signal(s)实现同步与互斥。<br>&ensp;&ensp;&ensp;&ensp;在记录型信号量机制中：<br>&ensp;&ensp;&ensp;&ensp;s-&gt;value初值：表示系统中某类资源的数目。<br>&ensp;&ensp;&ensp;&ensp;s-&gt;value&lt;0:无可用资源，其绝对值表示系统中因请求该类资源而被阻塞的进程数目。  </p>
<p>等待：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wait(semaphore *S)&#123;</span><br><span class="line">	S-&gt;value --;</span><br><span class="line">	<span class="keyword">if</span>(S-&gt;value &lt; <span class="number">0</span>)</span><br><span class="line">		block(S-&gt;<span class="built_in">list</span>);<span class="comment">//让权等待</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通知：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">signal(semaphore *S)&#123;</span><br><span class="line">	S-&gt;value ++;</span><br><span class="line">	<span class="keyword">if</span>(S-&gt;value &lt;= <span class="number">0</span>)</span><br><span class="line">		wakeup(S-&gt;<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;关于记录型信号量的说明<br>&ensp;&ensp;&ensp;&ensp;每次执行完S-&gt;value–操作后，若S-&gt;value&lt;0时，说明该类资源已分配完毕，因此进程应调用block原语，进行自我阻塞，放弃处理机，并插入到信号量链表S.list中。<br>&ensp;&ensp;&ensp;&ensp;每次执行完S-&gt;value++操作后，若S-&gt;value≤0时，则表示在该信号量链表中，仍有等待该资源的进程被阻塞，故还应调用wakeup原语，将S.list链表中的第一个等待进程唤醒。<br>&ensp;&ensp;&ensp;&ensp;若S-&gt;value的初值为1，表示只允许一个进程访问临界资源，此时的信号量转化为互斥信号量。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. AND型信号量</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;AND型信号量集用于同时需要多种资源且每种资源占用一个信号量时的信号量操作；<br>&ensp;&ensp;&ensp;&ensp;基本思想：在一个原语中，将一段代码同时需要的多个临界资源，要么全部分配给它，要么一个都不分配。为Swait(Simultaneous Wait)。<br>&ensp;&ensp;&ensp;&ensp;在Swait时，各个信号量的次序并不重要，虽然会影响进程归入哪个阻塞队列，但是由于是对资源全部分配或不分配。<br>&ensp;&ensp;&ensp;&ensp;所以总有进程获得全部资源，并在执行完毕之后释放资源，因此不会死锁。   </p>
<p>等待操作Swait()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Swait(S1,S2,…Sn)&#123;</span><br><span class="line">   <span class="keyword">while</span>( TRUE)</span><br><span class="line">    &#123;      </span><br><span class="line">		 <span class="keyword">if</span>(S1&gt;=<span class="number">1</span> &amp;&amp; S2&gt;=<span class="number">1</span>…&amp;&amp; Sn&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)  Si--;   / /满足资源要求时的处理；</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">			&#125;<span class="comment">//if</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//某些资源不够时的处理；调用进程进入第一个小于1信号量的等待队列Sj;并把该进程的程序计数器指向swait操作的开始。 </span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通知操作Ssignal()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Ssignal(S1,S2,…Sn)&#123;</span><br><span class="line">   <span class="keyword">while</span>(TRUE)</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        Si++;<span class="comment">//释放资源</span></span><br><span class="line">  把 Si等待队列中的进程调入就绪队列。</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;<strong>4. 信号量集</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;思想：若进程一次需要申请多类临界资源，则在进行临界资源分配时，先测试各类临界资源是否大于其下限值。若低于下限值，则不予分配。<br>&ensp;&ensp;&ensp;&ensp;对应的Swait 和Ssignal格式为：<br>&ensp;&ensp;&ensp;&ensp;Swait(S1,t1,d1,…,Sn,tn,dn)    Ssignal(S1,d1,…,Sn,dn)<br>这里S为信号量，d为需求值，t为下限值  </p>
<p>&ensp;&ensp;&ensp;&ensp;用于同时需要多种资源、每种资源的占用数目不同、且可分配的资源还存在一个临界值时的处理；<br>&ensp;&ensp;&ensp;&ensp;临界值，就是指在某些情况下，当资源数量低于某一下限值时，便不予分配。这个下限值称作临界值。<br>&ensp;&ensp;&ensp;&ensp;一次需要N个某类临界资源，就要进行N次wait操作－－低效又可能死锁<br>&ensp;&ensp;&ensp;&ensp;基本思想：在AND型信号量集的基础上进行扩充：进程对信号量Si的下限值为ti（用于信号量的判断，即Si &lt;= ti，表示资源数量低于ti时，便不予分配），需求值为di（用于信号量的增减，即Si = Si - di和Si = Si + di）  </p>
<p>等待操作Swait()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Swait(S1，t1，d1，…，Sn，tn，dn)</span><br><span class="line">　　　　<span class="keyword">if</span> (Si&gt;=t1 &amp;&amp; … &amp;&amp; Sn&gt;=tn )&#123;</span><br><span class="line">　　　　　　<span class="keyword">for</span> (i=<span class="number">1</span> ;i&lt;= n;i++)</span><br><span class="line">　　　　　　　　Si:=Si-di；</span><br><span class="line">　　　　　　<span class="keyword">else</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;三种特例：<br>&ensp;&ensp;&ensp;&ensp;（1）Swait(S,d,d)：允许每次申请d个资源。当资源数少于d时，不予分配。<br>&ensp;&ensp;&ensp;&ensp;（2）Swait (s,1,1)：S&gt;1，资源信号量。S=1时，互斥信号量。<br>&ensp;&ensp;&ensp;&ensp;（3）Swait(s,1,0)，可控开关，当s&gt;=1时，允许进入，当s变为0后，阻止任何进程不能进入。  </p>
<h3 id="2-4-4-信号量的应用"><a href="#2-4-4-信号量的应用" class="headerlink" title="2.4.4 信号量的应用"></a>2.4.4 信号量的应用</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 利用信号量实现互斥</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）为临界资源设置一个互斥信号量mutex，其初值为1，取值为（-1，0，1）；在每个进程中将临界区代码置于wait(mutex)和signal(mutex)原语之间。</p>
<p>&ensp;&ensp;&ensp;&ensp;2）代码描述   </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>;</span><br><span class="line">Pa()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		wait(mutex);</span><br><span class="line">		临界区；</span><br><span class="line">		signal(mutex);</span><br><span class="line">		剩余区；</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Pb()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		wait(mutex);</span><br><span class="line">		临界区；</span><br><span class="line">		signal(mutex);</span><br><span class="line">		剩余区；</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;必须成对使用wait和signal原语,不能次序错误、重复或遗漏.遗漏wait原语则不能保证互斥访问，遗漏signal原语则不能在使用临界资源之后将其释放（给其他等待的进程）。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 利用信号量来描述前趋关系</strong>   </p>
<p><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8717.png">   </p>
<p>代码描述框架如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">p1()&#123; S1; signal(a); signal(b); &#125;</span><br><span class="line">p2()&#123; wait(a); S2; signal(c); signal(d); &#125;</span><br><span class="line">p3()&#123; wait(b);S3; signal(e); &#125;</span><br><span class="line">p4()&#123; wait(c);S4; signal(f); &#125;</span><br><span class="line">p5()&#123; wait(d);S1; signal(g); &#125;</span><br><span class="line">p6()&#123; wait(e); wait(f);wait(g);S6; &#125;</span><br><span class="line">main()&#123;</span><br><span class="line">semaphore a,b,c,d,e,f,g;</span><br><span class="line">a.value=b.value=c.value=d.value=e.value=f.value=g.value=<span class="number">0</span>;</span><br><span class="line">cobegin</span><br><span class="line">    p1();p2();p3();p4();p5();p6();</span><br><span class="line">coend  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-5-管程机制"><a href="#2-4-5-管程机制" class="headerlink" title="2.4.5 管程机制"></a>2.4.5 管程机制</h3><p>&ensp;&ensp;&ensp;&ensp;信号量同步的缺点<br>&ensp;&ensp;&ensp;&ensp;1）同步操作分散：信号量机制中，同步操作分散在各个进程中，使用不当就可能导致各进程死锁（如P、V操作的次序错误、重复或遗漏）；<br>&ensp;&ensp;&ensp;&ensp;2）易读性差：要了解对于一组共享变量及信号量的操作是否正确，必须通读整个系统或者并发程序；<br>&ensp;&ensp;&ensp;&ensp;3）不利于修改和维护：各模块的独立性差，任一组变量或一段代码的修改都可能影响全局；<br>&ensp;&ensp;&ensp;&ensp;4）正确性难以保证：操作系统或并发程序通常很大，很难保证这样一个复杂的系统没有逻辑错误。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.管程的定义</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;管程（Mointors）：一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。<br>&ensp;&ensp;&ensp;&ensp;管程组成：① 局部于管程的共享变量说明；② 对该数据结构进行操作的一组过程；③ 对局部于管程的数据设置初始值的语句。④还须为管程赋予一个名字。<br>&ensp;&ensp;&ensp;&ensp;代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，共同构成了一个操作系统的资源管理模块，我们称之为管程。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8718.png">   </p>
<p>管程语法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  Monitor monitor-name&#123;</span><br><span class="line">  share variable declarations;</span><br><span class="line">  cond declarations;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">(…)</span>  </span>&#123;….&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">(…)</span>  </span>&#123;….&#125;;</span><br><span class="line">  ….</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Pn</span><span class="params">(…)</span>  </span>&#123;….&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">        initialization code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;管程的主要特性<br>&ensp;&ensp;&ensp;&ensp;1）模块化：一个管程是一个基本程序单位，可以单独编译；<br>&ensp;&ensp;&ensp;&ensp;2）抽象数据类型：管程是一种特殊的数据类型，其中不仅有数据，而且有对数据进行操作的代码；<br>&ensp;&ensp;&ensp;&ensp;3）信息封装：管程是半透明的，管程中的过程（函数）实现了某些功能，至于这些功能是怎样实现的，在其外部则是不可见的。  </p>
<p>&ensp;&ensp;&ensp;&ensp;管程与进程的区别<br>&ensp;&ensp;&ensp;&ensp;1）进程定义的是私有数据结构PCB，管程定义的是公共数据结构；<br>&ensp;&ensp;&ensp;&ensp;2）都有对各自数据结构的操作。进程的操作由对应的代码段决定，管程的操作主要是同步操作和初始化操作；<br>&ensp;&ensp;&ensp;&ensp;3）设置进程的目的是为了实现并发，管程的目的是解决临界资源的互斥使用；  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.条件变量</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;管程的设计：<br>&ensp;&ensp;&ensp;&ensp;必须设置同步工具，如操作原语wait和signal，来保证对临界资源的正确访问；<br>&ensp;&ensp;&ensp;&ensp;引入条件变量condition，解决进程调用管程过程中被阻塞或挂起时，释放管程的相关控制；<br>&ensp;&ensp;&ensp;&ensp;通常，进程被挂起或阻塞的原因可能有多个，为了区别它们，需设置多个条件变量condition。<br>&ensp;&ensp;&ensp;&ensp;对条件变量的操作仅仅是wait和signal，因此条件变量也是一种抽象数据类型，每个条件变量保存了一个链表，用于记录因该条件变量而阻塞的所有进程。同时提供的两个操作即可表示为x.wait和x.signal。<br>&ensp;&ensp;&ensp;&ensp;x.wait的作用是：正在调用管程的进程因x条件需要被阻塞或挂起，则调用x.wait将自己插入到x条件的等待对列上，并释放管程，直到x条件变化。此时其它进程可以使用该管程。<br>&ensp;&ensp;&ensp;&ensp;x.signal的作用是：正在调用管程的进程发现x条件发生了变化，则调用x.signal重新启动一个因x条件而被阻塞或挂起的进程。如果存在多个这样的进程，则选择其中的一个，但如果没有被阻塞的进程，则x.signal操作不产生任何后果。如果有进程Q因x条件处于阻塞状态，当进程P执行了x.signal操作后，进程Q被重新启动，此时两个进程P和Q，怎样决定哪个进程执行，哪个等待，可采用下述两种方式之一：<br>&ensp;&ensp;&ensp;&ensp;（1） P等待，直至Q离开管程或等待另一条件；<br>&ensp;&ensp;&ensp;&ensp;（2） Q等待，直至P离开管程或等待另一条件。  </p>
<h2 id="2-5-经典进程的同步问题"><a href="#2-5-经典进程的同步问题" class="headerlink" title="2.5 经典进程的同步问题"></a>2.5 经典进程的同步问题</h2><h3 id="2-5-1-生产者——消费者问题"><a href="#2-5-1-生产者——消费者问题" class="headerlink" title="2.5.1 生产者——消费者问题"></a>2.5.1 生产者——消费者问题</h3><p>书p65<br>记录型信号量、AND型信号量、管程  </p>
<h3 id="2-5-2-哲学家进餐问题"><a href="#2-5-2-哲学家进餐问题" class="headerlink" title="2.5.2 哲学家进餐问题"></a>2.5.2 哲学家进餐问题</h3><p>书p69<br>记录型信号量、AND型信号量</p>
<h3 id="2-5-3-读者——写者问题"><a href="#2-5-3-读者——写者问题" class="headerlink" title="2.5.3 读者——写者问题"></a>2.5.3 读者——写者问题</h3><p>书p71<br>记录型信号量、信号量集</p>
<h2 id="2-6-进程通信"><a href="#2-6-进程通信" class="headerlink" title="2.6 进程通信"></a>2.6 进程通信</h2><p>&ensp;&ensp;&ensp;&ensp;进程通信的方式<br>&ensp;&ensp;&ensp;&ensp;进程之间的通信内容包含两种类型：控制信息和大批量数据。<br>&ensp;&ensp;&ensp;&ensp;低级通信：进程之间交换控制信息的过程<br>&ensp;&ensp;&ensp;&ensp;高级通信：进程之间交换批量数据的过程<br>&ensp;&ensp;&ensp;&ensp;进程之间同步与互斥是一种低级通信来控制进程的执行速度。</p>
<p>&ensp;&ensp;&ensp;&ensp;高级通信：利用操作系统提供的通信命令，高效传送大量数据的一种通信方式。<br>&ensp;&ensp;&ensp;&ensp;高级通讯方式有：<br>&ensp;&ensp;&ensp;&ensp;1、共享存储器系统，<br>&ensp;&ensp;&ensp;&ensp;2、管道通信系统<br>&ensp;&ensp;&ensp;&ensp;3、消息传递系统<br>&ensp;&ensp;&ensp;&ensp;4、C/S系统  </p>
<h3 id="2-6-1-进程通信的类型"><a href="#2-6-1-进程通信的类型" class="headerlink" title="2.6.1 进程通信的类型"></a>2.6.1 进程通信的类型</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.共享存储器系统（Shared-Memory System）</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在共享存储器系统中，相互通信的进程共享某些数据结构或共享存储区，进程之间能够通过这些空间进行通信。又可以分为以下两种类型：  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）基于共享数据结构的通信方式（低级通信）<br>&ensp;&ensp;&ensp;&ensp;该种通信方式中，要求诸进程公用某些数据结构，借以实现诸进程间的信息交换。如生产者-消费者问题中的共享缓冲池。这种通信方式仅适于传递相对少量的数据，通信效率低下，属于低级通信。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8719.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）基于共享存储区的通信方式（高级通信）<br>&ensp;&ensp;&ensp;&ensp;为了传输大量数据，在存储器中划出了一块共享存储区，诸进程可通过对共享存储区中数据的读和写来实现通信。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8720.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;步骤：<br>&ensp;&ensp;&ensp;&ensp;（1）申请共享存储区。<br>&ensp;&ensp;&ensp;&ensp;（2）连接共享存储区到进程的存储空间。<br>&ensp;&ensp;&ensp;&ensp;（3）互斥访问共享存储区。<br>&ensp;&ensp;&ensp;&ensp;（4）归还共享存储区。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.管道（pipe）通信系统</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。<br>&ensp;&ensp;&ensp;&ensp;向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入管道；<br>&ensp;&ensp;&ensp;&ensp;而接受管道输出的接收进程（即读进程），则从管道中接收（读）数据。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8721.png">     </p>
<p>&ensp;&ensp;&ensp;&ensp;管道机制须提供的协调能力<br>&ensp;&ensp;&ensp;&ensp;①互斥 即当一个进程正在对pipe执行读/写操作时，其他进程必须等待；<br>&ensp;&ensp;&ensp;&ensp;②同步  指当写（输入）进程把一定数量的数据写入pipe，便去睡眠等待，直到读（输出）进程取走数据后，再把它唤醒。当读进程读一空pipe时，也应睡眠等待，直至写进程将数据写入管道后，才将之唤醒；<br>&ensp;&ensp;&ensp;&ensp;③确定对方是否存在，只有确定了对方已存在时，才能进行通信。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.消息传递系统（Message passing system）</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在消息传递系统中，进程间的数据交换，是以格式化的消息（Message）为单位的。程序员直接利用系统提供的一组通信命令进行通信。<br>&ensp;&ensp;&ensp;&ensp;当今最为流行的微内核操作系统中，微内核与服务器之间的通信，无一例外地都采用了消息传递机制。<br>&ensp;&ensp;&ensp;&ensp;当基于消息传递系统的通信方式属于高级通信方式，因其实现方式的不同，可进一步分成两类：<br>&ensp;&ensp;&ensp;&ensp;1）直接通信方式：发送进程利用OS所提供的发送命令，直接把消息发送给目标进程；<br>&ensp;&ensp;&ensp;&ensp;2）间接通信方式：进程之间的通信，通过中间实体（也称为信箱）来暂存发送进程发送给目标进程的消息，接收进程则从该实体中接收发送给自己的消息。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.客户机-服务器系统（Client-server system）</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;客户机-服务器系统的通信机制，在网络环境下的各种应用领域以成为当前主流的通信实现机制。<br>&ensp;&ensp;&ensp;&ensp;其主要的实现方法有三类：①套接字，②远程方法调用和③远程过程调用。  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）套接字：起源于BSD Unix,最初用于同一台主机上多个应用程序之间的通信，随着网络技术和Unix操作系统的广泛使用，套接字已经逐渐成为最流行的网络程序接口之一。通常包括两类：<br>&ensp;&ensp;&ensp;&ensp;（1）基于文件型：通信进程运行在同一台机器的环境中，套接字是基于本地文件系统支持的，一个套接字关联到一个特殊的文件，通信双方通过对这个特殊文件的读写实现通信，原理类似于管道。<br>&ensp;&ensp;&ensp;&ensp;（2）基于网络型：采用非对称方式通信，即发送者需要提供接收者命名。通信双方的进程运行在不同主机的网络环境下，被分配了一对套接字，分别属于发送者和接收者。  </p>
<p>&ensp;&ensp;&ensp;&ensp;套接字的优势在于，它不仅适用于同一台计算机内部的通信，也适用于网络环境中不同计算机间的进程通信。由于每个套接字拥有唯一标识符，因而可以方便加以区分。  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）远程过程调用和远程方法调用：远程过程调用RPC是一个通信协议，允许一台主机（本地）系统上的进程调用另一台主机（远程）系统上的进程。如果涉及的软件采用面向对象编程，那么RPC亦可称为远程方法调用。<br>&ensp;&ensp;&ensp;&ensp;负责RPC的进程有两个，一个是本地客户进程，另一个是远程服务进程。它们通常也被称为网络守护进程，主要负责网络间的消息传递，一般都处于阻塞状态，等待消息。  </p>
<h3 id="2-6-2-消息传递通信的实现方式"><a href="#2-6-2-消息传递通信的实现方式" class="headerlink" title="2.6.2 消息传递通信的实现方式"></a>2.6.2 消息传递通信的实现方式</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.直接消息传递系统</strong>：发送进程利用OS提供的发送命令（原语），直接把消息发送给目标进程。  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）直接通信原语<br>&ensp;&ensp;&ensp;&ensp;a.对称寻址方式<br>&ensp;&ensp;&ensp;&ensp;send(Receiver, message)   send(P2,m1)<br>&ensp;&ensp;&ensp;&ensp;receive(Sender, message)  receive(P1,m1)<br>&ensp;&ensp;&ensp;&ensp;b.非对称寻址方式<br>&ensp;&ensp;&ensp;&ensp;send(P,message)  receive     </p>
<p>&ensp;&ensp;&ensp;&ensp;2）消息格式:传递的消息要有统一的格式<br>&ensp;&ensp;&ensp;&ensp;①单机系统环境下，由于发送者和接收者处于同一台机器中，所以消息的格式采用比较短的定长消息格式。<br>&ensp;&ensp;&ensp;&ensp;（系统开销小，用户不便）<br>&ensp;&ensp;&ensp;&ensp;②对于发送较长消息的用户，可采用变长消息格式，即进程所发送的消息长度是可变的。<br>&ensp;&ensp;&ensp;&ensp;（开销大，用户方便）  </p>
<p>&ensp;&ensp;&ensp;&ensp;3）进程间的同步方式：通信进程之间需要协调通信。<br>&ensp;&ensp;&ensp;&ensp;①发送和接收进程阻塞（汇合）：用于紧密同步，无缓冲区时。<br>&ensp;&ensp;&ensp;&ensp;②发送进程不阻塞，接收进程阻塞：相当于接收进程（可能是多个）一直等待发送进程，如：打印进程等待打印任务。<br>&ensp;&ensp;&ensp;&ensp;③发送/接收进程均不阻塞：一般在发、收进程间有多个缓冲区时。  </p>
<p>&ensp;&ensp;&ensp;&ensp;4）通信链路<br>&ensp;&ensp;&ensp;&ensp;两种方式建立通信链路<br>&ensp;&ensp;&ensp;&ensp;显式建立：（使用“建立连接”原语）由发送进程在通信之前，用显式的“建立连接”命令（原语），请求系统为之建立一条通信链路，在链路使用完后拆除链路。<br>&ensp;&ensp;&ensp;&ensp;隐式建立：（使用发送原语）发送进程无须明确提出建立链路的请求，只须利用系统提供的发送命令（原语），系统会自动地为之建立一条链路。（多用于单机系统）   </p>
<p>&ensp;&ensp;&ensp;&ensp;根据通信方式的不同，则又可把链路分成两种<br>&ensp;&ensp;&ensp;&ensp;①单向通信链路，只允许发送进程向接收进程发送消息，或者相反；<br>&ensp;&ensp;&ensp;&ensp;②双向通信链路，既允许由进程A向进程B发送消息，也允许进程B同时向进程A发送消息。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.信箱通信（间接通信）</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;基本方式：通过邮箱发送、接收、回答信件通信发送进程申请建立一个与接收进程链接的邮箱。发送进程的消息送往邮箱，接收进程可在任何时候从邮箱中取出消息，从而完成进程间信息交换。</p>
<p>&ensp;&ensp;&ensp;&ensp;1）信箱的结构<br>&ensp;&ensp;&ensp;&ensp;信箱是一种数据结构，由信箱头和信箱体组成。<br>&ensp;&ensp;&ensp;&ensp;①信箱头：描述信箱名、大小及拥有该信箱的进程名称等<br>&ensp;&ensp;&ensp;&ensp;②信箱体：包含多个格子，用于存放消息正文<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8722.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）信箱的类型  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）私用信箱：<br>&ensp;&ensp;&ensp;&ensp;用户进程可为自己建立一个新信箱，并作为该进程的一部分，当拥有该信箱的进程结束时，信箱也随之消失；<br>&ensp;&ensp;&ensp;&ensp;（2）公用信箱：<br>&ensp;&ensp;&ensp;&ensp;由操作系统创建，并提供给系统中的所有核准进程使用，核准进程既可把消息发送到该信箱中，也可从信箱中读取发送给自己的消息；<br>&ensp;&ensp;&ensp;&ensp;（3）共享信箱：<br>&ensp;&ensp;&ensp;&ensp;由某进程创建，在创建时或创建后，指明它是可共享的，同时须指出共享进程（用户）的名字。  </p>
<h3 id="2-6-3-直接消息传递系统实例"><a href="#2-6-3-直接消息传递系统实例" class="headerlink" title="2.6.3 直接消息传递系统实例"></a>2.6.3 直接消息传递系统实例</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.消息缓冲队列通信系统中的数据结构</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）消息缓冲区  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type <span class="class"><span class="keyword">struct</span> <span class="title">message_buffer</span>&#123;</span></span><br><span class="line">　　<span class="keyword">int</span> sender； 发送者进程标识符</span><br><span class="line">　　<span class="keyword">int</span> size；   消息长度</span><br><span class="line">　　<span class="keyword">char</span> *text；   消息正文</span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">message_buffer</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;2）PCB中有关通信的数据项   </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type <span class="class"><span class="keyword">struct</span> <span class="title">processcontrol_block</span>&#123;</span></span><br><span class="line">	…</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">message_buffer</span> *<span class="title">mq</span>； 消息队列队首指针</span></span><br><span class="line"><span class="class">	<span class="title">semaphore</span> <span class="title">mutex</span>；  消息队列互斥信号量</span></span><br><span class="line"><span class="class">	<span class="title">semaphore</span> <span class="title">sm</span>；     消息队列资源信号量</span></span><br><span class="line"><span class="class">	…</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;<strong>2.发送原语</strong>   </p>
<p><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8723.png">  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(receiver, a)</span></span>&#123;</span><br><span class="line">	 getbuf(a.size, i);向系统申请一个消息缓冲区</span><br><span class="line">	 i.sender=a.sender;</span><br><span class="line">	 i.size=a.size;</span><br><span class="line">	 i.text=a.text;</span><br><span class="line">	 i.next=<span class="number">0</span>;将发送的消息送消息缓冲区</span><br><span class="line">	 getid(PCBset, receiver.j);</span><br><span class="line">	 wait(j.mutex);</span><br><span class="line">	 insert(j.mq, i);将消息缓冲区插入消息队列     </span><br><span class="line">     signal(j.mutex);</span><br><span class="line">	 signal(j.sm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.接收原语</strong>  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">(b)</span></span>&#123;</span><br><span class="line">	 j=internal name;</span><br><span class="line">	 wait(j.sm);</span><br><span class="line">	 wait(j.mutex);</span><br><span class="line">	 remove(j.mq, i);取消息队列中的消息</span><br><span class="line">	 signal(j.mutex);</span><br><span class="line">	 b.sender=i.sender;</span><br><span class="line">	 b.size=i.size;</span><br><span class="line">	 b.text=i.text;将消息从缓冲区复制到接收区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-7-线程（THREAD）的基本概念"><a href="#2-7-线程（THREAD）的基本概念" class="headerlink" title="2.7 线程（THREAD）的基本概念"></a>2.7 线程（THREAD）的基本概念</h2><p>&ensp;&ensp;&ensp;&ensp;在20世纪60年代中期，人们设计多道OS时引入了进程的概念，从而解决了程序并发性的问题。此后的20多年时间里，进程一直作为资源分配和调度的基本单位。<br>&ensp;&ensp;&ensp;&ensp;80年代中期，为了进一步提高程序的并发度，引入了线程这一更小的基本单位。它特别适用于多处理机OS。  </p>
<h3 id="2-7-1-线程的引入"><a href="#2-7-1-线程的引入" class="headerlink" title="2.7.1 线程的引入"></a>2.7.1 线程的引入</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.程序并发执行所付出的时空开销</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）创建进程。系统在创建进程时，必须为之分配其所必需的、除处理机以外的所有资源。如内存空间、I/O设备以及建立相应的PCB。<br>&ensp;&ensp;&ensp;&ensp;（2）撤消进程。系统在撤消进程时，又必须先对这些资源进行回收操作，然后再撤消PCB。<br>&ensp;&ensp;&ensp;&ensp;（3）进程切换。在对进程进行切换时，由于要保留当前进程的CPU环境和设置新选中进程的CPU环境，为此需花费不少处理机时间。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.线程——作为调度和分派的基本单位</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;由于进程是一个资源的拥有者，所以在创建、撤销和切换中，系统必须付出较大的时空开销。正因如此，系统中设置的进程数目不宜过多，进程切换频率也不宜过高，这就限制了并发程度的进一步提高。<br>&ensp;&ensp;&ensp;&ensp;引入线程，以线程作为调度、分派和切换的基本单位，则可以有效地改善系统性能。  </p>
<h3 id="2-7-2-线程与进程的比较"><a href="#2-7-2-线程与进程的比较" class="headerlink" title="2.7.2 线程与进程的比较"></a>2.7.2 线程与进程的比较</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.调度的基本单位</strong>：在传统的操作系统中，拥有资源的基本单位和独立调度、分派的基本单位都是进程，因而调度时，开销较大。引入线程则把它作为独立运行的基本单位，切换线程时，仅需保存和设置少量的寄存器内容，代价较低。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.并发性</strong>：在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，因而使操作系统具有更好的并发性，从而能更有效地使用系统资源和提高系统吞吐量。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.拥有资源</strong>：不论是传统的操作系统，还是设有线程的操作系统，进程都是拥有资源的一个独立单位，它可以拥有自己的资源。线程本身并不拥有系统资源，而是仅有一点必需，保证独立运行的资源。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.独立性</strong>：同一进程中的不同线程之间的独立性比不同进程之间的独立性低得多。   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>5.系统开销</strong>：由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等。因此，操作系统所付出的开销将明显地大于在创建或撤消线程时的开销。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>6.支持多处理机系统</strong>：在多处理机系统中，传统的进程只能运行在一个处理机上。对于多线程进程，可将多个线程分配到多个处理机上，使它们并行执行。     </p>
<h3 id="2-7-3-线程的状态和线程控制块"><a href="#2-7-3-线程的状态和线程控制块" class="headerlink" title="2.7.3 线程的状态和线程控制块"></a>2.7.3 线程的状态和线程控制块</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.线程运行的三个状态</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;与传统进程一样，线程之间也存在着相互制约关系，使得线程运行时出现间断性，因而线程也有三种基本状态：<br>&ensp;&ensp;&ensp;&ensp;（1）执行状态。线程获得处理机正在运行。<br>&ensp;&ensp;&ensp;&ensp;（2）就绪状态。线程已具备了各种执行条件，只需再获得CPU便可执行。<br>&ensp;&ensp;&ensp;&ensp;（3）阻塞状态。线程因某个事件而处于暂停状态。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.线程控制块TCB</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;线程控制块通常包含以下几项内容：<br>&ensp;&ensp;&ensp;&ensp;①线程标识符；②一组寄存器，包括程序计数器，状态寄存器和通用寄存器；③线程运行状态；④线程优先级；⑤线程专有存储区；⑥信号屏蔽；⑦堆栈指针。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.多线程OS中的进程属性</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）作为系统资源分配的单位。（线程是资源调度的基本单位）<br>&ensp;&ensp;&ensp;&ensp;（2）可包括多个线程。一个进程都含有多个相对独立的线程，其数目可多可少，但至少要有一个线程，由进程为这些线程提供资源及运行环境，使这些线程可并发执行。<br>&ensp;&ensp;&ensp;&ensp;（3）进程不是一个可执行的实体。在多线程OS中，线程作为独立运行的基本单位。虽然如此，进程仍具有与执行相关的状态。所谓进程处于“执行”状态，实际上是指该进程中的<strong>某线程正在执行</strong>。把某<strong>进程挂起</strong>，该进程中的<strong>所有线程都将被挂起</strong>。    </p>
<h2 id="2-8-线程的实现"><a href="#2-8-线程的实现" class="headerlink" title="2.8 线程的实现"></a>2.8 线程的实现</h2><h3 id="2-8-1-线程的实现方式"><a href="#2-8-1-线程的实现方式" class="headerlink" title="2.8.1 线程的实现方式"></a>2.8.1 线程的实现方式</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.内核支持线程KST（Kernel Supported Threads）</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;内核支持线程KST（Kernel Supported Threads），指的是在内核支持下运行的，即无论是用户进程中的线程，还是系统进程中的线程，他们的创建、撤销和切换等也是依靠内核，在内核空间实现的。线程管理的所有工作都由内核完成。 </p>
<p>&ensp;&ensp;&ensp;&ensp;优点：<br>&ensp;&ensp;&ensp;&ensp;1）在多处理器系统中，内核能同时调度同一进程中的多个线程并行执行；<br>&ensp;&ensp;&ensp;&ensp;2）如果进程中的一个线程被阻塞了，内核可以调度该进程中的其他线程或运行其他进程中的线程；<br>&ensp;&ensp;&ensp;&ensp;3）内核支持线程具有很小的数据结构和堆栈，线程的切换比较快，切换开销小；<br>&ensp;&ensp;&ensp;&ensp;4）内核本身也可以采用多线程技术，可以提高系统的执行速度和效率。  </p>
<p>&ensp;&ensp;&ensp;&ensp;缺点：对于用户的线程切换而言，其切换的开销较大，在同一个进程中，从一个线程切换到另一个线程时，需要从用户态转到内核态进行。这是因为用户进程的线程在用户态运行，而线程调度和管理在内核实现，系统开销较大。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.用户级线程ULT（User Level Threads）</strong>    </p>
<p>&ensp;&ensp;&ensp;用户级线程ULT(User Level Threads)仅存在于用户空间中。对于这种线程的创建、撤销、线程之间的同步与通信等功能，都无须利用系统调用来实现。线程的管理由应用程序完成，在用户空间中实现，内核无需感知线程的存在。<br>&ensp;&ensp;&ensp;对于用户级线程的切换，通常发生在一个应用进程的诸多线程之间，这时，也同样无须内核的支持。  </p>
<p>&ensp;&ensp;&ensp;&ensp;优点：<br>&ensp;&ensp;&ensp;&ensp;1）线程切换不需要转换到内核空间；<br>&ensp;&ensp;&ensp;&ensp;2）调度算法可以是线程专用的；<br>&ensp;&ensp;&ensp;&ensp;3）用户级线程的实现与操作系统平台无关；  </p>
<p>&ensp;&ensp;&ensp;&ensp;缺点：<br>&ensp;&ensp;&ensp;&ensp;1）系统调用的阻塞问题。用户级线程执行系统调用时，不仅该线程阻塞，而且进程内的所有线程都会阻塞，而内核支持线程方式中，进程中的其它线程仍然可以运行；<br>&ensp;&ensp;&ensp;&ensp;2）单纯的用户级线程实现方式中，多线程应用不能利用多处理机进行多重处理的优点。内核每次分配给进程的只有一个CPU，因此进程中仅有一个线程能执行。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8724.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.组合方式</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;在该方式中，内核支持多个内核支持线程的建立，调度和管理，同时，也允许用户应用程序建立，调度和管理用户级线程。线程的创建是在用户层进行线程的调度和同步在用户层进行选择一部分用户级线程映射到一些内核级线程上。<br>&ensp;&ensp;&ensp;&ensp;它能够结合KST和ULT两者的优点，并克服了各自的不足。  </p>
<p>&ensp;&ensp;&ensp;&ensp;三种不同模型：<br>&ensp;&ensp;&ensp;&ensp;（1）多对一模型。即将多个用户线程映射到一个内核控制线程。这些用户线程一般属于一个进程，运行在该进程的用户空间，对这些线程的调度和管理也是在该进程的用户空间完成。仅当用户线程需要访问内核时，才将其映射到内核线程，每次只允许一个线程进行映射。<br>&ensp;&ensp;&ensp;&ensp;（2）一对一模型。即将每个用户线程映射到一个内核控制线程。当一个线程阻塞时允许另一个线程运行。此外，它允许多个线程并行运行在多处理机系统中。<br>&ensp;&ensp;&ensp;&ensp;（3）多对多模型。将多个用户线程映射到同样数量或更少数量的内核线程上。结合了上述两种模型的优点。  </p>
<h3 id="2-8-2-线程的实现"><a href="#2-8-2-线程的实现" class="headerlink" title="2.8.2 线程的实现"></a>2.8.2 线程的实现</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.内核支持线程的实现</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在仅设置了内核支持线程的OS中，一种可能的线程控制方法是，系统在创建一个进程时，便为它分配一个任务数据区PTDA（Per Task Data Area）其中包括若干个线程控制块TCB。TCB中可保存线程标识符、优先级、线程运行的CPU状态等信息。这些信息是被保存在内核空间中的。<br>&ensp;&ensp;&ensp;&ensp;之后对线程的创建、撤销均与进程的相类似；<br>&ensp;&ensp;&ensp;&ensp;内核支持线程的调度和切换与进程的调度和切换也类似  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.用户级线程的实现</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;用户级线程是在用户空间实现的。所有的用户级线程都具有相同的结构，它们都运行在一个中间系统的上面。<br>&ensp;&ensp;&ensp;&ensp;1）运行时系统：实质上是用于管理和控制线程的函数（过程）的集合，其中包括用于创建和撤销线程的函数、线程同步和通信的函数以及实现线程调度的函数等。<br>&ensp;&ensp;&ensp;&ensp;运行时系统的所有函数都驻留在用户空间，作为用户级线程和内核之间的接口。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8725.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）内核控制线程（组合方式）：这种线程又称为轻型进程LWP（Light Weight Process）。每一个进程都可拥有多个LWP，每个LWP都有自己的数据结构（如TCB）。LWP可以通过系统调用来获得内核提供的服务。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8726.png">   </p>
<h3 id="2-8-3-线程的创建和终止"><a href="#2-8-3-线程的创建和终止" class="headerlink" title="2.8.3 线程的创建和终止"></a>2.8.3 线程的创建和终止</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.线程的创建</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;应用程序在启动时，通常仅有一个线程在执行，人们把线程称为“初始化线程”，它的主要功能是用于创建新线程。在创建新线程时，需要利用一个线程创建函数（或系统调用），并提供相应的参数。创建函数执行完成后，返回一个线程标识符供以后使用。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.线程的终止</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;当一个线程完成了自己的任务后，或是线程在运行中出现异常情况而须被强行终止时，由终止线程通过调用相应的函数对它执行终止操作。在大多数OS中，线程被中止后并不立即释放它所占有的资源，只有当进程中的其它线程执行了分离函数后，被终止的线程才与资源分离，此时的资源才能被其它线程利用。<br>&ensp;&ensp;&ensp;&ensp;虽已被终止但尚未释放资源的线程，仍可以被需要它的线程所调用，以使被终止线程重新恢复运行。为此，调用者线程须调用一条被称为“等待线程终止”的连接命令，来与该线程进行连接。如果在一个调用者线程调用“等待线程终止”的连接命令试图与指定线程相连接时，若指定线程尚未被终止，则调用连接命令的线程将会阻塞，直至指定线程被终止后才能实现它与调用者线程的连接并继续执行；若指定线程已被终止，则调用者线程不会被阻塞而是继续执行。</p>

    </div>

    
    
    
<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------以上<i class="fa fa-paw"></i>（或许会有不定时更新）-------------</div>
    
</div>

  
</div>
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Komeiji Satori
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://kome1jisatori.github.io/2021/05/08/os-2/" title="操作系统笔记——第二章">https://kome1jisatori.github.io/2021/05/08/os-2/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/" rel="tag"># 课堂笔记</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/06/%E5%89%8D%E7%BC%80%E5%92%8C/" rel="prev" title="二维矩阵前缀和计算方法">
      <i class="fa fa-chevron-left"></i> 二维矩阵前缀和计算方法
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/09/os-3/" rel="next" title="操作系统笔记——第三章">
      操作系统笔记——第三章 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-text">第二章 进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E5%89%8D%E8%B6%8B%E5%9B%BE%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="nav-text">2.1 前趋图和程序执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-%E5%89%8D%E8%B6%8B%E5%9B%BE"><span class="nav-text">2.1.1 前趋图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%8F%8A%E5%85%B6%E7%89%B9%E5%BE%81"><span class="nav-text">2.1.2 程序的顺序执行及其特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E5%8F%8A%E5%85%B6%E7%89%B9%E5%BE%81"><span class="nav-text">2.1.3 程序的并发执行及其特征</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="nav-text">2.2 进程的描述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E5%BE%81"><span class="nav-text">2.2.1 进程的定义和特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2"><span class="nav-text">2.2.2 进程的基本状态及其转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-%E6%8C%82%E8%B5%B7%E6%93%8D%E4%BD%9C%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">2.2.3 挂起操作和进程状态的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-4-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">2.2.4 进程管理中的数据结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text">2.3 进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8"><span class="nav-text">2.3.1 操作系统内核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">2.3.2 进程的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="nav-text">2.3.3 进程的终止</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4-%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92"><span class="nav-text">2.3.4 进程的阻塞与唤醒</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-5-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8C%82%E8%B5%B7%E4%B8%8E%E6%BF%80%E6%B4%BB"><span class="nav-text">2.3.5 进程的挂起与激活</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-text">2.4 进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">2.4.1 进程同步的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-%E7%A1%AC%E4%BB%B6%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="nav-text">2.4.2 硬件同步机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-3-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="nav-text">2.4.3 信号量机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-4-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">2.4.4 信号量的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-5-%E7%AE%A1%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="nav-text">2.4.5 管程机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="nav-text">2.5 经典进程的同步问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-1-%E7%94%9F%E4%BA%A7%E8%80%85%E2%80%94%E2%80%94%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-text">2.5.1 生产者——消费者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-2-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-text">2.5.2 哲学家进餐问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-3-%E8%AF%BB%E8%80%85%E2%80%94%E2%80%94%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-text">2.5.3 读者——写者问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-text">2.6 进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-1-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">2.6.1 进程通信的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-2-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E9%80%9A%E4%BF%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-text">2.6.2 消息传递通信的实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-3-%E7%9B%B4%E6%8E%A5%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B"><span class="nav-text">2.6.3 直接消息传递系统实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-%E7%BA%BF%E7%A8%8B%EF%BC%88THREAD%EF%BC%89%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">2.7 线程（THREAD）的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-text">2.7.1 线程的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-2-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-text">2.7.2 线程与进程的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-text">2.7.3 线程的状态和线程控制块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-8-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.8 线程的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-text">2.8.1 线程的实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.8.2 线程的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%BB%88%E6%AD%A2"><span class="nav-text">2.8.3 线程的创建和终止</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Komeiji Satori" src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Komeiji Satori</p>
  <div class="site-description" itemprop="description">记录些有的没的的学习心得</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kome1jisatori" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kome1jisatori" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=740775405&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;740775405&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      膜大佬的链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://sherlockcoder.xyz/" title="http:&#x2F;&#x2F;sherlockcoder.xyz" rel="noopener" target="_blank">不朽之存在的首页</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://datawhalechina.github.io/leeml-notes/#/" title="https:&#x2F;&#x2F;datawhalechina.github.io&#x2F;leeml-notes&#x2F;#&#x2F;" rel="noopener" target="_blank">机器学习笔记(LeeML-Notes)</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备 - 2021020302 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KomeijiSatori</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">205k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:06</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '8NhM2OcimmX1hgpelhxOhQK8-gzGzoHsz',
      appKey     : 'bQ1303bPFHzcUrkoBzb39dgO',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>



  <script type="text/javascript" color="0,0,0" opacity="0.5" zindex="-1" count="150" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true},"log":false});</script></body>
</html>

      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/Kome1jiSatori.github.io/">KOME1JISATORI.GITHUB.IO</a></li>
            <li><a href="/Kome1jiSatori.github.io/2021/">2021</a></li>
            <li><a href="/Kome1jiSatori.github.io/2021/05/">05</a></li>
            <li><a href="/Kome1jiSatori.github.io/2021/05/08/">08</a></li>
          <li>OS-2</li>
        
  </ul>

    
    
    


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">KomeijiSatoriのblog</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">
          操作系统笔记——第二章
        </span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-text">第二章 进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E5%89%8D%E8%B6%8B%E5%9B%BE%E5%92%8C%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="nav-text">2.1 前趋图和程序执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-%E5%89%8D%E8%B6%8B%E5%9B%BE"><span class="nav-text">2.1.1 前趋图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%8F%8A%E5%85%B6%E7%89%B9%E5%BE%81"><span class="nav-text">2.1.2 程序的顺序执行及其特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E5%8F%8A%E5%85%B6%E7%89%B9%E5%BE%81"><span class="nav-text">2.1.3 程序的并发执行及其特征</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="nav-text">2.2 进程的描述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E5%BE%81"><span class="nav-text">2.2.1 进程的定义和特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2"><span class="nav-text">2.2.2 进程的基本状态及其转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-%E6%8C%82%E8%B5%B7%E6%93%8D%E4%BD%9C%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">2.2.3 挂起操作和进程状态的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-4-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">2.2.4 进程管理中的数据结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text">2.3 进程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8"><span class="nav-text">2.3.1 操作系统内核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">2.3.2 进程的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="nav-text">2.3.3 进程的终止</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4-%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92"><span class="nav-text">2.3.4 进程的阻塞与唤醒</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-5-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8C%82%E8%B5%B7%E4%B8%8E%E6%BF%80%E6%B4%BB"><span class="nav-text">2.3.5 进程的挂起与激活</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-text">2.4 进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">2.4.1 进程同步的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-%E7%A1%AC%E4%BB%B6%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="nav-text">2.4.2 硬件同步机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-3-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="nav-text">2.4.3 信号量机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-4-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">2.4.4 信号量的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-5-%E7%AE%A1%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="nav-text">2.4.5 管程机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="nav-text">2.5 经典进程的同步问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-1-%E7%94%9F%E4%BA%A7%E8%80%85%E2%80%94%E2%80%94%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-text">2.5.1 生产者——消费者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-2-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-text">2.5.2 哲学家进餐问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-3-%E8%AF%BB%E8%80%85%E2%80%94%E2%80%94%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-text">2.5.3 读者——写者问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-text">2.6 进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-1-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">2.6.1 进程通信的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-2-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E9%80%9A%E4%BF%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-text">2.6.2 消息传递通信的实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-3-%E7%9B%B4%E6%8E%A5%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%B3%BB%E7%BB%9F%E5%AE%9E%E4%BE%8B"><span class="nav-text">2.6.3 直接消息传递系统实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-%E7%BA%BF%E7%A8%8B%EF%BC%88THREAD%EF%BC%89%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">2.7 线程（THREAD）的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-text">2.7.1 线程的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-2-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-text">2.7.2 线程与进程的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-text">2.7.3 线程的状态和线程控制块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-8-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.8 线程的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-text">2.8.1 线程的实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.8.2 线程的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%BB%88%E6%AD%A2"><span class="nav-text">2.8.3 线程的创建和终止</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Komeiji Satori"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Komeiji Satori</p>
  <div class="site-description" itemprop="description">记录些有的没的的学习心得</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kome1jisatori" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kome1jisatori" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=740775405&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;740775405&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      膜大佬的链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://sherlockcoder.xyz/" title="http:&#x2F;&#x2F;sherlockcoder.xyz" rel="noopener" target="_blank">不朽之存在的首页</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://datawhalechina.github.io/leeml-notes/#/" title="https:&#x2F;&#x2F;datawhalechina.github.io&#x2F;leeml-notes&#x2F;#&#x2F;" rel="noopener" target="_blank">机器学习笔记(LeeML-Notes)</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备 - 2021020302 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KomeijiSatori</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">243k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:41</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '8NhM2OcimmX1hgpelhxOhQK8-gzGzoHsz',
      appKey     : 'bQ1303bPFHzcUrkoBzb39dgO',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>



  <script type="text/javascript" color="0,0,0" opacity='0.5' zIndex="-1" count="150" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true},"log":false});</script></body>
</html>
