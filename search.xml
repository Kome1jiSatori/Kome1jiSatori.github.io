<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android实验课作业四 后台质数运算</title>
    <url>/2021/11/11/Android4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>后台质数运算（复习一下筛法求素数，虽然代码没用到）</p>
<span id="more"></span> 

<h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><p>使用WorkManager，开启后台线程计算100万以内的质数（不需要输出），并结合第4章提到的ProgressBar，显示后台程序进度。  </p>
<h1 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h1><p>Android Studio、Kotlin  </p>
<h1 id="三、主要实验步骤"><a href="#三、主要实验步骤" class="headerlink" title="三、主要实验步骤"></a>三、主要实验步骤</h1><p>1）打开Android Studio，新建工程Prime，如图所示：<br><img src="/2021/11/11/Android4/%E5%9B%BE%E7%89%871.png">   </p>
<p>2）为了使用WorkManager类，首先需要添加该类的依赖，如下图所示：<br><img src="/2021/11/11/Android4/%E5%9B%BE%E7%89%872.png">   </p>
<p>3）将依赖添加成功之后，准备工作就做好了，接着可以开始使用WorkManager。首先定义一个后台任务，这里创建一个PrimeWorker类，如下图所示：<br><img src="/2021/11/11/Android4/%E5%9B%BE%E7%89%873.png">   </p>
<p>该类必须继承自worker类，并调用它唯一的构造函数然 后 重 写 父 类 中 的 doWork() 方 法， 在 这 个 方 法 中 编 写 具 体 的 后 台 任 务 逻 辑任务，即计算100万以内的质数，具体代码如下图所示：<br><img src="/2021/11/11/Android4/%E5%9B%BE%E7%89%874.png">    </p>
<p>设置一个二重循环，如果i不能被从2到i-1的数字整除，则认为它是一个质数，并将其输出。另外dowork()方法要求返回一个Result对象，成 功 就 返 回 Result.success()。<br>4）接下来可以进入到第二步，配置该后台任务的运行条件和约束信息，由于该任务中不需要配置额外的限制信息，因此只进行最基本的配置就可以，代码如下图所示：<br><img src="/2021/11/11/Android4/%E5%9B%BE%E7%89%875.png">   </p>
<p>最后将构建出的后台任务请求传入WorkManager的enqueue()方法中，系统就会在合适的时间去执行。<br>5）完成WorkRquest的配置后，我们希望它在点击按钮后运行后台程序，在activity_mian.xml中绘制按钮Start Caculating和Stop Caculating，并绘制一条进度条progressbar，用来记录后台运行的进度，代码如下图所示：<br><img src="/2021/11/11/Android4/%E5%9B%BE%E7%89%876.png">   </p>
<p>设置控件的各项属性，将progressbar的max值设置为100，方便之后的进度记录。<br>该界面的视图如下图所示：<br><img src="/2021/11/11/Android4/%E5%9B%BE%E7%89%877.png">   </p>
<p>6）接着回到MainActivity，使用findViewById方法找到两个按钮和一个进度条，分别使按钮在点击时实现PrimeWorker入队和取消所有队列中的进程的功能，如下图所示：<br><img src="/2021/11/11/Android4/%E5%9B%BE%E7%89%878.png">   </p>
<p>7）最后需要实现的功能是用progressbar记录后台服务的进度，由于找质数的方法是遍历从1到100万的每一个数字，所以可以通过循环中的i来判断后台服务的完成进度。<br>首先在PrimeWorker将i放入Data对象中，并将其返回到MainActivity，如下图示：<br><img src="/2021/11/11/Android4/%E5%9B%BE%E7%89%879.png">   </p>
<p>接着在MainActivity中使用监视器取出i值，并且可以在该返回值更新时实时更新界面的ui，即这里的progressbar，具体代码如下图所示：<br><img src="/2021/11/11/Android4/%E5%9B%BE%E7%89%8710.png">   </p>
<p>需要注意的是，进度条设置的最大值为100，取出的i的值需要除以10000来得到进度，并且为了能够在运行完成后保持进度条处于满的进度，当workinfo中的状态为succeeded时，将进度条设置为满。<br>8）接着就可以尝试运行代码，点击Start Caculating，即可开始后台的运算，在run中可以看到输出结果，如下图示：<br><img src="/2021/11/11/Android4/%E5%9B%BE%E7%89%8711.png">   </p>
<p>可以看到进度条也可以正常运行，如下图所示：<br><img src="/2021/11/11/Android4/%E5%9B%BE%E7%89%8712.png">   </p>
<p>运算完成之后，进度条保持在100不变，如下图所示：<br><img src="/2021/11/11/Android4/%E5%9B%BE%E7%89%8713.png">   </p>
<p>至此，成功完成了实验的要求，实验成功。  </p>
<h1 id="代码附录"><a href="#代码附录" class="headerlink" title="代码附录"></a>代码附录</h1><h2 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.prime</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.widget.Button</span><br><span class="line"><span class="keyword">import</span> android.widget.ProgressBar</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.LiveData</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.Observer</span><br><span class="line"><span class="keyword">import</span> androidx.work.OneTimeWorkRequest</span><br><span class="line"><span class="keyword">import</span> androidx.work.WorkInfo</span><br><span class="line"><span class="keyword">import</span> androidx.work.WorkManager</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        <span class="keyword">val</span> doWorkBtn: Button = findViewById(R.id.doWorkBtn)</span><br><span class="line">        <span class="keyword">val</span> stopWorkBtn: Button = findViewById(R.id.StopWorkBtn)</span><br><span class="line">        <span class="keyword">val</span> bar: ProgressBar = findViewById(R.id.progressBar)</span><br><span class="line">        <span class="keyword">val</span> request = OneTimeWorkRequest.Builder(PrimeWorker::<span class="keyword">class</span>.java).build()</span><br><span class="line">        doWorkBtn.setOnClickListener&#123;</span><br><span class="line">            WorkManager.getInstance(<span class="keyword">this</span>).enqueue(request)</span><br><span class="line">            WorkManager.getInstance(<span class="keyword">this</span>).getWorkInfoByIdLiveData(request.id).observe(<span class="keyword">this</span>,</span><br><span class="line">                Observer&#123; workinfo: WorkInfo? -&gt;</span><br><span class="line">                <span class="keyword">if</span>(workinfo != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">val</span> progress = workinfo.progress</span><br><span class="line">                    <span class="keyword">val</span> value = progress.getInt(<span class="string">&quot;Progress&quot;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">//                    Log.d(&quot;MainActivity&quot;, &quot;$value\n&quot;)</span></span><br><span class="line">                    <span class="keyword">val</span> value2 = value / <span class="number">10000</span></span><br><span class="line">                    bar.setProgress(value2)</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="keyword">if</span>(workinfo?.state == WorkInfo.State.SUCCEEDED) bar.setProgress(<span class="number">100</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        stopWorkBtn.setOnClickListener &#123;</span><br><span class="line">            WorkManager.getInstance(<span class="keyword">this</span>).cancelWorkById(request.id)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PrimeWorker"><a href="#PrimeWorker" class="headerlink" title="PrimeWorker"></a>PrimeWorker</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.prime</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> androidx.work.*</span><br><span class="line"><span class="keyword">import</span> java.lang.Exception</span><br><span class="line"><span class="keyword">import</span> java.lang.Math.sqrt</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeWorker</span> </span>(context: Context, params: WorkerParameters) : Worker(context, params) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        <span class="keyword">val</span> start: <span class="built_in">Int</span> = <span class="number">2</span></span><br><span class="line">        <span class="keyword">val</span> end: <span class="built_in">Int</span> = <span class="number">1000000</span></span><br><span class="line">        <span class="keyword">var</span> isPrime: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span>(i <span class="keyword">in</span> start..end)&#123;</span><br><span class="line">            isPrime = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">for</span>(j <span class="keyword">in</span> <span class="number">2</span> until i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">                    isPrime = <span class="literal">false</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isPrime) Log.d(<span class="string">&quot;PrimeWorker&quot;</span>, <span class="string">&quot;<span class="variable">$i</span>\n&quot;</span>)</span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">data</span>: Data = Data.Builder().putInt(<span class="string">&quot;Progress&quot;</span>, i).build()</span><br><span class="line">            setProgressAsync(<span class="keyword">data</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>)</span><br><span class="line">            &#125;<span class="keyword">catch</span> (e: Exception)&#123;</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.success()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStopped</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStopped()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="activity-main-xml"><a href="#activity-main-xml" class="headerlink" title="activity_main.xml"></a>activity_main.xml</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout</span><br><span class="line">    xmlns:android &#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    android:layout_width &#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height &#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:orientation &#x3D;&quot;vertical&quot; &gt;</span><br><span class="line">    &lt;Button android:id &#x3D;&quot;@+id&#x2F;doWorkBtn&quot;</span><br><span class="line">        android:layout_width &#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height &#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_gravity &#x3D;&quot;center_horizontal&quot;</span><br><span class="line">        android:text &#x3D;&quot;Start Caculating&quot;&#x2F;&gt;</span><br><span class="line">    &lt;ProgressBar</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;progressBar&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        style&#x3D;&quot;?android:attr&#x2F;progressBarStyleHorizontal&quot;</span><br><span class="line">        android:max&#x3D;&quot;100&quot;</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line">    &lt;Button android:id &#x3D;&quot;@+id&#x2F;StopWorkBtn&quot;</span><br><span class="line">        android:layout_width &#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height &#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:layout_gravity &#x3D;&quot;center_horizontal&quot;</span><br><span class="line">        android:text &#x3D;&quot;Stop Caculating&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>实验课作业</tag>
      </tags>
  </entry>
  <entry>
    <title>Android实验课作业五 Json解析</title>
    <url>/2021/11/11/Android5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>实验五，解析套娃json</p>
<span id="more"></span> 

<h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><p>解析提供的素材shanghaiindex2021018.json，将解析后的时间、指数和成交量进行日志打印输出</p>
<h1 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h1><p>Android Studio、Kotlin</p>
<h1 id="三、主要实验步骤"><a href="#三、主要实验步骤" class="headerlink" title="三、主要实验步骤"></a>三、主要实验步骤</h1><p>该实验主要分为以下几个步骤：<br>①以计算机为服务器构建web网页端便于安卓手机访问②使用okhttp发起POST请求，返回String类型的Json内容③使用Gson解析Json内容并于日志中输出时间、指数和成交量等数据。<br>1）下载本课程第十一章的素材，打开httpd-2.4.51-win64-VS16.zip，按照readme的说明进行安装，即解压Apach24文件夹至C盘，接着打开命令行，将目录调至Apache24/bin下，并运行httpd.exe，如下图所示：  </p>
<img src="/2021/11/11/Android5/%E5%9B%BE%E7%89%871.png" class>      

<p>看到光标自动跳转到下一行说明成功运行。在浏览器中输入<a href="http://localhost,显示it/">http://localhost，显示It</a> works表明Apache运行正常，如下图所示：  </p>
<img src="/2021/11/11/Android5/%E5%9B%BE%E7%89%872.png" class>     

<p>2）接着将本次实验所需要用到的json文件shanghaiindex20210108.json，放入C:\Apache\htdocs目录下，这时在浏览器中访问<a href="http://127.0.0.1/shanghaiindex20210108.json%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E8%AF%A5json%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA%EF%BC%9A">http://127.0.0.1/shanghaiindex20210108.json，就可以看到该json文件的内容，如下图所示：</a>  </p>
<img src="/2021/11/11/Android5/%E5%9B%BE%E7%89%873.png" class>     
<p>3）准备工作就到此结束了，接着打开Android studio，创建新工程JsonTest，如下图所示：  </p>
<img src="/2021/11/11/Android5/%E5%9B%BE%E7%89%874.png" class>      

<p>4）因为需要使用okhttp发送POST请求，首先需要在app/build.gradle文件中添加相关的依赖包，如下图所示：  </p>
<img src="/2021/11/11/Android5/%E5%9B%BE%E7%89%875.png" class>      

<p>5）接着构造函数，发出POST请求，得到Json文件的内容，代码如下图所示：  </p>
<img src="/2021/11/11/Android5/%E5%9B%BE%E7%89%876.png" class>      

<p>首先创建一个request的对象设置目标的网址，接着以String的数据类型记录json的主体，然后使用parseJSONWithGSON函数对该主体进行解析，下面介绍parseJSONWithGSON函数。<br>6）在parseJSONWithGSON函数中需要使用到GSON开源库，因此需要在app/build.gradle文件中添加以下依赖：  </p>
<img src="/2021/11/11/Android5/%E5%9B%BE%E7%89%877.png" class>      

<p>GSON库的强大之处就在于可以将一段JSON格式的字符串自动映射成一个对象，不需要再手动编写代码进行解析。<br>7）观察json的主体，发现该json分为多层，最外层有两个属性，分别为“success”和“result”，其中“success”为Int类型的数据，取值为1，“result”中又含有4个不同的属性“dtQuery”、“dtCount”、“dtAppend”和“dtList”，其中“dtQuery”和“dtCount”为两个Int类型的数据，“dtAppend”包含4个不同的属性，“dtList”是一个{“dateYmdhi”，”lastPrice”，”volume”}的列表，我们需要读取的即是dtList列表中的各个属性值。<br>8）解读完json的主体结构后，就可以根据该结构构建用于GSON映射的对象，构建类APP，如下图所示：  </p>
<img src="/2021/11/11/Android5/%E5%9B%BE%E7%89%878.png" class>      

<p>9）接着使用GSON提供的相关方法，即可取出我们需要的数据，具体代码如下图所示：  </p>
<img src="/2021/11/11/Android5/%E5%9B%BE%E7%89%879.png" class>      

<p>首先创建一个gson的对象，接着使用该对象中的方法fromJson用App类的格式创建基于Json解析的对象，接着读出我们需要的数据所在的列表dtlist，最后对dtlist进行遍历，并在日志中打印出各项的解析后的时间、指数和成交量。<br>10）最后在activity_main.xml中添加一个按钮，并修改MainActivity，按下按钮时调用sendRequestWithOkHttp函数，如下图所示：  </p>
<img src="/2021/11/11/Android5/%E5%9B%BE%E7%89%8710.png" class>      

<p>11）最后在虚拟机上运行程序，如下图所示：  </p>
<img src="/2021/11/11/Android5/%E5%9B%BE%E7%89%8711.png" class>      

<p>点击按钮，可以在Run界面中看到解析得到的Json数据，如下图所示：  </p>
<img src="/2021/11/11/Android5/%E5%9B%BE%E7%89%8712.png" class>      

<p>成功解析出了需要的数据，说明实验成功。  </p>
<h1 id="代码附录"><a href="#代码附录" class="headerlink" title="代码附录"></a>代码附录</h1><h2 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jsontest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> android.widget.Button</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"><span class="keyword">import</span> com.google.gson.Gson</span><br><span class="line"><span class="keyword">import</span> com.google.gson.reflect.TypeToken</span><br><span class="line"><span class="keyword">import</span> okhttp3.OkHttpClient</span><br><span class="line"><span class="keyword">import</span> okhttp3.Request</span><br><span class="line"><span class="keyword">import</span> org.json.JSONArray</span><br><span class="line"><span class="keyword">import</span> org.json.JSONObject</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection</span><br><span class="line"><span class="keyword">import</span> java.net.URL</span><br><span class="line"><span class="keyword">import</span> kotlin.concurrent.thread</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        <span class="keyword">val</span> sendRequestBtn: Button = findViewById(R.id.sendRequestBtn)</span><br><span class="line">        sendRequestBtn.setOnClickListener &#123;</span><br><span class="line">            sendRequestWithOkHttp()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendRequestWithOkHttp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        thread &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> client = OkHttpClient()</span><br><span class="line">                <span class="keyword">val</span> request = Request.Builder()</span><br><span class="line">                    <span class="comment">// 指定访问的服务器地址是计算机本机</span></span><br><span class="line">                    .url(<span class="string">&quot;http://10.0.2.2/shanghaiindex20210108.json&quot;</span>)</span><br><span class="line">                    .build()</span><br><span class="line">                <span class="keyword">val</span> response = client.newCall(request).execute()</span><br><span class="line">                <span class="keyword">val</span> responseData = response.body?.string()</span><br><span class="line">                <span class="keyword">if</span> (responseData != <span class="literal">null</span>) &#123;</span><br><span class="line">                    parseJSONWithGSON(responseData)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">parseJSONWithGSON</span><span class="params">(jsonData: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> gson = Gson()</span><br><span class="line">        <span class="keyword">val</span> row_appList = gson.fromJson(jsonData, App::<span class="keyword">class</span>.java)</span><br><span class="line">        <span class="keyword">val</span> appList = row_appList.result.dtList</span><br><span class="line">        <span class="keyword">for</span> (app <span class="keyword">in</span> appList) &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;dateYmdhi is <span class="subst">$&#123;app.dateYmdhi&#125;</span>&quot;</span>)</span><br><span class="line">            Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;lastPrice is <span class="subst">$&#123;app.lastPrice&#125;</span>&quot;</span>)</span><br><span class="line">            Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;volume is <span class="subst">$&#123;app.volume&#125;</span>&quot;</span>)</span><br><span class="line">            Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;-----------------------------------&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span></span>(<span class="keyword">val</span> success: String, <span class="keyword">val</span> result: Result)&#123;</span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span></span>(<span class="keyword">val</span> dtQuery: String, <span class="keyword">val</span> dtcount: String, <span class="keyword">val</span> dtAppend: DtAppend, <span class="keyword">val</span> dtList: List&lt;DtList&gt;)&#123;</span><br><span class="line">        <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">DtAppend</span></span>(<span class="keyword">val</span> htType: String, <span class="keyword">val</span> inxId: String, <span class="keyword">val</span> inxNm: String)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">DtList</span></span>(<span class="keyword">val</span> dateYmdhi: String, <span class="keyword">val</span> lastPrice: String, <span class="keyword">val</span> volume: String)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="activity-main-xml"><a href="#activity-main-xml" class="headerlink" title="activity_main.xml"></a>activity_main.xml</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    android:orientation&#x3D;&quot;vertical&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot; &gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;sendRequestBtn&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:text&#x3D;&quot;Send Request&quot; &#x2F;&gt;</span><br><span class="line">    &lt;ScrollView</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;match_parent&quot; &gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;responseText&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;wrap_content&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;ScrollView&gt;</span><br><span class="line">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>实验课作业</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记——第一章（绝赞更新中）</title>
    <url>/2021/04/19/OS-1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>个人操作系统笔记整理，欢迎参考，时不时更新。  </p>
<span id="more"></span>

<h1 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章  操作系统引论"></a>第一章  操作系统引论</h1><h2 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h2><h3 id="一、计算机系统的组成"><a href="#一、计算机系统的组成" class="headerlink" title="一、计算机系统的组成"></a>一、计算机系统的组成</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1．计算机系统是由硬件和软件两部分组成</strong></p>
<p><img src="/2021/04/19/OS-1/gainian.jpg" alt="计算机系统的组成">  </p>
<p>&ensp;&ensp;&ensp;&ensp;硬件部分：构成了系统本身和用户作业赖以活动的物质基础和环境。<br>&ensp;&ensp;&ensp;&ensp;系统软件：主要管理计算机系统本身的操作；<br>&ensp;&ensp;&ensp;&ensp;应用软件: 主要解决用户的问题。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2．操作系统在计算机系统中的地位和作用</strong> </p>
<p><img src="/2021/04/19/OS-1/diwei.png" alt="操作系统的地位">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>计算机的层次结构</strong></p>
<p><img src="/2021/04/19/OS-1/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="层次结构">  </p>
<p>&ensp;&ensp;&ensp;&ensp;操作系统的地位：是系统硬件之上的第一层软件，为其他软件提供单向支撑作用。<br>&ensp;&ensp;&ensp;&ensp;裸机：没有任何软件支持的计算机。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3．操作系统的定义</strong>  </p>
<ul>
<li>计算机系统中的一个大型的<font color="#FF0000">系统软件</font>   </li>
<li>它用来<font color="#FF0000">管理和控制</font>计算机系统中的全部软、硬件<font color="#FF0000">资源</font>  </li>
<li>合理地组织计算机的工作流程  </li>
<li>为用户应用程序的运行提供一个<font color="#FF0000">友好的界面和良好的工作环境。</font>  </li>
</ul>
<h2 id="操作系统的目标和作用"><a href="#操作系统的目标和作用" class="headerlink" title="操作系统的目标和作用"></a>操作系统的目标和作用</h2><h3 id="一、操作系统的目标"><a href="#一、操作系统的目标" class="headerlink" title="一、操作系统的目标"></a>一、操作系统的目标</h3><ul>
<li>有效性(系统管理人员的观点)：合理地组织计算机系统的工作流程，管理和分配各种硬件和软件资源，提高计算机系统资源利用率和系统吞吐量。</li>
<li>方便性(用户的观点)：提供良好的、一致的用户接口。无需了解许多有关硬件和系统软件的细节。</li>
<li>可扩充性：指OS应采用层次化、模块化结构，给计算机系统的功能的扩展提供开放式的支撑平台。</li>
<li>开放性：指系统遵循世界标准规范，特别是遵循开放系统互联0SI国际标准。</li>
</ul>
<h3 id="二、操作系统的作用"><a href="#二、操作系统的作用" class="headerlink" title="二、操作系统的作用"></a>二、操作系统的作用</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.OS作为用户与计算机硬件系统之间的接口</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;OS处于用户与计算机硬件系统之间，用户通过OS来使用计算机系统。<br><img src="/2021/04/19/OS-1/%E6%8E%A5%E5%8F%A3%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="OS作为接口示意图"><br>&ensp;&ensp;&ensp;&ensp;使用方式：<br>&ensp;&ensp;&ensp;&ensp;（1）命令方式。这是指由OS提供了一组联机命令(语言)， 用户可通过键盘输入有关命令，来直接操纵计算机系统<br>&ensp;&ensp;&ensp;&ensp;（2）系统调用方式。OS提供了一组系统调用，用户可在自己的应用程序中通过相应的系统调用，来操纵计算机。<br>&ensp;&ensp;&ensp;&ensp;（3）图形、窗口方式。用户通过屏幕上的窗口和图标来操纵计算机系统和运行自己的程序。<br>&ensp;&ensp;&ensp;&ensp;<strong>2.OS作为计算机系统资源的管理者</strong><br><img src="/2021/04/19/OS-1/%E6%B5%81%E7%A8%8B%E5%9B%BE1.png" alt="资源的管理者">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.OS实现了对计算机资源的抽象</strong></p>
<ul>
<li>在裸机上添加：处理机管理(针对CPU)、存储管理(针对内存和外存)、设备管理 、文件管理</li>
<li>把覆盖了软件的机器称为扩充机或虚拟机器</li>
<li>合理组织工作流程：作业管理、进程管理  </li>
</ul>
<p><img src="/2021/04/19/OS-1/detail.png" alt="细节">  </p>
<h3 id="三、推动操作系统发展的动力"><a href="#三、推动操作系统发展的动力" class="headerlink" title="三、推动操作系统发展的动力"></a>三、推动操作系统发展的动力</h3><ul>
<li>不断提高计算机资源利用率</li>
<li>方便用户</li>
<li>器件的不断更新换代</li>
<li>计算机体系结构的不断发展</li>
<li>不断提出新的应用需求  </li>
</ul>
<h2 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h2><h3 id="无操作系统的计算机系统"><a href="#无操作系统的计算机系统" class="headerlink" title="无操作系统的计算机系统"></a>无操作系统的计算机系统</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1、人工操作阶段</strong><br>&ensp;&ensp;&ensp;&ensp;电子管时代，1945-50年代:<br>&ensp;&ensp;&ensp;&ensp;手工操作计算机，用机器语言编写程序，操作繁琐、易出错，效率低，CPU等待人工操作、利用率低<br><img src="/2021/04/19/OS-1/%E6%89%8B%E5%B7%A5%E6%93%8D%E4%BD%9C.png" alt="手工操作计算机"><br>&ensp;&ensp;&ensp;&ensp;手工操作的缺点：<br>&ensp;&ensp;&ensp;&ensp;（1）易出错、操作繁琐、难于掌握<br>&ensp;&ensp;&ensp;&ensp;（2）CPU的利用率低<br>&ensp;&ensp;&ensp;&ensp;提高效率低途径：<br>&ensp;&ensp;&ensp;&ensp;（1）专门的操作员/批量处理<br>&ensp;&ensp;&ensp;&ensp;（2）脱机I/O<br>&ensp;&ensp;&ensp;&ensp;（3）通道技术、中断技术、缓冲技术<br>&ensp;&ensp;&ensp;&ensp;<strong>2. 脱机输入/输出(Off-Line I/O)方式</strong><br>&ensp;&ensp;&ensp;&ensp;这种脱机I/O方式的主要优点如下：<br>&ensp;&ensp;&ensp;&ensp;（1）减少了CPU的空闲时间。<br>&ensp;&ensp;&ensp;&ensp;（2）提高I/O速度。<br><img src="/2021/04/19/OS-1/%E8%84%B1%E6%9C%BA.png" alt="I/O脱机">  </p>
<h3 id="成批处理阶段"><a href="#成批处理阶段" class="headerlink" title="成批处理阶段"></a>成批处理阶段</h3><p>&ensp;&ensp;&ensp;&ensp;晶体管时代，50年代末-60年代中，随着中央处理机速度的大幅度提高，人工操作的慢速度和中央处理机运算的高速度之间出现了矛盾，即所谓人机矛盾。为解决这一矛盾，只有设法去掉人工操作，实现作业的自动过渡，这样就出现了成批处理。<br>&ensp;&ensp;&ensp;&ensp;监督程序：是一个常驻内存的小的核心代码，用于实现各作业之间的自动转接，提高了系统效率。<br>&ensp;&ensp;&ensp;&ensp;<strong>1.单道批处理:</strong>    </p>
<ul>
<li>利用磁带把若干作用分类编成作业执行序列  </li>
<li>每批作业由一个专门的监督程序自动依次处理  </li>
<li>可使用汇编语言开发<br><img src="/2021/04/19/OS-1/%E5%8D%95%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86.png" alt="单道批处理"><br>&ensp;&ensp;&ensp;&ensp;单道批处理系统特点：自动性、顺序性、单道性<br>&ensp;&ensp;&ensp;&ensp;成批处理经历了两个阶段：<br>&ensp;&ensp;&ensp;&ensp;联机批处理阶段和脱机批处理阶段。</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;联机批处理系统：作业的I/O和计算全部由CPU直接控制。<br><img src="/2021/04/19/OS-1/%E8%81%94%E6%9C%BA%E6%89%B9%E5%A4%84%E7%90%86.png" alt="联机批处理">  </p>
<p>&ensp;&ensp;&ensp;&ensp;脱机批处理系统：由主机和外围计算机（卫星机）组成，外围计算机负责I/O处理，主机和外围计算机可以并行工作。<br><img src="/2021/04/19/OS-1/%E8%84%B1%E6%9C%BA%E6%89%B9%E5%A4%84%E7%90%86.png" alt="脱机批处理"><br> &ensp;&ensp;&ensp;&ensp;<strong>2.多道批处理系统</strong><br>&ensp;&ensp;&ensp;&ensp;多道程序设计技术是指在计算机内存中同时存放多个作业，它们在管理程序控制之下交替执行，共享系统中的各种资源。60年代中-70年代中(集成电路)<br>多道程序运行的特征：<br> &ensp;&ensp;&ensp;&ensp;（1）主存中存放多道程序；<br> &ensp;&ensp;&ensp;&ensp;（2）宏观上并行；<br> &ensp;&ensp;&ensp;&ensp;（3）微观上串行。<br><img src="/2021/04/19/OS-1/%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86.jpg" alt="多道批处理">  </p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言笔记（二）</title>
    <url>/2021/09/19/R2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>呜呜开始听不懂了</p>
<span id="more"></span> 

<p>贴下<a href="https://meeting.tencent.com/user-center/shared-record-info?id=ac2d1896-4877-40a7-947b-b1f58b8cb9b9&from=3">课堂回放</a>地址<br>密码：1Qyvc8ge</p>
<h1 id="一、课堂一些练习"><a href="#一、课堂一些练习" class="headerlink" title="一、课堂一些练习"></a>一、课堂一些练习</h1><h2 id="1-求a到b之间的最大值函数"><a href="#1-求a到b之间的最大值函数" class="headerlink" title="1.求a到b之间的最大值函数"></a>1.求a到b之间的最大值函数</h2><p>代码如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x &lt;- 1:<span class="number">10</span></span><br><span class="line">a &lt;- 3</span><br><span class="line">b &lt;- 7</span><br><span class="line">maxstart &lt;- -<span class="number">1</span></span><br><span class="line">maxinfo &lt;- <span class="keyword">function</span>(x,a,b,maxstart=-<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span> (j <span class="keyword">in</span> a:b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(x[j]&gt;maxstart)</span><br><span class="line">      max.index=j</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> (<span class="built_in">c</span>(maxstart,max.index))</span><br><span class="line">&#125;</span><br><span class="line">maxinfo(<span class="built_in">c</span>(<span class="number">1</span>:<span class="number">10</span>),<span class="number">3</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>得到输出如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; maxinfo(<span class="built_in">c</span>(<span class="number">1</span>:<span class="number">10</span>),<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">[<span class="number">1</span>] -<span class="number">1</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="2-求a到b之间最小值的两个值的平均值函数"><a href="#2-求a到b之间最小值的两个值的平均值函数" class="headerlink" title="2.求a到b之间最小值的两个值的平均值函数"></a>2.求a到b之间最小值的两个值的平均值函数</h2><p>法一<br>代码如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mininfo &lt;- <span class="keyword">function</span>(x,a,b,minstart=<span class="number">10000</span>,minstart2=<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(j <span class="keyword">in</span> a:b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x[j] &lt; minstart)&#123;</span><br><span class="line">      <span class="keyword">if</span>(minstart!=<span class="number">10000</span>)</span><br><span class="line">        minstart2=minstart</span><br><span class="line">      minstart=x[j]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="built_in">return</span>(mean(<span class="built_in">c</span>(minstart,minstart2)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法二<br>代码如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x&lt;-<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">40</span>)</span><br><span class="line">min2&lt;-<span class="keyword">function</span>(x)</span><br><span class="line">min2&lt;-<span class="keyword">function</span>(x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">return</span>(mean(x[rank(x)&lt;=<span class="number">2</span>])) <span class="comment">#rank(x)代表原序列在排序序列中的位置（从小到大）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; min2(x)</span><br><span class="line">[1] 1.5</span><br></pre></td></tr></table></figure>

<h2 id="3-求一个浮点数组中最大的四个值的和"><a href="#3-求一个浮点数组中最大的四个值的和" class="headerlink" title="3.求一个浮点数组中最大的四个值的和"></a>3.求一个浮点数组中最大的四个值的和</h2><p>代码如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">maxfl &lt;- <span class="keyword">function</span>(x)&#123;</span><br><span class="line">  <span class="built_in">return</span>(<span class="built_in">sum</span>(x[rank(x)&gt;<span class="built_in">length</span>(x)-<span class="number">4</span>]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到输出如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; x&lt;-<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">40</span>)</span><br><span class="line">&gt; maxfl(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">64</span></span><br></pre></td></tr></table></figure>

<h2 id="4-对student表求每门课程成绩前四和"><a href="#4-对student表求每门课程成绩前四和" class="headerlink" title="4.对student表求每门课程成绩前四和"></a>4.对student表求每门课程成绩前四和</h2><p>代码如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">student &lt;- read.table(<span class="string">&quot;C:/Users/74077/Documents/Tencent Files/740775405/FileRecv/student.csv&quot;</span>,head=<span class="literal">TRUE</span>,sep=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">apply(student[,<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)],<span class="number">2</span>,maxfl)</span><br></pre></td></tr></table></figure>

<p>得到输出如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; apply(student[,<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)],<span class="number">2</span>,maxfl)</span><br><span class="line">数学 语文 外语 </span><br><span class="line"> <span class="number">327</span>  <span class="number">342</span>  <span class="number">357</span> </span><br></pre></td></tr></table></figure>

<h2 id="5-从数据库读取ZS-bank数据，计算招商银行前50用户现金流指标中中位数"><a href="#5-从数据库读取ZS-bank数据，计算招商银行前50用户现金流指标中中位数" class="headerlink" title="5.从数据库读取ZS_bank数据，计算招商银行前50用户现金流指标中中位数"></a>5.从数据库读取ZS_bank数据，计算招商银行前50用户现金流指标中中位数</h2><p>代码如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages(<span class="string">&quot;RODBC&quot;</span>)</span><br><span class="line">library(<span class="string">&quot;RODBC&quot;</span>)</span><br><span class="line">con &lt;- odbcConnect(<span class="string">&quot;bank&quot;</span>)</span><br><span class="line">bank &lt;- sqlFetch(con,<span class="string">&quot;Sheet1&quot;</span>)</span><br><span class="line">max_ZS_bank &lt;- <span class="keyword">function</span>(x)&#123;</span><br><span class="line">  <span class="built_in">return</span>(median(x[rank(x)&gt;<span class="built_in">length</span>(x)-<span class="number">50</span>]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max_ZS_bank(bank$SaveIndex)</span><br></pre></td></tr></table></figure>

<p>odbc绑定数据库/Excel文件过程参照<a href="https://blog.csdn.net/buptlihang/article/details/80275641">这里</a>  </p>
<p>bank为xlsx文件中表一：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; bank</span><br><span class="line">   custid   SaveIndex</span><br><span class="line">1       <span class="number">1</span>   <span class="number">78.000000</span></span><br><span class="line">2       <span class="number">2</span>   <span class="number">90.000000</span></span><br><span class="line">3       <span class="number">3</span>   <span class="number">67.000000</span></span><br><span class="line">4       <span class="number">4</span>   <span class="number">67.333333</span></span><br><span class="line">5       <span class="number">5</span>   <span class="number">61.833333</span></span><br><span class="line">6       <span class="number">6</span>   <span class="number">56.333333</span></span><br><span class="line">7       <span class="number">7</span>   <span class="number">50.833333</span></span><br><span class="line">8       <span class="number">8</span>   <span class="number">45.333333</span></span><br><span class="line">9       <span class="number">9</span>   <span class="number">39.833333</span></span><br><span class="line">10     <span class="number">10</span>   <span class="number">34.333333</span></span><br><span class="line">11     <span class="number">11</span>   <span class="number">28.833333</span></span><br><span class="line">12     <span class="number">12</span>   <span class="number">23.333333</span></span><br><span class="line">13     <span class="number">13</span>   <span class="number">17.833333</span></span><br><span class="line">14     <span class="number">14</span>   <span class="number">12.333333</span></span><br><span class="line">15     <span class="number">15</span>    <span class="number">6.833333</span></span><br><span class="line">16     <span class="number">16</span>    <span class="number">1.333333</span></span><br><span class="line">17     <span class="number">17</span>   -<span class="number">4.166667</span></span><br><span class="line">18     <span class="number">18</span>   -<span class="number">9.666667</span></span><br><span class="line">19     <span class="number">19</span>  -<span class="number">15.166667</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<p>得到结果如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; max_ZS_bank(bank$SaveIndex)</span><br><span class="line">[<span class="number">1</span>] -<span class="number">50.91667</span></span><br></pre></td></tr></table></figure>

<h2 id="6-求绝对值大于给定p值的向量的分量的平均值"><a href="#6-求绝对值大于给定p值的向量的分量的平均值" class="headerlink" title="6.求绝对值大于给定p值的向量的分量的平均值"></a>6.求绝对值大于给定p值的向量的分量的平均值</h2><p>代码如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">abs_mean&lt;-<span class="keyword">function</span>(x,p)</span><br><span class="line">&#123;</span><br><span class="line">  x&lt;-na.omit(x) <span class="comment"># 返回补齐缺值的对象</span></span><br><span class="line">  <span class="built_in">return</span>(mean(x[<span class="built_in">abs</span>(x)&gt;p]))</span><br><span class="line">&#125;</span><br><span class="line">x &lt;- <span class="built_in">c</span>(<span class="number">0.4</span>, -<span class="number">0.6</span>, <span class="number">0.9</span>, <span class="number">0.7</span>)</span><br><span class="line">p &lt;- 0.5</span><br><span class="line">abs_mean(x,p)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中<code>x[abs(x)&gt;p]</code>表示选择向量x中绝对值大于p的分量。内在逻辑为选择表达式<code>abs(x)&gt;p</code>返回一个<code>bool</code>类型的向量<code>FALSE  TRUE  TRUE  TRUE</code>，当对应位置的值为<code>FALSE</code>时不取该值，反则取出求平均。<br>得到结果如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; abs_mean(x,p)</span><br><span class="line">[<span class="number">1</span>] <span class="number">0.3333333</span></span><br></pre></td></tr></table></figure>

<h2 id="7-实现DELT函数"><a href="#7-实现DELT函数" class="headerlink" title="7.实现DELT函数"></a>7.实现DELT函数</h2><p>代码如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">stock_open &lt;- <span class="built_in">c</span>(<span class="number">102.25</span>,<span class="number">102.87</span>,<span class="number">102.25</span>,<span class="number">100.87</span>,<span class="number">103.44</span>,<span class="number">103.87</span>,<span class="number">103.00</span>)</span><br><span class="line">stock_close &lt;- <span class="built_in">c</span>(<span class="number">102.12</span>,<span class="number">102.62</span>,<span class="number">100.12</span>,<span class="number">103.00</span>,<span class="number">103.87</span>,<span class="number">103.12</span>,<span class="number">105.12</span>)</span><br><span class="line">stock_open2 &lt;- stock_open[<span class="number">2</span>:<span class="built_in">length</span>(stock_open)]</span><br><span class="line">stock_open2 &lt;- append(stock_open2,<span class="number">0</span>)</span><br><span class="line">delt &lt;- stock_open2 - stock_open</span><br><span class="line">delt</span><br><span class="line">delt &lt;- delt/stock_open</span><br><span class="line">delt</span><br></pre></td></tr></table></figure>

<p>得到结果如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; delt</span><br><span class="line">[<span class="number">1</span>]    <span class="number">0.62</span>   -<span class="number">0.62</span>   -<span class="number">1.38</span>    <span class="number">2.57</span>    <span class="number">0.43</span>   -<span class="number">0.87</span> -<span class="number">103.00</span></span><br><span class="line">&gt; delt &lt;- delt/stock_open</span><br><span class="line">&gt; delt</span><br><span class="line">[<span class="number">1</span>]  <span class="number">0.006063570</span> -<span class="number">0.006027024</span> -<span class="number">0.013496333</span>  <span class="number">0.025478338</span>  <span class="number">0.004156999</span></span><br><span class="line">[<span class="number">6</span>] -<span class="number">0.008375854</span> -<span class="number">1.000000000</span></span><br></pre></td></tr></table></figure>

<h1 id="二、课后学习和一些库的安装"><a href="#二、课后学习和一些库的安装" class="headerlink" title="二、课后学习和一些库的安装"></a>二、课后学习和一些库的安装</h1><h2 id="1-下节课前要求安装的库"><a href="#1-下节课前要求安装的库" class="headerlink" title="1.下节课前要求安装的库"></a>1.下节课前要求安装的库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">install.packages(&quot;DMwR2&quot;)</span><br><span class="line">install.packages(&quot;quantmod&quot;)</span><br><span class="line">install.packages(&quot;xts&quot;)</span><br></pre></td></tr></table></figure>
<p>其中DMwR不适配新版本的R，选用了DMwR2，希望不会有什么不同的.jpg</p>
<h2 id="2-课后学习"><a href="#2-课后学习" class="headerlink" title="2.课后学习"></a>2.课后学习</h2><p>上网冲浪的时候发现了R有一个很有趣的笔记库swirl，虽然是纯英文读起来有点吃力，但是影响不大，在此分享一下。<a href="https://swirlstats.com/students.html">官网在这</a><br>使用起来也很简单，第一步输入<code>install.packages(&quot;swirl&quot;)</code><br>第二步输入</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; library(<span class="string">&quot;swirl&quot;</span>)</span><br><span class="line">&gt; swirl()</span><br></pre></td></tr></table></figure>
<p>接着就可以根据引导语have fun了。  </p>
<p>实际使用时的截图，非常好玩  </p>
<p><img src="/2021/09/19/R2/%E5%9B%BE1.png" alt="引导语"><br>使用交互的方式选择想要学习的内容<br><img src="/2021/09/19/R2/%E5%9B%BE2.png">  </p>
]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言笔记（一）</title>
    <url>/2021/09/05/R1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>R语言笔记——第一节课</p>
<span id="more"></span> 

<h1 id="记录一些函数用法"><a href="#记录一些函数用法" class="headerlink" title="记录一些函数用法"></a>记录一些函数用法</h1><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">x &lt;- <span class="built_in">c</span>(<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">0.9</span>,<span class="number">1.2</span>)</span><br><span class="line"><span class="built_in">length</span>(x)</span><br><span class="line"><span class="built_in">sum</span>(x)</span><br><span class="line">y &lt;- 1:<span class="number">10</span></span><br><span class="line">order(x) <span class="comment">## 排序序列在原序列中的下标</span></span><br><span class="line">x[order(x)]</span><br><span class="line">sort(x)</span><br><span class="line">rank(x) <span class="comment">## 原序列在排序序列中的下标</span></span><br><span class="line"><span class="built_in">cumsum</span>(x) <span class="comment">## 前n项求和</span></span><br><span class="line">mean(x)</span><br><span class="line"><span class="built_in">min</span>(x)</span><br><span class="line"><span class="built_in">max</span>(x)</span><br><span class="line"></span><br><span class="line">m &lt;- matrix(<span class="built_in">c</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>),<span class="number">2</span>,<span class="number">2</span>,byrow = <span class="built_in">T</span>)</span><br><span class="line">apply(m,<span class="number">1</span>,<span class="built_in">sum</span>) <span class="comment">## 对数组m按行1求和</span></span><br><span class="line">apply(m,<span class="number">2</span>,<span class="built_in">min</span>) <span class="comment">## 对数组m按行2求最小值</span></span><br><span class="line"><span class="built_in">dim</span>(m)</span><br><span class="line">rownames(m) &lt;- <span class="built_in">c</span>(<span class="string">&quot;诸葛亮&quot;</span>,<span class="string">&quot;孙悟空&quot;</span>)</span><br><span class="line">colnames(m) &lt;- <span class="built_in">c</span>(<span class="string">&quot;太极拳&quot;</span>,<span class="string">&quot;古琴课&quot;</span>)</span><br><span class="line">m[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">m[-<span class="built_in">c</span>(<span class="number">1</span>),<span class="built_in">c</span>(<span class="string">&quot;古琴课&quot;</span>)]</span><br><span class="line">m[,<span class="built_in">c</span>(<span class="string">&quot;古琴课&quot;</span>)]</span><br><span class="line">m[,]</span><br><span class="line">t(m) <span class="comment">#转置</span></span><br><span class="line">solve(m) <span class="comment">#求逆</span></span><br><span class="line">m%*%solve(m) <span class="comment">#求内积</span></span><br><span class="line">A &lt;- matrix(<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>), <span class="number">3</span>)</span><br><span class="line">b &lt;- <span class="built_in">c</span>(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>)</span><br><span class="line">x &lt;- solve(A,b)</span><br><span class="line"></span><br><span class="line">margin.table(m,<span class="number">1</span>)</span><br><span class="line">margin.table(m,<span class="number">2</span>)</span><br><span class="line">m</span><br><span class="line"></span><br><span class="line"><span class="comment">####数据框###</span></span><br><span class="line"></span><br><span class="line">head(iris) <span class="comment"># 1.系统自带数据集</span></span><br><span class="line"><span class="built_in">class</span>(iris)</span><br><span class="line">table(iris$Species) <span class="comment">#一维列联表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###自己创建数据框###</span></span><br><span class="line"></span><br><span class="line">student &lt;- data.frame(age = numeric(<span class="number">0</span>), gender = character(<span class="number">0</span>))<span class="comment">## 2.自建数据框</span></span><br><span class="line">student &lt;- edit(student) <span class="comment">##键盘输入</span></span><br><span class="line">student</span><br><span class="line"></span><br><span class="line">student &lt;- read.table(<span class="string">&quot;D:\\student.csv&quot;</span>, head = <span class="built_in">T</span>, sep = <span class="string">&quot;,&quot;</span>) <span class="comment">#3.从excel导入</span></span><br><span class="line">student[,<span class="built_in">c</span>(<span class="string">&quot;语文&quot;</span>,<span class="string">&quot;数学&quot;</span>)]</span><br><span class="line">student$语文</span><br><span class="line">score &lt;- student[, <span class="built_in">c</span>(<span class="number">4</span>,<span class="number">5</span>)]</span><br><span class="line">apply(score,<span class="number">1</span> , sd)</span><br><span class="line"><span class="comment"># sql</span></span><br><span class="line">con &lt;- odbcConnect(<span class="string">&quot;47&quot;</span>)</span><br><span class="line">order &lt;- sqlFetch(con, <span class="string">&quot;BT_CRM_Order&quot;</span>)</span><br><span class="line"><span class="built_in">class</span>(order)</span><br><span class="line">sqlQuery(con,<span class="string">&quot;select..&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">data(<span class="string">&quot;mtcars&quot;</span>) <span class="comment"># 加载数据包</span></span><br><span class="line">head(mtcars, <span class="number">10</span>)</span><br><span class="line">mtcars[, <span class="built_in">c</span>(<span class="number">3</span>,<span class="number">5</span>)]</span><br><span class="line">summary(mtcars) <span class="comment"># 统计数据</span></span><br><span class="line">head(iris, <span class="number">10</span>)</span><br><span class="line">summary(iris)</span><br><span class="line">nrow(iris)</span><br><span class="line"><span class="built_in">length</span>(iris)</span><br><span class="line">summary(women)</span><br><span class="line">plot(women)</span><br><span class="line">close(con)</span><br><span class="line"></span><br><span class="line"><span class="comment">###四.因子型数据类型</span></span><br><span class="line"></span><br><span class="line">status &lt;-<span class="built_in">c</span>(<span class="string">&quot;poor&quot;</span>,<span class="string">&quot;improved&quot;</span>,<span class="string">&quot;excellent&quot;</span>,<span class="string">&quot;poor&quot;</span>)</span><br><span class="line"><span class="built_in">class</span>(status)</span><br><span class="line">table(status)</span><br><span class="line">status &lt;- factor(status,ordered = <span class="built_in">T</span>) <span class="comment">#按字母排序</span></span><br><span class="line">barplot(table(status)) <span class="comment">##对字符串向量因子化</span></span><br><span class="line">status &lt;- factor(status, ordered = <span class="built_in">T</span>, levels = <span class="built_in">c</span>(<span class="string">&quot;poor&quot;</span>,<span class="string">&quot;improved&quot;</span>,<span class="string">&quot;excellent&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">##分割</span></span><br><span class="line">x &lt;- 1:<span class="number">10000</span></span><br><span class="line">my_inter &lt;- 4500</span><br><span class="line">x &lt;- factor(x&gt;my_inter, labels = <span class="built_in">LETTERS</span>[<span class="number">1</span>:<span class="number">2</span>])</span><br><span class="line">table(x)</span><br><span class="line">barplot(table(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">#五.列表</span></span><br><span class="line"><span class="comment">#1.函数返回用list打包返回多个值</span></span><br><span class="line"><span class="comment">#2.对非结构数据进行统计</span></span><br><span class="line"></span><br><span class="line">c &lt;- <span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">m &lt;- matrix(<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>),<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">f &lt;- factor(<span class="built_in">c</span>(<span class="string">&quot;poor&quot;</span>,<span class="string">&quot;improved&quot;</span>,<span class="string">&quot;excellent&quot;</span>,<span class="string">&quot;poor&quot;</span>))</span><br><span class="line">listli &lt;- <span class="built_in">list</span>(e1=<span class="built_in">c</span>, e2=m, e3=f)</span><br><span class="line"><span class="built_in">class</span>(listli$e1)</span><br><span class="line">rownames(listli$e2) &lt;- <span class="built_in">c</span>(<span class="string">&quot;row1&quot;</span>,<span class="string">&quot;row2&quot;</span>)</span><br><span class="line"></span><br><span class="line">scores &lt;- <span class="built_in">list</span>(math = <span class="built_in">c</span>(<span class="number">99</span>,<span class="number">33</span>,<span class="number">90</span>),english = <span class="built_in">c</span>(<span class="number">30</span>,<span class="number">70</span>,<span class="number">80</span>,<span class="number">50</span>),chinese = <span class="built_in">c</span>(<span class="number">40</span>,<span class="number">90</span>))</span><br><span class="line">l &lt;- lapply(scores,mean)</span><br><span class="line"><span class="built_in">class</span>(l)</span><br><span class="line">s &lt;- sapply(scores,<span class="built_in">sum</span>)<span class="comment">#sapply是对lapply的简化表达</span></span><br><span class="line"><span class="built_in">class</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串函数</span></span><br><span class="line">nchar(<span class="string">&quot;john&quot;</span>)</span><br><span class="line">s &lt;- <span class="built_in">c</span>(<span class="string">&quot;john&quot;</span>,<span class="string">&quot;marry&quot;</span>,<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">nchar(s)</span><br><span class="line"><span class="built_in">length</span>(s)</span><br><span class="line">paste(<span class="string">&quot;everybody&quot;</span>,<span class="string">&quot;loves&quot;</span>,<span class="string">&quot;country&quot;</span>,sep = <span class="string">&quot;-&quot;</span>)</span><br><span class="line">substr(<span class="string">&quot;china&quot;</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">s &lt;- strsplit(<span class="string">&quot;d:/myglass/betterment&quot;</span>,<span class="string">&quot;/&quot;</span>) <span class="comment">#字符串分割，得到list类型结果</span></span><br><span class="line"><span class="built_in">class</span>(s)</span><br><span class="line"><span class="built_in">class</span>(s[[<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">s1 &lt;- <span class="built_in">c</span>(<span class="string">&quot;南京&quot;</span>,<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;上海&quot;</span>)</span><br><span class="line">s2 &lt;- <span class="built_in">c</span>(<span class="string">&quot;成本&quot;</span>,<span class="string">&quot;收入&quot;</span>)</span><br><span class="line">cross &lt;- outer(s1, s2, paste, sep = <span class="string">&#x27;-&#x27;</span>) <span class="comment">#笛卡尔积</span></span><br><span class="line"><span class="built_in">class</span>(cross)</span><br><span class="line">cross[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日期函数</span></span><br><span class="line">install.packages(<span class="string">&quot;xts&quot;</span>)</span><br><span class="line">library(<span class="string">&quot;xts&quot;</span>)</span><br><span class="line">Sys.Date()</span><br><span class="line">Sys.time()</span><br><span class="line">as.POSTIXlt(Sys.Date())$yday</span><br><span class="line">help(<span class="string">&quot;as.POSIXct.POSIXlt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数</span></span><br><span class="line">sample(<span class="number">1</span>:<span class="number">10</span>)</span><br><span class="line">ind &lt;- sample(<span class="number">1</span>:<span class="number">3</span>,<span class="number">100</span>,replace = <span class="literal">TRUE</span>,prob = <span class="built_in">c</span>(<span class="number">0.3</span>,<span class="number">0.4</span>,<span class="number">0.3</span>))</span><br><span class="line"><span class="built_in">length</span>(ind)</span><br><span class="line">table(ind)</span><br><span class="line">iris[ind==<span class="number">2</span>,] <span class="comment"># 抽样示例</span></span><br><span class="line"></span><br><span class="line">ind &lt;- sample(<span class="number">1</span>:nrow(iris),<span class="number">70</span>,replace = <span class="built_in">T</span>)</span><br><span class="line">iris[ind,] <span class="comment"># 抽样示例</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android实验课作业一 Kotlin简单应用</title>
    <url>/2021/09/07/kotlin1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&ensp;&ensp;&ensp;&ensp;使用Kotlin完成简单的编程问题 </p>
<span id="more"></span>

<h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><p>1、练习Kotlin的基本语法，为安卓开发做准备<br>2、使用Kotlin语言编程求解y对x的线性回归方程  </p>
<h1 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h1><p>Android Studio、Kotlin  </p>
<h1 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h1><p>假设10名同学高一（x）和高二（y）的数学成绩为：<br>高一（x）：74 71 72 68 76 73 67 70 65 74<br>高二（y）：76 75 71 70 76 79 65 77 65 72<br>练习使用Kotlin语言编程求解y对x的线性回归方程<br>回归公式如下：<br><img src="/2021/09/07/kotlin1/1.png">  </p>
<h1 id="四、主要实验步骤"><a href="#四、主要实验步骤" class="headerlink" title="四、主要实验步骤"></a>四、主要实验步骤</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fun main() &#123;</span><br><span class="line">    val score1 &#x3D; arrayOf(74, 71, 72, 68, 76, 73, 67, 70, 65, 74)</span><br><span class="line">    val score2 &#x3D; arrayOf(76, 75, 71, 70, 76, 79, 65, 77, 65, 72)</span><br><span class="line">    val x_mean &#x3D; mean(score1)</span><br><span class="line">    val y_mean &#x3D; mean(score2)</span><br><span class="line">    var mol &#x3D; 0.0</span><br><span class="line">    var deno &#x3D; 0.0</span><br><span class="line">    for (i in 0 until 10) &#123;</span><br><span class="line">        var temp1 &#x3D; score1[i] - x_mean</span><br><span class="line">        var temp2 &#x3D; score2[i] - y_mean</span><br><span class="line">        mol +&#x3D; temp1 * temp2</span><br><span class="line">        deno +&#x3D; temp1 * temp1</span><br><span class="line">    &#125;</span><br><span class="line">    val b &#x3D; mol &#x2F; deno</span><br><span class="line">    val a &#x3D; y_mean - b * x_mean</span><br><span class="line">    val ans &#x3D; &quot;y &#x3D; $b x $a&quot;</span><br><span class="line">    println(ans)</span><br><span class="line">    println(&quot;hello world&quot;)</span><br><span class="line">&#125;</span><br><span class="line">fun mean(args: Array&lt;Int&gt;): Double &#123;</span><br><span class="line">    var temp &#x3D; 0.0</span><br><span class="line">    for (i in 0 until args.size) &#123;</span><br><span class="line">        temp +&#x3D; args[i]</span><br><span class="line">    &#125;</span><br><span class="line">    return temp &#x2F; args.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>实验课作业</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言笔记（三）</title>
    <url>/2021/09/28/R3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据合并、数据聚集和作图</p>
<span id="more"></span> 

<h1 id="一、数据操作"><a href="#一、数据操作" class="headerlink" title="一、数据操作"></a>一、数据操作</h1><h2 id="1-数据合并"><a href="#1-数据合并" class="headerlink" title="1.数据合并"></a>1.数据合并</h2><p>数据合并用到merge操作，可以实现对两个数据表进行匹配和拼接的功能，merge连接两个数据，官方参考文档语法：  </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">merge(x, y, by = intersect(<span class="built_in">names</span>(x), <span class="built_in">names</span>(y)),</span><br><span class="line">      by.x = by, by.y = by, <span class="built_in">all</span> = <span class="literal">FALSE</span>, all.x = <span class="built_in">all</span>, all.y = <span class="built_in">all</span>,</span><br><span class="line">      sort = <span class="literal">TRUE</span>, suffixes = <span class="built_in">c</span>(<span class="string">&quot;.x&quot;</span>,<span class="string">&quot;.y&quot;</span>),</span><br><span class="line">      incomparables = <span class="literal">NULL</span>, ...)</span><br></pre></td></tr></table></figure>

<p>merge函数各个参数的说明如下：  </p>
<ul>
<li>x,y：要合并的两个数据集  </li>
<li>by：用于连接两个数据集的列intersect(a,b)值向量a,b的交集，names(x)指提取数据集x的列名  </li>
<li>by.x,by.y:指定依据哪些合并数据框，默认值为相同列名的列  </li>
<li>all,all.x,all.y:指定x和y的行是否应该全在输出文件  </li>
<li>sort:by指定的列（即公共列）是否要排序  </li>
<li>suffixes:指定除by外相同列名的后缀  </li>
<li>incomparables:指定by中哪些单元不进行合并</li>
</ul>
<p><strong>举例说明如下</strong></p>
<p>①首先读入数据，得到student2和student作为实验集</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">student &lt;- read.table(<span class="string">&quot;C:/Users/74077/Documents/Tencent Files/740775405/FileRecv/student.csv&quot;</span>,head=<span class="literal">TRUE</span>,sep=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">apply(student[,<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)],<span class="number">2</span>,maxfl)</span><br><span class="line">student2 &lt;- student[<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)]</span><br><span class="line">student2</span><br></pre></td></tr></table></figure>
<p><code>student</code>输出如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">     姓名 数学 语文 外语 性别 系别</span><br><span class="line">1 诸 葛亮   <span class="number">34</span>   <span class="number">35</span>   <span class="number">59</span>   男 三国</span><br><span class="line">2   张 飞   <span class="number">69</span>   <span class="number">90</span>   <span class="number">24</span>   男 水浒</span><br><span class="line">3 孙 悟空   <span class="number">56</span>   <span class="number">78</span>   <span class="number">88</span>   男 西游</span><br><span class="line">4   孙 权   <span class="number">78</span>   <span class="number">78</span>   <span class="number">69</span>   男 三国</span><br><span class="line">5   刘 备   <span class="number">67</span>   <span class="number">80</span>   <span class="number">90</span>   男 三国</span><br><span class="line">6 白 骨精   <span class="number">56</span>   <span class="number">56</span>   <span class="number">89</span>   女 西游</span><br><span class="line">7   宋 江   <span class="number">90</span>   <span class="number">67</span>   <span class="number">90</span>   男 水浒</span><br><span class="line">8 贾 宝玉   <span class="number">67</span>   <span class="number">84</span>   <span class="number">77</span>   男 红楼</span><br><span class="line">9 林 黛玉   <span class="number">90</span>   <span class="number">88</span>   <span class="number">26</span>   女 红楼</span><br></pre></td></tr></table></figure>

<p><code>student2</code>输出如下:</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">     姓名 数学 语文 外语</span><br><span class="line">1 诸 葛亮   <span class="number">34</span>   <span class="number">35</span>   <span class="number">59</span></span><br><span class="line">2   张 飞   <span class="number">69</span>   <span class="number">90</span>   <span class="number">24</span></span><br><span class="line">3 孙 悟空   <span class="number">56</span>   <span class="number">78</span>   <span class="number">88</span></span><br></pre></td></tr></table></figure>

<p>按相同列姓名合并两个数据集</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; merge(student,student2,by=<span class="built_in">c</span>(<span class="string">&quot;姓名&quot;</span>))</span><br><span class="line">     姓名 数学.x 语文.x 外语.x 性别 系别 数学.y 语文.y 外语.y</span><br><span class="line">1 孙 悟空     <span class="number">56</span>     <span class="number">78</span>     <span class="number">88</span>   男 西游     <span class="number">56</span>     <span class="number">78</span>     <span class="number">88</span></span><br><span class="line">2   张 飞     <span class="number">69</span>     <span class="number">90</span>     <span class="number">24</span>   男 水浒     <span class="number">69</span>     <span class="number">90</span>     <span class="number">24</span></span><br><span class="line">3 诸 葛亮     <span class="number">34</span>     <span class="number">35</span>     <span class="number">59</span>   男 三国     <span class="number">34</span>     <span class="number">35</span>     <span class="number">59</span></span><br></pre></td></tr></table></figure>

<p>使用bt可以去除重复列</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">&gt; merge(student,student2,bt=<span class="built_in">c</span>(<span class="string">&quot;姓名&quot;</span>))</span><br><span class="line">     姓名 数学 语文 外语 性别 系别</span><br><span class="line">1 孙 悟空   <span class="number">56</span>   <span class="number">78</span>   <span class="number">88</span>   男 西游</span><br><span class="line">2   张 飞   <span class="number">69</span>   <span class="number">90</span>   <span class="number">24</span>   男 水浒</span><br><span class="line">3 诸 葛亮   <span class="number">34</span>   <span class="number">35</span>   <span class="number">59</span>   男 三国</span><br></pre></td></tr></table></figure>
<h2 id="2-选取字段"><a href="#2-选取字段" class="headerlink" title="2.选取字段"></a>2.选取字段</h2><p>选取字段有三种方法</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.直接引用</span></span><br><span class="line">student[which(student$数学&gt;<span class="number">40</span>),<span class="built_in">c</span>(<span class="string">&quot;姓名&quot;</span>,<span class="string">&quot;数学&quot;</span>)] </span><br><span class="line"></span><br><span class="line"><span class="comment">#2.通过subset函数引用</span></span><br><span class="line">subset(student, select=<span class="built_in">c</span>(<span class="string">&quot;姓名&quot;</span>,<span class="string">&quot;数学&quot;</span>),数学&gt;<span class="number">40</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#3.通过sql语句，需先引入library(sqldf)</span></span><br><span class="line">install.packages(<span class="string">&quot;sqldf&quot;</span>)</span><br><span class="line">library(<span class="string">&quot;sqldf&quot;</span>)</span><br><span class="line">sqldf(<span class="string">&quot;select 姓名,数学 from student where 数学&gt;40&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>得到输出均如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">    姓名 数学</span><br><span class="line">2   张 飞   <span class="number">69</span></span><br><span class="line">3 孙 悟空   <span class="number">56</span></span><br><span class="line">4   孙 权   <span class="number">78</span></span><br><span class="line">5   刘 备   <span class="number">67</span></span><br><span class="line">6 白 骨精   <span class="number">56</span></span><br><span class="line">7   宋 江   <span class="number">90</span></span><br><span class="line">8 贾 宝玉   <span class="number">67</span></span><br><span class="line">9 林 黛玉   <span class="number">90</span></span><br></pre></td></tr></table></figure>
<h2 id="3-数据聚集"><a href="#3-数据聚集" class="headerlink" title="3.数据聚集"></a>3.数据聚集</h2><p>aggregate函数可以按照要求把数据打组聚合，然后对聚合以后的数据进行加和、求平均等各种操作。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">aggregate(student[,<span class="built_in">c</span>(<span class="string">&quot;数学&quot;</span>,<span class="string">&quot;外语&quot;</span>)],by=<span class="built_in">list</span>(系别=student$系别,性别=student$性别),FUN=mean,na.rm=<span class="built_in">T</span>)</span><br><span class="line">sqldf(<span class="string">&quot;select 系别,avg(数学),avg(外语) from student group by 系别, 性别&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>得到输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  系别 性别     数学     外语</span><br><span class="line">1 红楼   男 67.00000 77.00000</span><br><span class="line">2 三国   男 59.66667 72.66667</span><br><span class="line">3 水浒   男 79.50000 57.00000</span><br><span class="line">4 西游   男 56.00000 88.00000</span><br><span class="line">5 红楼   女 90.00000 26.00000</span><br><span class="line">6 西游   女 56.00000 89.00000</span><br></pre></td></tr></table></figure>

<h1 id="二、课堂练习"><a href="#二、课堂练习" class="headerlink" title="二、课堂练习"></a>二、课堂练习</h1><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.对于iris数据集，抽样50行，和原数据集合并（行号）</span></span><br><span class="line">ind &lt;- sample(<span class="number">1</span>:<span class="built_in">length</span>(iris[,<span class="number">1</span>]),<span class="number">50</span>,replace = <span class="literal">TRUE</span>)</span><br><span class="line"><span class="built_in">length</span>(ind)</span><br><span class="line">table(ind)</span><br><span class="line">iris2 &lt;- iris[ind,]</span><br><span class="line">merge(iris,iris2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查询花蕾长度大于2的鸢尾花的类别号</span></span><br><span class="line">subset(iris, select=<span class="built_in">c</span>(<span class="string">&quot;Species&quot;</span>),Sepal.Length&gt;<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.用aggregate函数，查询每类鸢尾花的中心（四个长度的平均值）!</span></span><br><span class="line">aggregate(iris[,<span class="built_in">c</span>(<span class="string">&quot;Sepal.Width&quot;</span>,<span class="string">&quot;Sepal.Length&quot;</span>,<span class="string">&quot;Petal.Length&quot;</span>,<span class="string">&quot;Petal.Width&quot;</span>)],by=<span class="built_in">list</span>(Species=iris$Species),FUN=mean,na.rm=<span class="built_in">T</span>)</span><br></pre></td></tr></table></figure>

<h1 id="三、画图常用函数和设置"><a href="#三、画图常用函数和设置" class="headerlink" title="三、画图常用函数和设置"></a>三、画图常用函数和设置</h1><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">##################设置</span></span><br><span class="line">demo(graphics)</span><br><span class="line"><span class="comment">###设置点和线的类型</span></span><br><span class="line">oldpar &lt;- par(mfrow = <span class="built_in">c</span>(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">hist(iris$Sepal.Width)</span><br><span class="line"><span class="comment">#不同的点</span></span><br><span class="line">plot(<span class="number">0</span>, <span class="number">0</span>, xlim = <span class="built_in">c</span>(<span class="number">6</span>, <span class="number">6</span>), ylim = <span class="built_in">c</span>(<span class="number">6</span>, <span class="number">6</span>))</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">5</span>) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1</span>:<span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">  points(i + <span class="number">3</span>, j + <span class="number">3</span>, pch = (i - <span class="number">1</span>) * <span class="number">5</span> + j, bg = (i - <span class="number">1</span>) * <span class="number">5</span> + j, cex = <span class="number">3</span>)</span><br><span class="line">  text(i + <span class="number">3</span>, j + <span class="number">2.8</span>, (i - <span class="number">1</span>) * <span class="number">5</span> + j)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#不同的线</span></span><br><span class="line">plot(<span class="number">4</span>, <span class="number">4</span>, type = <span class="string">&quot;n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">6</span>) &#123;</span><br><span class="line">  segments(x0 = <span class="number">2.5</span>, y0 = <span class="number">2</span> + i * <span class="number">0.5</span>,</span><br><span class="line">           x1 = <span class="number">5</span>, y1 = <span class="number">2</span> + i * <span class="number">0.5</span>,</span><br><span class="line">           lty = i,lwd=<span class="number">3</span>)</span><br><span class="line">  text(<span class="number">5.5</span>, <span class="number">2</span> + i * <span class="number">0.5</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">##如何 保存设置</span></span><br><span class="line">barplot(table(iris$Species),col=<span class="string">&quot;blue&quot;</span>)</span><br><span class="line">par(col=<span class="string">&quot;green&quot;</span>)</span><br><span class="line">help(par)</span><br><span class="line">barplot(table(iris$Species),col=<span class="string">&quot;green&quot;</span>)</span><br><span class="line">x&lt;-<span class="number">1</span>:<span class="number">10</span></span><br><span class="line">y&lt;-<span class="number">2</span>*x+<span class="number">5</span></span><br><span class="line">plot(x,y,type=<span class="string">&quot;o&quot;</span>,lty=<span class="number">5</span>,lwd=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">opar&lt;-par()</span><br><span class="line">par(col=<span class="string">&quot;blue&quot;</span>)</span><br><span class="line">par(cex.main=<span class="number">1</span>) </span><br><span class="line">par(col.main=<span class="number">4</span>)</span><br><span class="line">par(fon.main=<span class="number">1</span>)</span><br><span class="line">par(cex.axis=<span class="number">0.5</span>)</span><br><span class="line">par(cex.lab=<span class="number">1</span>)</span><br><span class="line">par(opar)</span><br><span class="line"></span><br><span class="line">x&lt;-rnorm(<span class="number">300</span>,<span class="number">0</span>,<span class="number">0.5</span>)</span><br><span class="line">y&lt;-rnorm(<span class="number">300</span>,<span class="number">0</span>,<span class="number">0.5</span>)</span><br><span class="line">plot(x,y)</span><br><span class="line">plot(x,y,col=<span class="string">&quot;red&quot;</span>,fg=<span class="string">&quot;green&quot;</span>,pch=<span class="number">2</span>,lty=<span class="string">&quot;dotted&quot;</span>,lwd=<span class="number">3</span>,main=<span class="string">&quot;正态分布&quot;</span>,sub =<span class="string">&quot;hhhh&quot;</span>,xlab=<span class="string">&quot;X轴&quot;</span>,ylab=<span class="string">&quot;Y&quot;</span>)</span><br><span class="line"><span class="comment">##颜色参数</span></span><br><span class="line">col 默认的绘图颜色</span><br><span class="line">col.axis 坐标轴刻度的颜色，默认为black</span><br><span class="line">col.lab 坐标轴标签的颜色，默认为black</span><br><span class="line">col.main 主标题的颜色，默认为black</span><br><span class="line">col.sub 副标题的颜色，默认为black</span><br><span class="line">fg 前景色</span><br><span class="line">bg 背景色</span><br><span class="line"></span><br><span class="line">rainbow(<span class="number">20</span>)</span><br><span class="line">colors()</span><br><span class="line">heat.colors(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##用药与症状的关系</span></span><br><span class="line">dose&lt;-<span class="built_in">c</span>(<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">45</span>,<span class="number">60</span>)</span><br><span class="line">drugA&lt;-<span class="built_in">c</span>(<span class="number">16</span>,<span class="number">202</span>,<span class="number">7</span>,<span class="number">40</span>,<span class="number">60</span>)</span><br><span class="line">drugB&lt;-<span class="built_in">c</span>(<span class="number">15</span>,<span class="number">18</span>,<span class="number">25</span>,<span class="number">31</span>,<span class="number">40</span>)</span><br><span class="line">par(no.only=<span class="built_in">T</span>)</span><br><span class="line">par(lwd=<span class="number">2</span>,cex=<span class="number">0.5</span>,font.lab=<span class="number">2</span>)</span><br><span class="line">plot(dose,drugA,type=<span class="string">&quot;o&quot;</span>,pch=<span class="number">15</span>,lty=<span class="string">&quot;dotted&quot;</span>,col=<span class="string">&quot;green&quot;</span>,main=<span class="string">&quot;DrugA vs DrugB&quot;</span>,xlab=<span class="string">&quot;Dose&quot;</span>,ylab=<span class="string">&quot;Drug Response&quot;</span>) </span><br><span class="line"><span class="comment">##绘制drugA曲线</span></span><br><span class="line"></span><br><span class="line">set.seed(<span class="number">2015</span>)</span><br><span class="line">xx &lt;- rnorm(<span class="number">100</span>)</span><br><span class="line">plot(xx)  <span class="comment"># ①</span></span><br><span class="line"><span class="comment"># 保存原有的设置</span></span><br><span class="line">opar &lt;- par(no.readonly=<span class="literal">TRUE</span>) </span><br><span class="line"><span class="comment"># 增加新的作图设置</span></span><br><span class="line">par(lty=<span class="number">2</span>, pch=<span class="number">17</span>)           </span><br><span class="line">plot(xx) <span class="comment"># ②</span></span><br><span class="line"><span class="comment"># 复原设置 </span></span><br><span class="line">par(opar)  </span><br><span class="line">plot(xx)  <span class="comment"># ③</span></span><br><span class="line"><span class="comment"># ①与③的图是一样的 set.seed(2015)</span></span><br><span class="line">xx &lt;- rnorm(<span class="number">100</span>)</span><br><span class="line">plot(xx)  <span class="comment"># ①</span></span><br><span class="line"><span class="comment"># 保存原有的设置</span></span><br><span class="line">opar &lt;- par(no.readonly=<span class="literal">TRUE</span>) </span><br><span class="line"><span class="comment"># 增加新的作图设置</span></span><br><span class="line">par(lty=<span class="number">2</span>, pch=<span class="number">17</span>)           </span><br><span class="line">plot(xx) <span class="comment"># ②</span></span><br><span class="line"><span class="comment"># 复原设置 </span></span><br><span class="line">par(opar)  </span><br><span class="line">plot(xx)  <span class="comment"># ③</span></span><br><span class="line"><span class="comment"># ①与③的图是一样的 </span></span><br><span class="line"><span class="comment">####图例</span></span><br><span class="line">data(iris)</span><br><span class="line">ind &lt;- <span class="built_in">as.numeric</span>(iris$Species)</span><br><span class="line">plot(iris$Petal.Width,iris$Sepal.Width,</span><br><span class="line">     pch=ind,col=ind,</span><br><span class="line">     main=<span class="string">&quot;Width VS Length&quot;</span>,</span><br><span class="line">     xlab=<span class="string">&quot;Length&quot;</span>,ylab=<span class="string">&quot;Width&quot;</span>)</span><br><span class="line">grid()</span><br><span class="line">legend(<span class="string">&quot;topright&quot;</span>,title=<span class="string">&quot;Iris Species&quot;</span>, legend=levels(iris$Species),pch=<span class="number">1</span>:<span class="number">3</span>,col=<span class="number">1</span>:<span class="number">3</span>,inset=<span class="number">0.05</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#####################布局控制 mfrow,layout</span></span><br><span class="line">attach(mtcars) </span><br><span class="line">nrow(mtcars)</span><br><span class="line">par(mfrow=<span class="built_in">c</span>(<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">hist(mtcars$mpg) </span><br><span class="line">hist(wt)  </span><br><span class="line">hist(disp)</span><br><span class="line">hist(wt)</span><br><span class="line"></span><br><span class="line">layout(matrix(<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>),nrow=<span class="number">2</span>),</span><br><span class="line">       width=<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>),height=<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">1</span>)) </span><br><span class="line">hist(mpg) </span><br><span class="line">hist(wt)  </span><br><span class="line">hist(disp) </span><br><span class="line">hist(wt)</span><br><span class="line">detach(mtcars)</span><br><span class="line"></span><br><span class="line">layout(mat=matrix(data=<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>),nrow=<span class="number">2</span>))</span><br><span class="line">plot(iris$Sepal.Length~iris$Sepal.Width,</span><br><span class="line">     main=<span class="string">&quot;Iris&#x27;s Sepal Length VS Width&quot;</span>,</span><br><span class="line">     xlab=<span class="string">&quot;Width&quot;</span>,ylab=<span class="string">&quot;Length&quot;</span>)</span><br><span class="line">boxplot(iris$Sepal.Length~iris$Species)</span><br><span class="line">hist(x=iris$Sepal.Length)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言笔记（四）</title>
    <url>/2021/10/21/R4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记一下近期的一些函数</p>
<span id="more"></span> 

<h1 id="fishermodel"><a href="#fishermodel" class="headerlink" title="fishermodel"></a>fishermodel</h1><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fisher&lt;-<span class="keyword">function</span>(data,n,form)&#123;</span><br><span class="line">  accu&lt;-<span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span>(i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">1000</span>)&#123;</span><br><span class="line">    ind&lt;-sample(<span class="number">1</span>:nrow(data),<span class="built_in">round</span>(<span class="number">0.7</span>*nrow(data)),replace = <span class="literal">FALSE</span>)</span><br><span class="line">    require(<span class="string">&quot;MASS&quot;</span>)</span><br><span class="line">    fisher.mode&lt;-lda(form,data=data[ind,])</span><br><span class="line">    pre &lt;- predict(fisher.mode,data[-ind,])</span><br><span class="line">    t &lt;- table(data[-ind,n],pre$<span class="built_in">class</span>)</span><br><span class="line">    accu[i] &lt;- <span class="built_in">sum</span>(diag(t)/<span class="built_in">sum</span>(t))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span>(<span class="built_in">c</span>(mean(accu),sd(accu)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="rpart"><a href="#rpart" class="headerlink" title="rpart"></a>rpart</h1><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library(rpart)</span><br><span class="line">dt&lt;-<span class="keyword">function</span>(data,n,form)&#123;</span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">1000</span>)&#123;</span><br><span class="line">    ind &lt;- sample(<span class="number">1</span>:nrow(data),<span class="built_in">round</span>(<span class="number">0.7</span>*nrow(data)),replace = <span class="literal">FALSE</span>)</span><br><span class="line">    treemodel &lt;- rpart(form,data[ind,],method = <span class="string">&quot;class&quot;</span>)</span><br><span class="line">    treepre &lt;- predict(treemodel,data[-ind,-n],type=<span class="string">&quot;class&quot;</span>)</span><br><span class="line">    t &lt;- table(data[-ind,n],treepre)</span><br><span class="line">    accu[i] &lt;- <span class="built_in">sum</span>(diag(t))/<span class="built_in">sum</span>(t)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span>(<span class="built_in">c</span>(mean(accu),sd(accu)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#剪枝</span></span><br><span class="line">z.auto&lt;-rpart(Mileage ~ Weight, car.test.frame)</span><br><span class="line">zp&lt;-prune(z.auto,cp=<span class="number">0.1</span>)</span><br><span class="line">install.packages(<span class="string">&quot;rpart.plot&quot;</span>)</span><br><span class="line">library(rpart)</span><br><span class="line">library(rpart.plot)</span><br><span class="line"></span><br><span class="line">par(mfrow=<span class="built_in">c</span>(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">rpart.plot(z.auto)</span><br><span class="line">rpart.plot(zp)</span><br></pre></td></tr></table></figure>

<h1 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h1><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages(<span class="string">&quot;kernlab&quot;</span>)</span><br><span class="line">library(<span class="string">&quot;kernlab&quot;</span>)</span><br><span class="line">svm &lt;- <span class="keyword">function</span>(data,n,fomu)&#123;</span><br><span class="line">  require(kernlab)</span><br><span class="line">  accu &lt;- 0</span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:<span class="number">1000</span>)&#123;</span><br><span class="line">    ind &lt;- sample(<span class="number">1</span>:nrow(data),<span class="number">100</span>,replace = <span class="literal">FALSE</span>)</span><br><span class="line">    svmmodel &lt;- ksvm(fomu,data[ind,],C=<span class="number">10</span>,type=<span class="string">&quot;C-svc&quot;</span>)</span><br><span class="line">    svmpre &lt;- predict(svmmodel,data[-ind,-n])</span><br><span class="line">    t &lt;- table(data[-ind,n],svmpre)</span><br><span class="line">    accu[i] &lt;- <span class="built_in">sum</span>(diag(t))/<span class="built_in">sum</span>(t)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> (<span class="built_in">c</span>(mean(accu),sd(accu)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>R</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Android实验课作业三 数据库实践</title>
    <url>/2021/10/20/android3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>安卓SQLite实践</p>
<span id="more"></span> 

<h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><p>使用事务完成以下目标：<br>1）在数据库中新建一个数据表（表名任意）<br>2）添加你和你三位同学的学号、姓名、高数成绩、英语成绩和体育成绩<br>3）升级新的数据库版本，将数据表中你的三位同学的所有成绩全部更新为0  </p>
<h1 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h1><p>Android Studio、Kotlin、sqllite  </p>
<h1 id="三、主要实验步骤"><a href="#三、主要实验步骤" class="headerlink" title="三、主要实验步骤"></a>三、主要实验步骤</h1><p>1）打开打开Android Studio，新建工程Homework，如图所示：    </p>
<img src="/2021/10/20/android3/%E5%9B%BE%E7%89%871.png" class>   

<p>2）这里创建一个名为Student.db的数据库，然后在这个数据库中新建一张Book表，表中有id（主键）、姓名、高数成绩、英语成绩、体育成绩等列，Grade表的建表语句如下所示：  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Grade （</span><br><span class="line">            id <span class="type">integer</span> <span class="keyword">primary</span> key autoincrement,</span><br><span class="line">            name text,</span><br><span class="line">            hmath <span class="type">integer</span>,</span><br><span class="line">            english <span class="type">integer</span>,</span><br><span class="line">            sport <span class="type">integer</span>)</span><br></pre></td></tr></table></figure>
<p>然后需要在代码中执行这条SQL语句，才能完成创建表的操作，新建MyDatabaseHelper类继承自SQLiteOpenHelper，如下图所示：  </p>
<img src="/2021/10/20/android3/%E5%9B%BE%E7%89%872.png" class>   

<p>3）接着绘制控件Button：createDatabase，点击后用于执行创建数据库的功能，先修改布局文件activity_main.xml中的代码，如下图所示：  </p>
<img src="/2021/10/20/android3/%E5%9B%BE%E7%89%873.png" class>   

<p>最后修改MainActivity中的代码，如下图所示：  </p>
<img src="/2021/10/20/android3/%E5%9B%BE%E7%89%874.png" class>   

<p>4）尝试运行一下代码，在程序主界面点击Create Database按钮，如下图所示：  </p>
<img src="/2021/10/20/android3/%E5%9B%BE%E7%89%875.png" class>   

<p>可以使用Device File Explorer证实数据库确实创建成功了，在其中找到该db文件，如下图所示：  </p>
<img src="/2021/10/20/android3/%E5%9B%BE%E7%89%876.png" class>   

<p>可以看到Student.db顺利创建了，接着可以将该文件导出到本地，使用Database Navigator插件查看，如下图所示：  </p>
<img src="/2021/10/20/android3/%E5%9B%BE%E7%89%877.png" class>   

<p>用Database Navigator插件看到Grade表成功创建。如下图所示，表中的各列也创建成功。  </p>
<img src="/2021/10/20/android3/%E5%9B%BE%E7%89%878.png" class>   

<p>5）接着使用事务功能将所有数据全部添加进Grade表中。首先绘制控件Button：addData，修改布局文件activity_main.xml中的代码，如下图所示：  </p>
<img src="/2021/10/20/android3/%E5%9B%BE%E7%89%879.png" class>   

<p>为了能够将数据一次性全部插入进去，防止数据的丢失和错误，这里使用务的方法来插入，如下图所示：  </p>
<img src="/2021/10/20/android3/%E5%9B%BE%E7%89%8710.png" class>   

<p>首先调用SQLiteDatabase的beginTransaction()方法开启一个事务，然后在一个异常捕获的代码块中执行具体的数据库操作：先获取了SQLiteDatabase对象，然后使用ContentValues对要添加的数据进行组装。接下来调用了insert()方法将数据添加到表当中。<br>当所有操作都完成后，调用setTransactionSuccessful()表示事务执行成功，最后在finally代码块中调用endTransaction()结束事务。<br>6）为了方便查看数据库表中数据的修改，我们可以先编写一个查询按键，这样就不用每次都将文件导入到本地并通过插件查看了。<br>首先绘制查询数据的控件Button：queryData，如下图所示：  </p>
<img src="/2021/10/20/android3/%E5%9B%BE%E7%89%8711.png" class>   

<p>然后修改MainActivity中的代码，添加如下图所示的代码：  </p>
<img src="/2021/10/20/android3/%E5%9B%BE%E7%89%8712.png" class>   

<p>首先在查询按钮的点击事件里面调用SQLiteDatabase的query()方法查询数据。查询这张表中的所有数据，查询完之后就得到了一个Cursor对象。<br>接着调用moveToFirst()方法，将数据的指针移动到第一行的位置，进入一个循环当中，去遍历查询到的每一行数据。在这个循环中可以通过Cursor的getColumnIndex()方法获取某一列在表中对应的位置索引，然后将这个索引传入相应的取值方法中，就可以得到从数据库中读取到的数据。<br>接着使用Log将取出的数据打印出来，借此检查读取工作有没有成功完成。<br>最后调用close()方法关闭Cursor。  </p>
<p>7）接着重新运行程序，如下图所示：  </p>
<img src="/2021/10/20/android3/%E5%9B%BE%E7%89%8713.png" class>   

<p>可以看到多了ADD DATA 和 QUERY DATA 的按钮，点击ADD DATA，向表中添加提前准备好的数据，点击QUERY DATA按钮即可查询添加的数据，如下图所示：  </p>
<img src="/2021/10/20/android3/%E5%9B%BE%E7%89%8714.png" class>   

<p>可以看到数据都正常插入了，用插件查看该表，如下图所示：  </p>
<img src="/2021/10/20/android3/%E5%9B%BE%E7%89%8715.png" class>  
<p>可以看到数据确实正常插入了。<br>8）至此目标1，2都已经实现，接下来只需要升级新的数据库版本，将数据表中所有成绩全部更新为0。<br>将MainActivity中DatabaseHelper中的version参数改为2，重写onUpgrade函数，使数据库更新时，将每一个记录中的三个成绩的值都更新为0，如下图所示：  </p>
<img src="/2021/10/20/android3/%E5%9B%BE%E7%89%8716.png" class>   

<p>点击运行按钮重新运行该代码，实现数据库的更新，再次使用QUERY DATA函数查询表中的数据，得到结果如下：  </p>
<img src="/2021/10/20/android3/%E5%9B%BE%E7%89%8717.png" class>   

<p>使用插件直接查看该表，如下图所示：  </p>
<img src="/2021/10/20/android3/%E5%9B%BE%E7%89%8718.png" class>   

<p>可以看到数据库更新后，所有结果成功归零。  </p>
<h1 id="代码附录"><a href="#代码附录" class="headerlink" title="代码附录"></a>代码附录</h1><h2 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.homework</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ContentValues</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> android.widget.Button</span><br><span class="line"><span class="keyword">import</span> java.lang.Exception</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        <span class="keyword">val</span> dbHelper = MyDatabaseHelper(<span class="keyword">this</span>, <span class="string">&quot;Student.db&quot;</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">val</span> createDatabase: Button = findViewById(R.id.createDatabase)</span><br><span class="line">        createDatabase.setOnClickListener &#123;</span><br><span class="line">            dbHelper.writableDatabase</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> addData:Button = findViewById(R.id.addData)</span><br><span class="line">        addData.setOnClickListener&#123;</span><br><span class="line">            <span class="keyword">val</span> db = dbHelper.writableDatabase</span><br><span class="line">            db.beginTransaction()</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> values1 = ContentValues().apply &#123;</span><br><span class="line">                    put(<span class="string">&quot;id&quot;</span>, <span class="number">2120191738</span>)</span><br><span class="line">                    put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;夏天豪&quot;</span>)</span><br><span class="line">                    put(<span class="string">&quot;hmath&quot;</span>, <span class="number">98</span>)</span><br><span class="line">                    put(<span class="string">&quot;english&quot;</span>, <span class="number">91</span>)</span><br><span class="line">                    put(<span class="string">&quot;sport&quot;</span>, <span class="number">93</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                db.insert(<span class="string">&quot;Grade&quot;</span>, <span class="literal">null</span>, values1)</span><br><span class="line">                <span class="keyword">val</span> values2 = ContentValues().apply &#123;</span><br><span class="line">                    put(<span class="string">&quot;id&quot;</span>, <span class="number">2120192810</span>)</span><br><span class="line">                    put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;王麒淳&quot;</span>)</span><br><span class="line">                    put(<span class="string">&quot;hmath&quot;</span>, <span class="number">77</span>)</span><br><span class="line">                    put(<span class="string">&quot;english&quot;</span>, <span class="number">67</span>)</span><br><span class="line">                    put(<span class="string">&quot;sport&quot;</span>, <span class="number">95</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                db.insert(<span class="string">&quot;Grade&quot;</span>, <span class="literal">null</span>, values2)</span><br><span class="line">                <span class="keyword">val</span> values3 = ContentValues().apply &#123;</span><br><span class="line">                    put(<span class="string">&quot;id&quot;</span>, <span class="number">2120191912</span>)</span><br><span class="line">                    put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;耿宇豪&quot;</span>)</span><br><span class="line">                    put(<span class="string">&quot;hmath&quot;</span>, <span class="number">89</span>)</span><br><span class="line">                    put(<span class="string">&quot;english&quot;</span>, <span class="number">85</span>)</span><br><span class="line">                    put(<span class="string">&quot;sport&quot;</span>, <span class="number">90</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                db.insert(<span class="string">&quot;Grade&quot;</span>, <span class="literal">null</span>, values3)</span><br><span class="line">                <span class="keyword">val</span> values4 = ContentValues().apply &#123;</span><br><span class="line">                    put(<span class="string">&quot;id&quot;</span>, <span class="number">2120191736</span>)</span><br><span class="line">                    put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;项明&quot;</span>)</span><br><span class="line">                    put(<span class="string">&quot;hmath&quot;</span>, <span class="number">67</span>)</span><br><span class="line">                    put(<span class="string">&quot;english&quot;</span>, <span class="number">78</span>)</span><br><span class="line">                    put(<span class="string">&quot;sport&quot;</span>, <span class="number">90</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                db.insert(<span class="string">&quot;Grade&quot;</span>, <span class="literal">null</span>, values4)</span><br><span class="line">                db.setTransactionSuccessful()</span><br><span class="line">            &#125;<span class="keyword">catch</span>(e:Exception)&#123;</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                db.endTransaction()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        val updateData: Button = findViewById(R.id.updateData)</span></span><br><span class="line"><span class="comment">//        updateData.setOnClickListener &#123;</span></span><br><span class="line"><span class="comment">//            val db = dbHelper.writableDatabase</span></span><br><span class="line"><span class="comment">//            val values = ContentValues()</span></span><br><span class="line"><span class="comment">//            values.put(&quot;hmath&quot;, 0)</span></span><br><span class="line"><span class="comment">//            values.put(&quot;english&quot;, 0)</span></span><br><span class="line"><span class="comment">//            values.put(&quot;sport&quot;, 0)</span></span><br><span class="line"><span class="comment">//            db.update(&quot;Grade&quot;, values, &quot;name = ?&quot;, arrayOf(&quot;夏天豪&quot;))</span></span><br><span class="line"><span class="comment">//            db.update(&quot;Grade&quot;, values, &quot;name = ?&quot;, arrayOf(&quot;项明&quot;))</span></span><br><span class="line"><span class="comment">//            db.update(&quot;Grade&quot;, values, &quot;name = ?&quot;, arrayOf(&quot;耿宇豪&quot;))</span></span><br><span class="line"><span class="comment">//            db.update(&quot;Grade&quot;, values, &quot;name = ?&quot;, arrayOf(&quot;王麒淳&quot;))</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">val</span> queryData: Button = findViewById(R.id.queryData)</span><br><span class="line">        queryData.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">val</span> db = dbHelper.writableDatabase  <span class="comment">// 查询Book表中所有的数据</span></span><br><span class="line">            <span class="keyword">val</span> cursor = db.query(<span class="string">&quot;Grade&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>,</span><br><span class="line">                <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">if</span> (cursor.moveToFirst()) &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;   <span class="comment">// 遍历Cursor对象，取出数据并打印</span></span><br><span class="line">                    <span class="keyword">val</span> id = cursor.getInt(cursor. getColumnIndexOrThrow(<span class="string">&quot;id&quot;</span>))</span><br><span class="line">                    <span class="keyword">val</span> name = cursor.getString(cursor.getColumnIndexOrThrow(<span class="string">&quot;name&quot;</span>))</span><br><span class="line">                    <span class="keyword">val</span> hmath = cursor.getInt(cursor. getColumnIndexOrThrow(<span class="string">&quot;hmath&quot;</span>))</span><br><span class="line">                    <span class="keyword">val</span> english = cursor.getInt(cursor. getColumnIndexOrThrow(<span class="string">&quot;english&quot;</span>))</span><br><span class="line">                    <span class="keyword">val</span> sport = cursor.getInt(cursor. getColumnIndexOrThrow(<span class="string">&quot;sport&quot;</span>))</span><br><span class="line">                    Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;id is <span class="variable">$id</span>&quot;</span>)</span><br><span class="line">                    Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;name is <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">                    Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;hmath is <span class="variable">$hmath</span>&quot;</span>)</span><br><span class="line">                    Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;english is <span class="variable">$english</span>&quot;</span>)</span><br><span class="line">                    Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;sport is <span class="variable">$sport</span>&quot;</span>)</span><br><span class="line">                    Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;------------------------&quot;</span>)</span><br><span class="line">                &#125; <span class="keyword">while</span> (cursor.moveToNext())</span><br><span class="line">            &#125;</span><br><span class="line">            cursor.close()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MyDatabaseHelper"><a href="#MyDatabaseHelper" class="headerlink" title="MyDatabaseHelper"></a>MyDatabaseHelper</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.example.homework</span><br><span class="line"></span><br><span class="line">import android.content.ContentValues</span><br><span class="line">import android.content.Context</span><br><span class="line">import android.database.sqlite.SQLiteDatabase</span><br><span class="line">import android.database.sqlite.SQLiteOpenHelper</span><br><span class="line">import android.widget.Toast</span><br><span class="line"></span><br><span class="line">class MyDatabaseHelper(val context: Context, name: String, version: Int) :</span><br><span class="line">    SQLiteOpenHelper(context, name, null, version) &#123;</span><br><span class="line">    private val createGrade &#x3D; &quot;create table Grade (&quot; +</span><br><span class="line">            &quot; id integer primary key autoincrement,&quot; +</span><br><span class="line">            &quot;name text,&quot; +</span><br><span class="line">            &quot;hmath integer,&quot; +</span><br><span class="line">            &quot;english integer,&quot; +</span><br><span class="line">            &quot;sport integer)&quot;</span><br><span class="line">    override fun onCreate(db: SQLiteDatabase) &#123;</span><br><span class="line">        db.execSQL(createGrade)</span><br><span class="line">        Toast.makeText(context, &quot;Create succeeded&quot;, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) &#123;</span><br><span class="line">        val values &#x3D; ContentValues()</span><br><span class="line">        values.put(&quot;hmath&quot;, 0)</span><br><span class="line">        values.put(&quot;english&quot;, 0)</span><br><span class="line">        values.put(&quot;sport&quot;, 0)</span><br><span class="line">        db.update(&quot;Grade&quot;, values, &quot;name &#x3D; ?&quot;, arrayOf(&quot;夏天豪&quot;))</span><br><span class="line">        db.update(&quot;Grade&quot;, values, &quot;name &#x3D; ?&quot;, arrayOf(&quot;项明&quot;))</span><br><span class="line">        db.update(&quot;Grade&quot;, values, &quot;name &#x3D; ?&quot;, arrayOf(&quot;耿宇豪&quot;))</span><br><span class="line">        db.update(&quot;Grade&quot;, values, &quot;name &#x3D; ?&quot;, arrayOf(&quot;王麒淳&quot;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="activity-main-xml"><a href="#activity-main-xml" class="headerlink" title="activity_main.xml"></a>activity_main.xml</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    android:orientation&#x3D;&quot;vertical&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;&gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;createDatabase&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:text&#x3D;&quot;Create Database&quot;&#x2F;&gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;addData&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:text&#x3D;&quot;Add Data&quot;</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;queryData&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:text&#x3D;&quot;Query Data&quot;</span><br><span class="line">        &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>实验课作业</tag>
      </tags>
  </entry>
  <entry>
    <title>Android实验课作业二 Fragment实践</title>
    <url>/2021/10/20/android2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Fragment实践：一个简易的新闻应用</p>
<span id="more"></span> 

<h1 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h1><p>1、完成Fragment实践：一个简易版的新闻应用<br>2、理解该项目的内在逻辑关系<br>3、能够较为熟练地应用Fragment和RecycleView</p>
<h1 id="二、实验环境"><a href="#二、实验环境" class="headerlink" title="二、实验环境"></a>二、实验环境</h1><p>Android Studio、Kotlin  </p>
<h1 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h1><p>运用Fragment相关内容编写一个简易的新闻应用，并且要求它可以兼容手机和平板。  </p>
<h1 id="四、主要实验步骤"><a href="#四、主要实验步骤" class="headerlink" title="四、主要实验步骤"></a>四、主要实验步骤</h1><p>1）打开Android Studio，新建工程FragmentBestPractice，如图所示：  </p>
<img src="/2021/10/20/android2/%E5%9B%BE%E7%89%871.png" class>  

<p>由于在编写新闻列表时会使用到RecyclerView，因此需要在app/build.gradle中添加RecyclerView的依赖库，因为有两个同样名字的build.gradle，所以需要注意添加依赖的位置，添加依赖如下图所示：  </p>
<img src="/2021/10/20/android2/%E5%9B%BE%E7%89%872.png" class>  

<p>2）接下来准备新闻的实体类，新建类News，如图所示：  </p>
<img src="/2021/10/20/android2/%E5%9B%BE%E7%89%873.png" class>  

<p>其中title字段表示新闻的标题，content字段表示新闻的内容。<br>接着需要新建layout文件news_content_frag.xml，作为新闻内容的布局，该布局文件主要包含三个UI控件，分别为两个TextView和两个个View：  </p>
<img src="/2021/10/20/android2/%E5%9B%BE%E7%89%874.png" class>  

<p>两个TextView代码如上图所示，其中头部部分显示新闻标题，正文部分显示正文内容，中间用一条水平线隔开，分隔的水平线用View实现。另一个控件View代码如下图所示：  </p>
<img src="/2021/10/20/android2/%E5%9B%BE%E7%89%875.png" class>  

<p>该View显示为一条垂直的细线，用于在双页模式时，将左侧的新闻列表和右侧的新闻内容分隔开。<br>该布局在design界面视图显示如下：  </p>
<img src="/2021/10/20/android2/%E5%9B%BE%E7%89%876.png" class>  

<p>3）因为在双页模式中，如果还没有选中新闻列表中的任何一条新闻，是不应该显示新闻的内容布局，所以我们需要将新闻内容的布局设置成不可见，新建NewsContentFragment类，继承自Fragment，在该类中，首先使用OnCreateView()方法加载news_content_frag布局，如图所示：  </p>
<img src="/2021/10/20/android2/%E5%9B%BE%E7%89%877.png" class>   

<p>该类中还提供了一个refresh()方法，用于将新闻的标题和内容显示在刚刚定义的界面上。调用refresh()时，需要将隐藏的新闻内容布局设置成可见，refresh()代码如下所示：  </p>
<img src="/2021/10/20/android2/%E5%9B%BE%E7%89%878.png" class>   

<p>其中，contentLayout?.visibility = View.VISIBLE代码将布局设置为可见。接着创建newsTitleAboveContent和newsContent的实例，在调用该函数时，将调用时的标题和内容分别刷新到标题和内容的TextView中。  </p>
<p>4）以上创建好了新闻内容的Fragment和布局，但是它们都是在双页模式中使用，需要新建一个NewsContentActivity，在单页中使用。<br>修改自动生成的activity_news_content.xml中的代码，如下图所示：  </p>
<img src="/2021/10/20/android2/%E5%9B%BE%E7%89%879.png" class>   

<p>Fragment中直接引入了NewsContentFragment，相当于把news_content_frag布局的内容加了进来。<br>接着修改NewsContentActibity，该Activity分为两个部分：onCreate和actionStart方法，onCreate()函数如下图所示：  </p>
<img src="/2021/10/20/android2/%E5%9B%BE%E7%89%8710.png" class>   

<p>该方法中通过intent获取传入的新闻标题和内容，然后创建NewsContentFragment的实例对象，并调用上文写到的refresh方法，显示新闻的标题和内容。<br>另一部分为actionStart方法，如下图所示：  </p>
<img src="/2021/10/20/android2/%E5%9B%BE%E7%89%8711.png" class>   

<p>该Activity所需要的参数都可以通过actionStart()方法的参数传递过来。  </p>
<p>5）新建news_title_frag作为显示新闻列表的布局，代码如下图所示  </p>
<img src="/2021/10/20/android2/%E5%9B%BE%E7%89%8712.png" class>   

<p>这个布局中仅包括一个RecyclerView用于显示新闻列表，由于用到了RecyclerView，还需要创建子项的布局news_item.xml。子项的布局中只有一个TextView，设置TextView的几个属性，如长度、高度、单行显示、留白空间、文本缩略方式等，代码如下图所示：  </p>
<img src="/2021/10/20/android2/%E5%9B%BE%E7%89%8713.png" class>   

<p>6）创建完新闻列表的布局后，还需要新建NewsTitleFragment作为展示新闻列表的Fragment，代码如图所示：  </p>
<img src="/2021/10/20/android2/%E5%9B%BE%E7%89%8714.png" class>   

<p>在onCreateView()方法中加载了news_title_frag布局，isTwoPane根据是否检测到NewsContentLayout来选择双页模式或者单页模式。   </p>
<p>7）为了实现让newsContentLayout只在双页模式中出现，修改activity_main.xml的代码，如下图所示：  </p>
<img src="/2021/10/20/android2/%E5%9B%BE%E7%89%8715.png" class>   

<p>上述代码保证了在单页模式下只会加载一个新闻标题的Fragment。<br>接着新建文件夹layout-sw600dp，在这个文件夹下新建activity_main.xml<br>用于显示双页模式，代码如下所示：  </p>
<img src="/2021/10/20/android2/%E5%9B%BE%E7%89%8716.png" class>   

<p>上述代码包含两个fragment，即在双页模式下，同时引入两个fragment，并将新闻内容的fragment放在FrameLayout布局中，因此只要能找到该布局的idnewsContentLayout时就是双页模式，否则为单页模式。该布局的预览如下图所示：  </p>
<img src="/2021/10/20/android2/%E5%9B%BE%E7%89%8717.png" class>   

<p>8）想要在NewsTitleFragment中通过RecylerView展示新闻列表，需要在该类中新建一个适配器NewsAdapter的适配器，如下图所示：  </p>
<img src="/2021/10/20/android2/%E5%9B%BE%E7%89%8718.png" class>   

<p>将适配器类写成内部类可以直接访问NewsTitleFragment的变量，上述代码首先创建了News的实例，接着根据IsTwoPane判断当前是单页还是双页模式。如果是双页模式，就刷新NewsContentFragment中的内容，如果是单页模式，则直接启动NewsContentActivity。  </p>
<p>9）最后只需要向RecyclerView中填充数据即可。修改NewsTitleFragmen中的代码，在onActivityCreated()方法中添加RecyclerView标准的使用方法，并调用getNews()方法来初始化50条模拟新闻数据，并使用getRandomLengthString()方法随机生成新闻内容的长度。具体代码如下图所示：  </p>
<img src="/2021/10/20/android2/%E5%9B%BE%E7%89%8719.png" class>   

<p>10）接着便可以分别在手机和平板的模拟器上运行程序检验一下效果。<br>手机模拟器：  </p>
<img src="/2021/10/20/android2/%E5%9B%BE%E7%89%8720.png" class>   

<p>可以看到新闻标题的列表，尝试点击第一条新闻的标题，如下图所示：  </p>
<img src="/2021/10/20/android2/%E5%9B%BE%E7%89%8721.png" class>   

<p>会启动一个新的Activity来显示新闻的内容。<br>接下来尝试将程序在平板模拟器上运行，点击第一条新闻标题，如下图所示：  </p>
<img src="/2021/10/20/android2/%E5%9B%BE%E7%89%8722.png" class>   

<p>可以看到分为了新闻标题列和新闻内容列正常运行，点击其他的新闻标题也能够正常更新标题和内容。  </p>
<h1 id="代码附录"><a href="#代码附录" class="headerlink" title="代码附录"></a>代码附录</h1><h2 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.fragmentbestpractice</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="News"><a href="#News" class="headerlink" title="News"></a>News</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.fragmentbestpractice</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">News</span></span>(<span class="keyword">val</span> title: String, <span class="keyword">val</span> content: String) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NewsContentActivity"><a href="#NewsContentActivity" class="headerlink" title="NewsContentActivity"></a>NewsContentActivity</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.fragmentbestpractice</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsContentActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">actionStart</span><span class="params">(context: <span class="type">Context</span>, title: <span class="type">String</span>, content: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(context, NewsContentActivity::<span class="keyword">class</span>.java).apply&#123; <span class="comment">//apply函数将apply的内容作用于intent，该intent从context传递到this</span></span><br><span class="line">                putExtra(<span class="string">&quot;news_title&quot;</span>,title)</span><br><span class="line">                putExtra(<span class="string">&quot;news_content&quot;</span>,content)</span><br><span class="line">            &#125;</span><br><span class="line">            context.startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_news_content)</span><br><span class="line">        <span class="keyword">val</span> title = intent.getStringExtra(<span class="string">&quot;news_title&quot;</span>)<span class="comment">//获取传入的新闻标题</span></span><br><span class="line">        <span class="keyword">val</span> content = intent.getStringExtra(<span class="string">&quot;news_content&quot;</span>)<span class="comment">//获取传入的新闻内容</span></span><br><span class="line">        <span class="keyword">if</span>(title != <span class="literal">null</span>&amp;&amp;content != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">val</span> fragment = supportFragmentManager.findFragmentById(R.id.newsContentFrag) <span class="keyword">as</span> NewsContentFragment</span><br><span class="line">            fragment.refresh(title,content) <span class="comment">//刷新NewsContentFragment界面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NewsContentFragment"><a href="#NewsContentFragment" class="headerlink" title="NewsContentFragment"></a>NewsContentFragment</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.fragmentbestpractice</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> android.widget.LinearLayout</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.Fragment</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsContentFragment</span>: <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?, savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View?&#123;</span><br><span class="line">        <span class="keyword">return</span> inflater.inflate(R.layout.news_content_frag,container,<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">refresh</span><span class="params">(title: <span class="type">String</span>, content: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> contentLayout: LinearLayout? = activity?.findViewById(R.id.contentLayout)</span><br><span class="line">        contentLayout?.visibility = View.VISIBLE</span><br><span class="line">        <span class="keyword">val</span> newsTitle: TextView? = activity?.findViewById(R.id. newsTitleAboveContent)</span><br><span class="line">        <span class="keyword">val</span> newsContent:TextView? = activity?.findViewById(R.id.newsContent)</span><br><span class="line">        newsTitle?.text = title   <span class="comment">// 刷新新闻的标题</span></span><br><span class="line">        newsContent?.text = content    <span class="comment">// 刷新新闻的内容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NewsTitleFragment"><a href="#NewsTitleFragment" class="headerlink" title="NewsTitleFragment"></a>NewsTitleFragment</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.fragmentbestpractice</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.Fragment</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.LinearLayoutManager</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.RecyclerView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsTitleFragment</span> : <span class="type">Fragment</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> isTwoPane = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">                              savedInstanceState: <span class="type">Bundle</span>?)</span></span>: View? &#123;</span><br><span class="line">        <span class="keyword">return</span> inflater.inflate(R.layout.news_title_frag, container, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState)</span><br><span class="line">        isTwoPane = activity?.findViewById&lt;View&gt;(R.id.newsContentLayout) != <span class="literal">null</span></span><br><span class="line">        <span class="keyword">val</span> layoutManager = LinearLayoutManager(activity)</span><br><span class="line">        <span class="keyword">val</span> newsTitleRecyclerView: RecyclerView? = activity?.findViewById(R.id.newsTitleRecyclerView)</span><br><span class="line">        newsTitleRecyclerView?.layoutManager = layoutManager</span><br><span class="line">        <span class="keyword">val</span> adapter = NewsAdapter(getNews())</span><br><span class="line">        newsTitleRecyclerView?.adapter = adapter&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNews</span><span class="params">()</span></span>: List&lt;News&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> newsList = ArrayList&lt;News&gt;()</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.50</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> news = News(<span class="string">&quot;This is news title <span class="variable">$i</span>&quot;</span>,</span><br><span class="line">                getRandomLengthString(<span class="string">&quot;This is news content <span class="variable">$i</span>. &quot;</span>))</span><br><span class="line">            newsList.add(news)&#125;</span><br><span class="line">        <span class="keyword">return</span> newsList</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRandomLengthString</span><span class="params">(str: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> n = (<span class="number">1.</span><span class="number">.20</span>).random()</span><br><span class="line">        <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">        repeat(n) &#123;</span><br><span class="line">            builder.append(str)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsAdapter</span></span>(<span class="keyword">val</span> newsList: List&lt;News&gt;) :</span><br><span class="line">        RecyclerView.Adapter&lt;NewsAdapter.ViewHolder&gt;() &#123;</span><br><span class="line">        <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span></span>(view: View) : RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">            <span class="keyword">val</span> newsTitle: TextView = view.findViewById(R.id.newsTitle)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: ViewHolder &#123;</span><br><span class="line">            <span class="keyword">val</span> view = LayoutInflater.from(parent.context)</span><br><span class="line">                .inflate(R.layout.news_item, parent, <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">val</span> holder = ViewHolder(view)</span><br><span class="line">            holder.itemView.setOnClickListener &#123;</span><br><span class="line">                <span class="keyword">val</span> news = newsList[holder. bindingAdapterPosition]</span><br><span class="line">                <span class="keyword">if</span> (isTwoPane) &#123;<span class="comment">// 如果是双页模式，则刷新NewsContentFragment中的内容</span></span><br><span class="line">                    <span class="keyword">val</span> fragment = fragmentManager?.findFragmentById(R.id.newsContentFrag)</span><br><span class="line">                            <span class="keyword">as</span> NewsContentFragment</span><br><span class="line">                    fragment?.refresh(news.title, news.content)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;   <span class="comment">// 如果是单页模式，则直接启动NewsContentActivity</span></span><br><span class="line">                    NewsContentActivity.actionStart(parent.context, news.title,</span><br><span class="line">                        news.content)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> holder</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> news = newsList[position]</span><br><span class="line">            holder.newsTitle.text = news.title</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span> = newsList.size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="activity-main-xml"><a href="#activity-main-xml" class="headerlink" title="activity_main.xml"></a>activity_main.xml</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;FrameLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:id=<span class="string">&quot;@+id/newsTitleLayout&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span> &gt;</span><br><span class="line">    &lt;fragment</span><br><span class="line">        android:id=<span class="string">&quot;@+id/newsTitleFrag&quot;</span></span><br><span class="line">        android:name=<span class="string">&quot;com.example.fragmentbestpractice.NewsTitleFragment&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        /&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure>

<h2 id="activity-news-content-xml"><a href="#activity-news-content-xml" class="headerlink" title="activity_news_content.xml"></a>activity_news_content.xml</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;vertical&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span>&gt;</span><br><span class="line">    &lt;fragment</span><br><span class="line">        android:id=<span class="string">&quot;@+id/newsContentFrag&quot;</span></span><br><span class="line">        android:name=<span class="string">&quot;com.example.fragmentbestpractice.NewsContentFragment&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<h2 id="news-content-frag-xml"><a href="#news-content-frag-xml" class="headerlink" title="news_content_frag.xml"></a>news_content_frag.xml</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span>&gt;</span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:id=<span class="string">&quot;@+id/contentLayout&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:orientation=<span class="string">&quot;vertical&quot;</span></span><br><span class="line">        android:visibility=<span class="string">&quot;invisible&quot;</span> &gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=<span class="string">&quot;@+id/newsTitleAboveContent&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">            android:gravity=<span class="string">&quot;center&quot;</span></span><br><span class="line">            android:padding=<span class="string">&quot;10dp&quot;</span></span><br><span class="line">            android:textSize=<span class="string">&quot;20sp&quot;</span> /&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=<span class="string">&quot;@+id/newsContent&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;0dp&quot;</span></span><br><span class="line">            android:layout_weight=<span class="string">&quot;1&quot;</span></span><br><span class="line">            android:padding=<span class="string">&quot;15dp&quot;</span></span><br><span class="line">            android:textSize=<span class="string">&quot;18sp&quot;</span> /&gt;</span><br><span class="line">        &lt;View</span><br><span class="line">            android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;1dp&quot;</span></span><br><span class="line">            android:background=<span class="string">&quot;#000&quot;</span> /&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line">    &lt;View</span><br><span class="line">        android:layout_width=<span class="string">&quot;1dp&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_alignParentLeft=<span class="string">&quot;true&quot;</span></span><br><span class="line">        android:background=<span class="string">&quot;#000&quot;</span> /&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure>

<h2 id="news-item-xml"><a href="#news-item-xml" class="headerlink" title="news_item.xml"></a>news_item.xml</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;TextView xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:id=<span class="string">&quot;@+id/newsTitle&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">    android:maxLines=<span class="string">&quot;1&quot;</span></span><br><span class="line">    android:ellipsize=<span class="string">&quot;end&quot;</span></span><br><span class="line">    android:textSize=<span class="string">&quot;18sp&quot;</span></span><br><span class="line">    android:paddingLeft=<span class="string">&quot;10dp&quot;</span></span><br><span class="line">    android:paddingRight=<span class="string">&quot;10dp&quot;</span></span><br><span class="line">    android:paddingTop=<span class="string">&quot;15dp&quot;</span></span><br><span class="line">    android:paddingBottom=<span class="string">&quot;15dp&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="news-title-frag-xml"><a href="#news-title-frag-xml" class="headerlink" title="news_title_frag.xml"></a>news_title_frag.xml</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;vertical&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span>&gt;</span><br><span class="line">    &lt;androidx.recyclerview.widget.RecyclerView</span><br><span class="line">        android:id=<span class="string">&quot;@+id/newsTitleRecyclerView&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<h2 id="activity-main-xml-sw600dp"><a href="#activity-main-xml-sw600dp" class="headerlink" title="activity_main.xml(sw600dp)"></a>activity_main.xml(sw600dp)</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;vertical&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span>&gt;</span><br><span class="line">    &lt;androidx.recyclerview.widget.RecyclerView</span><br><span class="line">        android:id=<span class="string">&quot;@+id/newsTitleRecyclerView&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>实验课作业</tag>
      </tags>
  </entry>
  <entry>
    <title>第十一届蓝桥杯C/C++ B组国赛部分题解</title>
    <url>/2021/06/01/lanqiao/</url>
    <content><![CDATA[<p>填空题和部分编程题（因为太菜了，没有全部题目的题解</p>
<span id="more"></span>

<h1 id="试题-A-美丽的-2"><a href="#试题-A-美丽的-2" class="headerlink" title="试题 A: 美丽的 2"></a>试题 A: 美丽的 2</h1><p><strong>【问题描述】</strong><br>小蓝特别喜欢 2，今年是公元 2020 年，他特别高兴。<br>他很好奇，在公元 1 年到公元 2020 年（包含）中，有多少个年份的数位中包含数字 2？</p>
<p>答案：563</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2020</span>; i ++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x = i;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">while</span>(x)&#123;</span><br><span class="line">			<span class="keyword">int</span> t = x % <span class="number">10</span>;</span><br><span class="line">			<span class="keyword">if</span>(t == <span class="number">2</span>)&#123;</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			x /= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag) cnt ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="试题-B-扩散"><a href="#试题-B-扩散" class="headerlink" title="试题 B: 扩散"></a>试题 B: 扩散</h1><p><strong>【问题描述】</strong><br>小蓝在一张无限大的特殊画布上作画。<br>这张画布可以看成一个方格图，每个格子可以用一个二维的整数坐标表示。<br>小蓝在画布上首先点了一下几个点：(0, 0), (2020, 11), (11, 14), (2000, 2000)。<br>只有这几个格子上有黑色，其它位置都是白色的。<br>每过一分钟，黑色就会扩散一点。具体的，如果一个格子里面是黑色，它就会扩散到上、下、左、右四个相邻的格子中，使得这四个格子也变成黑色（如果原来就是黑色，则还是黑色）。<br>请问，经过 2020 分钟后，画布上有多少个格子是黑色的。  </p>
<p>简单的bfs  </p>
<p>答案：20312088</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2500</span>;</span><br><span class="line"><span class="keyword">bool</span> st[<span class="number">8000</span>][<span class="number">8000</span>];</span><br><span class="line">ll res = <span class="number">4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="keyword">int</span> step;</span><br><span class="line">&#125;node[<span class="number">8000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">	<span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">	q.push(&#123;<span class="number">0</span> + N, <span class="number">0</span> + N, <span class="number">0</span>&#125;), q.push(&#123;<span class="number">2020</span> + N, <span class="number">11</span> + N, <span class="number">0</span>&#125;), q.push(&#123;<span class="number">11</span> + N, <span class="number">14</span> + N, <span class="number">0</span>&#125;), q.push(&#123;<span class="number">2000</span> + N, <span class="number">2000</span> + N, <span class="number">0</span>&#125;);</span><br><span class="line">	st[<span class="number">0</span> + N][<span class="number">0</span> + N] = <span class="literal">true</span>;</span><br><span class="line">	st[<span class="number">2020</span> + N][<span class="number">11</span> + N] = <span class="literal">true</span>;</span><br><span class="line">	st[<span class="number">11</span> + N][<span class="number">14</span> + N] = <span class="literal">true</span>;</span><br><span class="line">	st[<span class="number">2000</span> + N][<span class="number">2000</span> + N] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">		Node t = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span>(t.step == <span class="number">2020</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )&#123;</span><br><span class="line">			<span class="keyword">int</span> a = t.x + dx[i];</span><br><span class="line">			<span class="keyword">int</span> b = t.y + dy[i];</span><br><span class="line">			<span class="keyword">if</span>(st[a][b]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				st[a][b] = <span class="literal">true</span>;</span><br><span class="line">				q.push(&#123;a, b, t.step + <span class="number">1</span>&#125;);</span><br><span class="line">				res ++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	bfs();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-C-阶乘约数"><a href="#试题-C-阶乘约数" class="headerlink" title="试题 C: 阶乘约数"></a>试题 C: 阶乘约数</h1><p><strong>【问题描述】</strong><br>定义阶乘 n! = 1 × 2 × 3 × · · · × n。<br>请问 100! （100 的阶乘）有多少个约数。  </p>
<p>数论问题  </p>
<p>答案：39001250856960000</p>
<p><strong>代码实现：</strong>   </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> minp[N];</span><br><span class="line"><span class="keyword">int</span> primes[N];</span><br><span class="line"><span class="keyword">int</span> st[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> sum[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">			primes[cnt ++] = i;</span><br><span class="line">			minp[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; i * primes[j] &lt;= n; j ++)&#123;</span><br><span class="line">			<span class="keyword">int</span> t = i * primes[j];</span><br><span class="line">			st[t] = <span class="literal">true</span>;</span><br><span class="line">			minp[t] = primes[j];</span><br><span class="line">			<span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ll res;</span><br><span class="line">	get_primes(<span class="number">1000</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">100</span>; i ++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x = i;</span><br><span class="line">		<span class="keyword">while</span>(x &gt; <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> p = minp[x];</span><br><span class="line">			<span class="keyword">while</span>(x % p == <span class="number">0</span>)&#123;</span><br><span class="line">				x /= p;</span><br><span class="line">				sum[p] ++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i ++)</span><br><span class="line">		<span class="keyword">if</span>(sum[i] != <span class="number">0</span>) res *= (<span class="number">1</span> + sum[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, res);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="试题-D-本质上升序列"><a href="#试题-D-本质上升序列" class="headerlink" title="试题 D: 本质上升序列"></a>试题 D: 本质上升序列</h1><p><strong>【问题描述】</strong><br>小蓝特别喜欢单调递增的事物。<br>在一个字符串中,如果取出若干个字符,将这些字符按照在字符串中的顺序排列后是单调递增的,则成为这个字符串中的一个单调递增子序列。<br>例如,在字符串 lanqiao 中,如果取出字符 n 和 q,则 nq 组成一个单调递增子序列。类似的单调递增子序列还有 lnq、i、ano 等等。<br>小蓝发现,有些子序列虽然位置不同,但是字符序列是一样的,例如取第二个字符和最后一个字符可以取到 ao,取最后两个字符也可以取到 ao。小蓝认为他们并没有本质不同。<br>对于一个字符串,小蓝想知道,本质不同的递增子序列有多少个?<br>例如,对于字符串 lanqiao,本质不同的递增子序列有 21 个。它们分别是 l、a、n、q、i、o、ln、an、lq、aq、nq、ai、lo、ao、no、io、lnq、anq、lno、ano、aio。<br>请问对于以下字符串(共 200 个小写英文字母,分四行显示):(如果你把以下文字复制到文本文件中,请务必检查复制的内容是否与文档中的一致。在试题目录下有一个文件 inc.txt,内容与下面的文本相同)<br>tocyjkdzcieoiodfpbgcncsrjbhmugdnojjddhllnofawllbhfiadgdcdjstemphmnjihecoapdjjrprrqnhgccevdarufmliqijgihhfgdcmxvicfauachlifhafpdccfseflcdgjncadfclvfmadvrnaaahahndsikzssoywakgnfjjaihtniptwoulxbaeqkqhfwl<br>本质不同的递增子序列有多少个?  </p>
<p>类似于最长子序列的dp问题  </p>
<p>答案：3616159</p>
<p><strong>代码实现：</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">3000</span>][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">210</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i ++)&#123;</span><br><span class="line">		dp[i][s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i ++)&#123;</span><br><span class="line">		<span class="keyword">int</span> curr = s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; curr; j ++)</span><br><span class="line">			dp[i][curr] += dp[i - <span class="number">1</span>][j];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; j ++)</span><br><span class="line">			dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i ++)	res += dp[len][i];</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="试题-E-玩具蛇"><a href="#试题-E-玩具蛇" class="headerlink" title="试题 E: 玩具蛇"></a>试题 E: 玩具蛇</h1><p><strong>【问题描述】</strong><br>小蓝有一条玩具蛇,一共有 16 节,上面标着数字 1 至 16。每一节都是一个正方形的形状。相邻的两节可以成直线或者成 90 度角。<br>小蓝还有一个 4 × 4 的方格盒子,用于存放玩具蛇,盒子的方格上依次标着字母 A 到 P 共 16 个字母。<br>小蓝可以折叠自己的玩具蛇放到盒子里面。他发现,有很多种方案可以将玩具蛇放进去。<br>下图给出了两种方案:<br><img src="/2021/06/01/lanqiao/she1.png">  </p>
<p>深搜搞定  </p>
<p>答案：552  </p>
<p><strong>代码实现：</strong>   </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> st[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">ll res;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(step == <span class="number">16</span>)&#123;</span><br><span class="line">		res ++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++)&#123;</span><br><span class="line">		<span class="keyword">int</span> a = x + dx[i];</span><br><span class="line">		<span class="keyword">int</span> b = y + dy[i];</span><br><span class="line">		<span class="keyword">if</span>(a &lt;= <span class="number">0</span> || a &gt; <span class="number">4</span> || b &lt;= <span class="number">0</span> || b &gt; <span class="number">4</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(st[a][b]) <span class="keyword">continue</span>;</span><br><span class="line">		st[a][b] = <span class="literal">true</span>;</span><br><span class="line">		dfs(a, b, step + <span class="number">1</span>);</span><br><span class="line">		st[a][b] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i ++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; j ++)&#123;</span><br><span class="line">			st[i][j] = <span class="literal">true</span>;</span><br><span class="line">			dfs(i, j, <span class="number">1</span>);</span><br><span class="line">			st[i][j] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-F-皮亚诺曲线距离"><a href="#试题-F-皮亚诺曲线距离" class="headerlink" title="试题 F: 皮亚诺曲线距离"></a>试题 F: 皮亚诺曲线距离</h1><p><strong>【问题描述】</strong><br>皮亚诺曲线是一条平面内的曲线。<br>下图给出了皮亚诺曲线的 1 阶情形，它是从左下角出发，经过一个 3×3 的<br>方格中的每一个格子，最终到达右上角的一条曲线。<br><img src="/2021/06/01/lanqiao/f1.png">  </p>
<p>下图给出了皮亚诺曲线的 2 阶情形，它是经过一个 3 2 × 3 2 的方格中的每一 个格子的一条曲线。它是将 1 阶曲线的每个方格由 1 阶曲线替换而成。<br><img src="/2021/06/01/lanqiao/f2.png">  </p>
<p>下图给出了皮亚诺曲线的 3 阶情形，它是经过一个 3 3 × 3 3 的方格中的每一个格子的一条曲线。它是将 2 阶曲线的每个方格由 1 阶曲线替换而成。<br><img src="/2021/06/01/lanqiao/f3.png">  </p>
<p>皮亚诺曲线总是从左下角开始出发，最终到达右上角。<br>我们将这些格子放到坐标系中，对于 k 阶皮亚诺曲线，左下角的坐标是<br>(0,0)，右上角坐标是 (3 k − 1,3 k − 1)，右下角坐标是 (3 k − 1,0)，左上角坐标是(0,3 k − 1)。<br>给定 k 阶皮亚诺曲线上的两个点的坐标，请问这两个点之间，如果沿着皮亚诺曲线走，距离是到少？  </p>
<p><strong>输入格式</strong><br>输入的第一行包含一个正整数 k，皮亚诺曲线的阶数。<br>第二行包含两个整数 x 1 , y 1 ，表示第一个点的坐标。<br>第三行包含两个整数 x 2 , y 2 ，表示第二个点的坐标。  </p>
<p><strong>输出格式</strong><br>输出一个整数，表示给定的两个点之间的距离。  </p>
<p><strong>输入样例1：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0 0</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>

<p><strong>输出样例1：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>

<p><strong>输入样例2：</strong>   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">0 2</span><br><span class="line">0 3</span><br></pre></td></tr></table></figure>

<p><strong>输出样例2：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure>

<p><strong>评测用例规模与约定</strong><br>对于 30% 的评测用例，0 ≤ k ≤ 10。<br>对于 50% 的评测用例，0 ≤ k ≤ 20。<br>对于所有评测用例，0 ≤ k ≤ 100, 0 ≤ x 1 ,y 1 , x 2 ,y 2 &lt; 3 k , x 1 ,y 1 , x 2 ,y 2 ≤ 10 18 。<br>数据保证答案不超过 10 18 。  </p>
<p><strong>代码实现：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">呜呜呜不会</span><br></pre></td></tr></table></figure>

<h1 id="试题-G-游园安排"><a href="#试题-G-游园安排" class="headerlink" title="试题 G: 游园安排"></a>试题 G: 游园安排</h1><p><strong>【问题描述】</strong><br>L 星球游乐园非常有趣，吸引着各个星球的游客前来游玩。小蓝是 L 星球游乐园的管理员。<br>为了更好的管理游乐园，游乐园要求所有的游客提前预约，小蓝能看到系<br>统上所有预约游客的名字。每个游客的名字由一个大写英文字母开始，后面跟0 个或多个小写英文字母。游客可能重名。<br>小蓝特别喜欢递增的事物。今天，他决定在所有预约的游客中，选择一部分游客在上午游玩，其他的游客都在下午游玩，在上午游玩的游客要求按照预约的顺序排列后，名字是单调递增的，即排在前面的名字严格小于排在后面的名字。<br>一个名字 A 小于另一个名字 B 是指：存在一个整数 i，使得 A 的前 i 个字母与 B 的前 i 个字母相同，且 A 的第 i+1 个字母小于 B 的第 i+1 个字母。（如果 A 不存在第 i + 1 个字母且 B 存在第 i + 1 个字母，也视为 A 的第 i + 1 个字母小于 B 的第 i + 1 个字母）<br>作为小蓝的助手，你要按照小蓝的想法安排游客，同时你又希望上午有尽量多的游客游玩，请告诉小蓝让哪些游客上午游玩。如果方案有多种，请输出上午游玩的第一个游客名字最小的方案。如果此时还有多种方案，请输出第一个游客名字最小的前提下第二个游客名字最小的方案。如果仍然有多种，依此类推选择第三个、第四个……游客名字最小的方案。  </p>
<p><strong>输入格式</strong><br>输入包含一个字符串，按预约的顺序给出所有游客的名字，相邻的游客名<br>字之间没有字符分隔。  </p>
<p><strong>输出格式</strong><br>按预约顺序输出上午游玩的游客名单，中间不加任何分隔字符。  </p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WoAiLanQiaoBei</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AiLanQiao</span><br></pre></td></tr></table></figure>

<p><strong>评测用例规模与约定</strong><br>对于 20% 的评测数据，输入的总长度不超过 20 个字母。<br>对于 50% 的评测数据，输入的总长度不超过 300 个字母。<br>对于 70% 的评测数据，输入的总长度不超过 10000 个字母。<br>对于所有评测数据，每个名字的长度不超过 10 个字母，输入的总长度不超过 1000000 个字母。  </p>
<p><strong>代码实现：</strong><br>最长子序列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">string</span> str[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans[<span class="number">10000</span>];</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i] &lt;= <span class="string">&#x27;Z&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">			str[++ cnt].push_back(s[i]);</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> str[cnt].push_back(s[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//for(int i = 1; i &lt;= cnt; i ++) cout &lt;&lt; str[i] &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i ++)&#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; temp;</span><br><span class="line">		dp[i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j ++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(str[i] &gt; str[j])&#123;</span><br><span class="line">				<span class="keyword">if</span>(dp[i] &lt; dp[j] + <span class="number">1</span>)&#123;</span><br><span class="line">					dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">					temp = ans[j];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(dp[i] == dp[j] + <span class="number">1</span>)&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; ans[j].size(); k ++)&#123;</span><br><span class="line">						<span class="keyword">if</span>(ans[j].at(k) &lt; temp.at(k))&#123;</span><br><span class="line">							temp = ans[j];</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		temp.push_back(str[i]);</span><br><span class="line">		ans[i] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i ++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dp[i] &gt; res)&#123;</span><br><span class="line">			res = dp[i];</span><br><span class="line">			r = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(dp[i] == res)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ans[i].size(); j ++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(ans[i].at(j) &lt; ans[r].at(j))&#123;</span><br><span class="line">					res = dp[i];</span><br><span class="line">					r = i;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans[r].size(); i ++) <span class="built_in">cout</span> &lt;&lt; ans[r].at(i);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-H-答疑"><a href="#试题-H-答疑" class="headerlink" title="试题 H: 答疑"></a>试题 H: 答疑</h1><p><strong>【问题描述】</strong><br>有 n 位同学同时找老师答疑。每位同学都预先估计了自己答疑的时间。<br>老师可以安排答疑的顺序，同学们要依次进入老师办公室答疑。<br>一位同学答疑的过程如下：<br>首先进入办公室，编号为 i 的同学需要 si 毫秒的时间。<br>然后同学问问题老师解答，编号为 i 的同学需要 ai 毫秒的时间。<br>答疑完成后，同学很高兴，会在课程群里面发一条消息，需要的时间可以忽略。<br>最后同学收拾东西离开办公室，需要 ei 毫秒的时间。一般需要 10秒、20 秒或 30 秒，即 ei 取值为 10000，20000 或 30000。<br>一位同学离开办公室后，紧接着下一位同学就可以进入办公室了。<br>答疑从 0 时刻开始。老师想合理的安排答疑的顺序，使得同学们在课程群里面发消息的时刻之和最小。  </p>
<p><strong>输入格式</strong><br>输入第一行包含一个整数 n，表示同学的数量。<br>接下来 n 行，描述每位同学的时间。其中第 i 行包含三个整数 s i , a i , e i ，意义如上所述。  </p>
<p><strong>输出格式</strong><br>输出一个整数，表示同学们在课程群里面发消息的时刻之和最小是多少。    </p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">10000 10000 10000</span><br><span class="line">20000 50000 20000</span><br><span class="line">30000 20000 30000</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">280000</span><br></pre></td></tr></table></figure>

<p><strong>评测用例规模与约定</strong><br>对于 30% 的评测用例，1 ≤ n ≤ 20。<br>对于 60% 的评测用例，1 ≤ n ≤ 200。<br>对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ s i ≤ 60000，1 ≤ a i ≤ 1000000,e i ∈ {10000,20000,30000}，即 e i 一定是 10000、20000、30000 之一。  </p>
<p><strong>代码实现：</strong><br>贪心实现 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> s;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> e;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Stu &amp;t)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum1 = s + a + e;</span><br><span class="line">		<span class="keyword">int</span> sum2 = t.s + t.a + t.e;</span><br><span class="line">		<span class="keyword">return</span> sum1 &lt; sum2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;student[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">	ll time = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">		<span class="keyword">int</span> s, a, e;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; a &gt;&gt; e;</span><br><span class="line">		student[i] = &#123;s, a, e&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(student, student + n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">		time += student[i].s + student[i].a;</span><br><span class="line">		res += time;</span><br><span class="line">		time += student[i].e;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-I-出租车"><a href="#试题-I-出租车" class="headerlink" title="试题 I: 出租车"></a>试题 I: 出租车</h1><p><strong>【问题描述】</strong><br>小蓝在 L 市开出租车。<br>L 市的规划很规整，所有的路都是正东西向或者正南北向的，道路都可以看成直线段。东西向的道路互相平行，南北向的道路互相平行，任何一条东西向道路垂直于任何一条南北向道路。<br>从北到南一共有 n 条东西向道路，依次标号为 H 1 , H 2 , ···, H n 。从西到东一共有 m 条南北向的道路，依次标号为 S 1 , S 2 , ···, S m 。<br>每条道路都有足够长，每一条东西向道路和每一条南北向道路都相交，H i与 S j 的交叉路口记为 (i, j)。<br>从 H 1 和 S 1 的交叉路口 (1,1) 开始，向南遇到的路口与 (1,1) 的距离分别是 h 1 , h 2 , ···, h n−1 ，向东遇到路口与 (1,1) 的距离分别是 w 1 , w 2 , ···, w m−1 。道路的每个路口都有一个红绿灯。<br>时刻 0 的时候，南北向绿灯亮，东西向红灯亮，南北向的绿灯会持续一段时间（每个路口不同），然后南北向变成红灯，东西向变成绿灯，持续一段时间后，再变成南北向绿灯，东西向红灯。<br>已知路口 (i, j) 的南北向绿灯每次持续的时间为 g ij ，东西向的绿灯每次持续的时间为 r ij ，红绿灯的变换时间忽略。<br>当一辆车走到路口时，如果是绿灯，可以直行、左转或右转。如果是红灯，可以右转，不能直行或左转。如果到路口的时候刚好由红灯变为绿灯，则视为看到绿灯，如果刚好由绿灯变为红灯，则视为看到红灯。<br>每段道路都是双向道路，道路中间有隔离栏杆，在道路中间不能掉头，只能在红绿灯路口掉头。掉头时不管是红灯还是绿灯都可以直接掉头。掉头的时间可以忽略。<br>小蓝时刻 0 从家出发。今天，他接到了 q 个预约的订单，他打算按照订单的顺序依次完成这些订单，就回家休息。中途小蓝不准备再拉其他乘客。<br>小蓝的家在两个路口的中点，小蓝喜欢用 x 1 , y 1 , x 2 , y 2 来表示自己家的位置，即路口 (x 1 ,y 1 ) 到路口 (x 2 ,y 2 ) 之间的道路中点的右侧，保证两个路口相邻（中间没有其他路口）。请注意当两个路口交换位置时，表达的是路的不同两边，路中间有栏杆，因此这两个位置实际要走比较远才能到达。<br>小蓝的订单也是从某两个路口间的中点出发，到某两个路口间的中点结束。小蓝必须按照给定的顺序处理订单，而且一个时刻只能处理一个订单，不能图省时间而同时接两位乘客，也不能插队完成后面的订单。<br>小蓝只对 L 市比较熟，因此他只会在给定的 n 条东西向道路和 m 条南北向道路上行驶，而且不会驶出 H 1 , H n , S 1 , S m 这几条道路所确定的矩形区域（可以到边界）。小蓝行车速度一直为 1，乘客上下车的时间忽略不计。请问，小蓝最早什么时候能完成所有订单回到家。  </p>
<p><strong>输入格式</strong><br>输入第一行包含两个整数 n, m，表示东西向道路的数量和南北向道路的数量。<br>第二行包含 n − 1 个整数 h 1 , h 2 , ···, h n−1 。<br>第三行包含 m − 1 个整数 w 1 , w 2 , ···, w m−1 。<br>接下来 n 行，每行 m 个整数，描述每个路口南北向绿灯的时间，其中的第i 行第 j 列表示 g ij 。<br>接下来 n 行，每行 m 个整数，描述每个路口东西向绿灯的时间，其中的第i 行第 j 列表示 r ij 。<br>接下来一行包含四个整数 x 1 , y 1 , x 2 , y 2 ，表示小蓝家的位置在路口 (x 1 ,y 1 )到路口 (x 2 ,y 2 ) 之间的道路中点的右侧。<br>接下来一行包含一个整数 q，表示订单数量。<br>接下来 q 行，每行描述一个订单，其中第 i 行包含八个整数 x i1 , y i1 , x i2 , y i2 ,x i3 , y i3 , x i4 , y i4 ，表示第 i 个订单的起点为路口 (x i1 ,y i1 ) 到路口 (x i2 ,y i2 ) 之间的道路中点的右侧，第 i 个订单的终点为路口 (x i3 ,y i3 ) 到路口 (x i4 ,y i4 ) 之间的道路中点的右侧。  </p>
<p><strong>输出格式</strong><br>输出一个实数，表示小蓝完成所有订单最后回到家的最早时刻。四舍五入保留一位小数。    </p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3</span><br><span class="line">200</span><br><span class="line">100 400</span><br><span class="line">10 20 10</span><br><span class="line">20 40 30</span><br><span class="line">20 20 20</span><br><span class="line">20 20 20</span><br><span class="line">2 1 1 1</span><br><span class="line">1</span><br><span class="line">2 2 1 2 1 2 1 3</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1620.0</span><br></pre></td></tr></table></figure>

<p><strong>样例说明</strong><br>小蓝有一个订单，他的行车路线如下图所示。其中 H 表示他家的位置，S表示订单的起点，T 表示订单的终点。小明在最后回家时要在直行的红绿灯路口等绿灯，等待时间为 20。<br><img src="/2021/06/01/lanqiao/i.png">  </p>
<p><strong>代码实现：</strong>   </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">太长不看（明明是不会</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>practise</category>
      </categories>
      <tags>
        <tag>算法练习</tag>
      </tags>
  </entry>
  <entry>
    <title>第十届蓝桥杯C/C++ B组国赛部分题解</title>
    <url>/2021/06/01/lanqiao2/</url>
    <content><![CDATA[<p>填空题和部分编程题（因为太菜了，没有全部题目的题解</p>
<span id="more"></span>  

<h1 id="试题-A-平方序列"><a href="#试题-A-平方序列" class="headerlink" title="试题 A: 平方序列"></a>试题 A: 平方序列</h1><p><strong>【问题描述】</strong><br>小明想找到两个正整数 X 和 Y，满足<br>• 2019 &lt; X &lt; Y;<br>• 2019^2 , X^2 , Y^2<br>组成等差数列。 请你求出在所有可能的解中，X + Y 的最小值是多少？  </p>
<p>暴力<br>答案：7020</p>
<p><strong>代码实现：</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="keyword">for</span>(x = <span class="number">2020</span>; x &lt; <span class="number">10000</span>; x ++ )&#123;</span><br><span class="line">		<span class="keyword">for</span>(y = x + <span class="number">1</span>; y &lt; <span class="number">10000</span>; y ++ )&#123;</span><br><span class="line">			<span class="keyword">if</span>(x * x - <span class="number">2019</span> * <span class="number">2019</span> == y * y - x * x)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(x * x - <span class="number">2019</span> * <span class="number">2019</span> == y * y - x * x)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; x + y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-B-质数拆分"><a href="#试题-B-质数拆分" class="headerlink" title="试题 B: 质数拆分"></a>试题 B: 质数拆分</h1><p><strong>【问题描述】</strong><br>将 2019 拆分为若干个两两不同的质数之和，一共有多少种不同的方法？ 注意交换顺序视为同一种方法，例如 2 + 2017 = 2019 与 2017 + 2 = 2019 视为同一种方法。  </p>
<p>暴力<br>答案：1</p>
<p><strong>代码实现：</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; i ++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">2019</span> / <span class="number">2</span>); i ++ )&#123;</span><br><span class="line">		<span class="keyword">if</span>(is_prime(i) &amp;&amp; is_prime(<span class="number">2019</span> - i))</span><br><span class="line">			cnt ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="试题-C-拼接"><a href="#试题-C-拼接" class="headerlink" title="试题 C: 拼接"></a>试题 C: 拼接</h1><p><strong>【问题描述】</strong><br>小明要把一根木头切成两段，然后拼接成一个直角。 如下图所示，他把中间部分分成了 n × n 的小正方形，他标记了每个小正方 形属于左边还是右边。然后沿两边的分界线将木头切断，将右边旋转向上后拼接在一起。<br><img src="/2021/06/01/lanqiao2/c.png">  </p>
<p>要求每个小正方形都正好属于左边或右边，而且同一边的必须是连通的。 在拼接时，拼接的部位必须保持在原来大正方形里面。 请问，对于 7 × 7 的小正方形，有多少种合法的划分小正方形的方式。</p>
<p>答案：14</p>
<p><strong>代码实现：</strong>  </p>
<h1 id="试题-D-求值"><a href="#试题-D-求值" class="headerlink" title="试题 D: 求值"></a>试题 D: 求值</h1><p><strong>【问题描述】</strong><br>学习了约数后，小明对于约数很好奇，他发现，给定一个正整数 t，总是可 以找到含有 t 个约数的整数。小明对于含有 t 个约数的最小数非常感兴趣，并 把它定义为 S t 。 例如 S 1 = 1, S 2 = 2, S 3 = 4, S 4 = 6，· · · 。 现在小明想知道，当 t = 100 时，S t 是多少？即 S 100 是多少？</p>
<p>答案：45360</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> minp[N];</span><br><span class="line"><span class="keyword">int</span> primes[N];</span><br><span class="line"><span class="keyword">int</span> st[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> sum[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x; i ++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">			primes[cnt ++] = i;</span><br><span class="line">			minp[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; i * primes[j] &lt;= x; j ++)&#123;</span><br><span class="line">			<span class="keyword">int</span> p = i * primes[j];</span><br><span class="line">			st[p] = <span class="literal">true</span>;</span><br><span class="line">			minp[p] = primes[j];</span><br><span class="line">			<span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	get_primes(<span class="number">100000</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">100000</span>; i ++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x = i;</span><br><span class="line">		<span class="keyword">int</span> cnt2 = <span class="number">0</span>;</span><br><span class="line">		res = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">		<span class="keyword">while</span>(x &gt; <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> p = minp[x];</span><br><span class="line">			<span class="keyword">while</span>(x % p == <span class="number">0</span>)&#123;</span><br><span class="line">				x /= p;</span><br><span class="line">				sum[cnt2] ++;</span><br><span class="line">			&#125;</span><br><span class="line">			cnt2 ++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= cnt2; j ++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(sum[j] != <span class="number">0</span>)</span><br><span class="line">				res *= (<span class="number">1</span> + sum[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(res == <span class="number">100</span>)&#123;</span><br><span class="line">			ans = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-E-求值"><a href="#试题-E-求值" class="headerlink" title="试题 E: 求值"></a>试题 E: 求值</h1><p><strong>【问题描述】</strong><br>从一个 5x5 的方格矩阵的左上角出发，沿着方格的边走，满足以下条件的路线有多少种？<br>• 总长度不超过 12；<br>• 最后回到左上角；<br>• 路线不自交；<br>• 不走出 5x5 的方格矩阵范围之外。<br>如下图所示，ABC 是三种合法的路线。注意 B 和 C 由于方向不同，所以 视为不同的路线。<br><img src="/2021/06/01/lanqiao2/e.png">  </p>
<p>答案：208</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">bool</span> st[N][N];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(step &gt; <span class="number">12</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span> &amp;&amp; st[<span class="number">0</span>][<span class="number">0</span>])&#123;</span><br><span class="line">		cnt ++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )&#123;</span><br><span class="line">		<span class="keyword">int</span> a = x + dx[i];</span><br><span class="line">		<span class="keyword">int</span> b = y + dy[i];</span><br><span class="line">		<span class="keyword">if</span>(a &lt; <span class="number">0</span> || a &gt; <span class="number">5</span> || b &lt; <span class="number">0</span> || b &gt; <span class="number">5</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(st[a][b]) <span class="keyword">continue</span>;</span><br><span class="line">		st[a][b] = <span class="literal">true</span>;</span><br><span class="line">		dfs(a, b, step + <span class="number">1</span>);</span><br><span class="line">		st[a][b] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-F-最优包含"><a href="#试题-F-最优包含" class="headerlink" title="试题 F: 最优包含"></a>试题 F: 最优包含</h1><p><strong>【问题描述】</strong><br>我们称一个字符串 S 包含字符串 T 是指 T 是 S 的一个子序列，即可以从字符串 S 中抽出若干个字符，它们按原来的顺序组合成一个新的字符串与 T 完全一样。  </p>
<p>给定两个字符串 S 和 T，请问最少修改 S 中的多少个字符，能使 S 包含 T？  </p>
<p><strong>输入格式</strong><br>输入两行，每行一个字符串。</p>
<p>第一行的字符串为 S，第二行的字符串为 T。</p>
<p>两个字符串均非空而且只包含大写英文字母。</p>
<p><strong>输出格式</strong><br>输出一个整数，表示答案。    </p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ABCDEABCD</span><br><span class="line">XAABZ</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p><strong>评测用例规模与约定</strong><br>1≤|T|≤|S|≤1000  </p>
<p><strong>代码实现：</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s,t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="built_in">memset</span>(dp,INF,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= s.size() ;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">1</span>; j &lt;= i ;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>] == INF) dp[i][j] = min(dp[i][j],<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = min(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]== INF)</span><br><span class="line">                    dp[i][j] = min(<span class="number">1</span>,dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                <span class="keyword">else</span>  dp[i][j] = min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>,dp[i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[s.size()][t.size()]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="试题-G-排列数"><a href="#试题-G-排列数" class="headerlink" title="试题 G: 排列数"></a>试题 G: 排列数</h1><p><strong>【问题描述】</strong><br>在一个排列中，一个折点是指排列中的一个元素，它同时小于两边的元素，或者同时大于两边的元素。</p>
<p>对于一个 1∼n 的排列，如果可以将这个排列中包含 t 个折点，则它称为一个 t+1 单调序列。</p>
<p>例如，排列 (1,4,2,3) 是一个 3 单调序列，其中 4 和 2 都是折点。</p>
<p>给定 n 和 k，请问 1∼n 的所有排列中有多少个 k 单调队列？</p>
<p><strong>输入格式</strong><br>输入一行包含两个整数 n,k。</p>
<p><strong>输出格式</strong><br>输出一个整数，表示答案。</p>
<p>答案可能很大，你可需要输出满足条件的排列数量除以 123456 的余数即可。    </p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure>

<p><strong>评测用例规模与约定</strong><br>1≤k≤n≤500  </p>
<p><strong>代码实现：</strong>  </p>
<h1 id="试题-H-解谜游戏"><a href="#试题-H-解谜游戏" class="headerlink" title="试题 H: 解谜游戏"></a>试题 H: 解谜游戏</h1><p><strong>【问题描述】</strong><br>小明正在玩一款解谜游戏。</p>
<p>谜题由 24 根塑料棒组成，其中黄色塑料棒 4 根，红色 8 根，绿色 12 根 (后面用 Y 表示黄色、R 表示红色、G 表示绿色)。<br><img src="/2021/06/01/lanqiao2/h.png"><br>初始时这些塑料棒排成三圈，如上图所示，外圈 12 根，中圈 8 根，内圈 4 根。</p>
<p>小明可以进行三种操作：</p>
<p>①将三圈塑料棒都顺时针旋转一个单位。例如当前外圈从 0 点位置开始顺时针依次是 YRYGRYGRGGGG，中圈是 RGRGGRRY，内圈是 GGGR。那么顺时针旋转一次之后，外圈、中圈、内圈依次变为：GYRYGRYGRGGG、YRGRGGRR 和 RGGG。<br>②将三圈塑料棒都逆时针旋转一个单位。例如当前外圈从 0 点位置开始顺时针依次是 YRYGRYGRGGGG，中圈是 RGRGGRRY，内圈是 GGGR。那么逆时针旋转一次之后，外圈、中圈、内圈依次变为：RYGRYGRGGGGY、GRGGRRYR 和 GGRG。<br>③将三圈 0 点位置的塑料棒做一个轮换。具体来说：外圈 0 点塑料棒移动到内圈 0 点，内圈 0 点移动到中圈 0 点，中圈 0 点移动到外圈 0 点。例如当前外圈从 0 点位置开始顺时针依次是 YRYGRYGRGGGG，中圈是 RGRGGRRY，内圈是 GGGR。那么轮换一次之后，外圈、中圈、内圈依次变为：RRYGRYGRGGGG、GGRGGRRY 和 YGGR。<br>小明的目标是把所有绿色移动到外圈、所有红色移动中圈、所有黄色移动到内圈。</p>
<p>给定初始状态，请你判断小明是否可以达成目标？</p>
<p><strong>输入格式</strong><br>第一行包含一个整数 T，代表询问的组数。</p>
<p>每组询问包含 3 行：</p>
<p>第一行包含 12 个大写字母，代表外圈从 0 点位置开始顺时针每个塑料棒的颜色。</p>
<p>第二行包含 8 个大写字母，代表中圈从 0 点位置开始顺时针每个塑料棒的颜色。</p>
<p>第三行包含 4 个大写字母，代表内圈从 0 点位置开始顺时针每个塑料棒的颜色。</p>
<p><strong>输出格式</strong><br>对于每组询问，输出一行 YES 或者 NO，代表小明是否可以达成目标。</p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">GYGGGGGGGGGG</span><br><span class="line">RGRRRRRR</span><br><span class="line">YRYY</span><br><span class="line">YGGGRRRRGGGY</span><br><span class="line">YGGGRRRR</span><br><span class="line">YGGG</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>

<p><strong>评测用例规模与约定</strong><br>1≤T≤100</p>
<p><strong>代码实现：</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">3</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++)  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y = <span class="number">0</span>, r = <span class="number">0</span>, g = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = k; s[i][j]; j += <span class="number">4</span>)</span><br><span class="line">                    <span class="keyword">if</span>(s[i][j] == <span class="string">&#x27;Y&#x27;</span>)  y ++;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(s[i][j] == <span class="string">&#x27;R&#x27;</span>)  r ++;</span><br><span class="line">                    <span class="keyword">else</span>  g ++;</span><br><span class="line">            <span class="keyword">if</span>(!(y == <span class="number">1</span> <span class="keyword">and</span> r == <span class="number">2</span> <span class="keyword">and</span> g == <span class="number">3</span>))  flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag)  <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>  <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>practise</category>
      </categories>
      <tags>
        <tag>算法练习</tag>
      </tags>
  </entry>
  <entry>
    <title>于是开始写第一篇博客</title>
    <url>/2021/04/10/my-first-blog/</url>
    <content><![CDATA[<p>从零开始的学习生活</p>
<span id="more"></span>!
<h1 id="以下是代码测试"><a href="#以下是代码测试" class="headerlink" title="以下是代码测试"></a>以下是代码测试</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">print(&quot;Hello</span> <span class="string">World&quot;);</span></span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>第十三届蓝桥杯C/C++ B组省赛</title>
    <url>/2022/04/09/lanqiao2022/</url>
    <content><![CDATA[<p>填空题比较简单略过了，写一下自己写出来的编程题。</p>
<span id="more"></span>  

<h1 id="试题-C-刷题统计"><a href="#试题-C-刷题统计" class="headerlink" title="试题 C: 刷题统计"></a>试题 C: 刷题统计</h1><p><strong>【问题描述】</strong><br>小明决定从下周一开始努力刷题准备蓝桥杯竞赛。他计划周一至周五每天做 a 道题目，周六和周日每天做 b 道题目。请你帮小明计算，按照计划他将在第几天实现做题数大于等于 n 题  </p>
<p>这题应该要按周算，我直接累加了（犯傻）应该只能过50%</p>
<p><strong>输入格式</strong><br>输入一行包含三个整数 a, b 和 n.</p>
<p><strong>输出格式</strong><br>输出一个整数代表天数。    </p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 20 99</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>

<p><strong>评测用例规模与约定</strong><br>对于 50% 的评测用例，1 ≤ a, b, n ≤ 1e6.<br>对于 100% 的评测用例，1 ≤ a, b, n ≤ 1e18  </p>
<p><strong>代码实现：</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a, b, n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; n;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> day = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(cnt &lt; n)&#123;</span><br><span class="line">		day ++;</span><br><span class="line">		<span class="keyword">if</span>(day % <span class="number">7</span> == <span class="number">0</span> || day % <span class="number">7</span> == <span class="number">6</span>) cnt += b;</span><br><span class="line">		<span class="keyword">else</span> cnt += a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, day);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-D-修剪灌木"><a href="#试题-D-修剪灌木" class="headerlink" title="试题 D: 修剪灌木"></a>试题 D: 修剪灌木</h1><p><strong>【问题描述】</strong><br>爱丽丝要完成一项修剪灌木的工作。<br>有 N 棵灌木整齐的从左到右排成一排。爱丽丝在每天傍晚会修剪一棵灌木，让灌木的高度变为 0 厘米。爱丽丝修剪灌木的顺序是从最左侧的灌木开始，每天向右修剪一棵灌木。当修剪了最右侧的灌木后，她会调转方向，下一天开始向左修剪灌木。直到修剪了最左的灌木后再次调转方向。然后如此循环往复。<br>灌木每天从早上到傍晚会长高 1 厘米，而其余时间不会长高。在第一天的早晨，所有灌木的高度都是 0 厘米。爱丽丝想知道每棵灌木最高长到多高。  </p>
<p>找规律</p>
<p><strong>输入格式</strong><br>一个正整数 N ，含义如题面所述。</p>
<p><strong>输出格式</strong><br>输出 N 行，每行一个整数，第行表示从左到右第 i 棵树最高能长到多高。  </p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p><strong>评测用例规模与约定</strong><br>对于 30% 的数据，N ≤ 10.<br>对于 100% 的数据，1 &lt; N ≤ 10000  </p>
<p><strong>代码实现：</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; max(<span class="number">2</span> * (n - i), <span class="number">2</span> * (i - <span class="number">1</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="试题-E-X-进制减法"><a href="#试题-E-X-进制减法" class="headerlink" title="试题 E: X 进制减法"></a>试题 E: X 进制减法</h1><p><strong>【问题描述】</strong><br>进制规定了数字在数位上逢几进一。<br>X 进制是一种很神奇的进制，因为其每一数位的进制并不固定！例如说某种 X 进制数，最低数位为二进制，第二数位为十进制，第三数位为八进制，则X 进制数 321 转换为十进制数为 65。<br>现在有两个 X 进制表示的整数 A 和 B，但是其具体每一数位的进制还不确定，只知道 A 和 B 是同一进制规则，且每一数位最高为 N 进制，最低为二进制。请你算出 A − B 的结果最小可能是多少。<br>请注意，你需要保证 A 和 B 在 X 进制下都是合法的，即每一数位上的数字要小于其进制。  </p>
<p>暴力，不知道能不能全过</p>
<p><strong>输入格式</strong><br>第一行一个正整数 N，含义如题面所述。<br>第二行一个正整数 Ma，表示 X 进制数 A 的位数。<br>第三行 Ma 个用空格分开的整数，表示 X 进制数 A 按从高位到低位顺序各 个数位上的数字在十进制下的表示。<br>第四行一个正整数 Mb，表示 X 进制数 B 的位数。<br>第五行 Mb 个用空格分开的整数，表示 X 进制数 B 按从高位到低位顺序各个数位上的数字在十进制下的表示。<br>请注意，输入中的所有数字都是十进制的。  </p>
<p><strong>输出格式</strong><br>输出一行一个整数，表示 X 进制数 A − B 的结果的最小可能值转换为十进制后再模 1000000007 的结果。    </p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br><span class="line">3</span><br><span class="line">10 4 0</span><br><span class="line">3</span><br><span class="line">1 2 0</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">94</span><br></pre></td></tr></table></figure>

<p><strong>评测用例规模与约定</strong><br>对于 30% 的数据，N ≤ 10; Ma, Mb ≤ 8.<br>对于 100% 的数据，2 ≤ N ≤ 1000; 1 ≤ Ma, Mb ≤ 100000; A ≥ B   </p>
<p><strong>代码实现：</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> numa[N], numb[N];</span><br><span class="line"><span class="keyword">int</span> x[N];</span><br><span class="line"><span class="keyword">int</span> n, ma, mb;</span><br><span class="line"><span class="keyword">int</span> minv = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(step == ma + <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, help = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ma; i ++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(numa[i] &gt;= x[i] || numb[i] &gt;= x[i]) <span class="keyword">return</span>;</span><br><span class="line">			a = (a  + numa[i] * help) % <span class="number">1000000007</span>;</span><br><span class="line">			b = (b  + numb[i] * help) % <span class="number">1000000007</span>;</span><br><span class="line">			help *= x[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> minus = (a - b) % <span class="number">1000000007</span>;</span><br><span class="line">		<span class="keyword">if</span>(minus &lt; minv) minv = minus;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">		x[step] = i;</span><br><span class="line">		dfs(step + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; ma;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = ma; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;numa[i]);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; mb;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = mb; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;numb[i]);</span><br><span class="line">	x[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	dfs(<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; minv &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-F-统计子矩阵"><a href="#试题-F-统计子矩阵" class="headerlink" title="试题 F: 统计子矩阵"></a>试题 F: 统计子矩阵</h1><p><strong>【问题描述】</strong><br>给定一个 N × M 的矩阵 A，请你统计有多少个子矩阵 (最小 1 × 1，最大N × M) 满足子矩阵中所有数的和不超过给定的整数 K?  </p>
<p>二维前缀和+暴力</p>
<p><strong>输入格式</strong><br>第一行包含三个整数 N, M 和 K.<br>之后 N 行每行包含 M 个整数，代表矩阵 A.  </p>
<p><strong>输出格式</strong><br>一个整数代表答案。  </p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4 10</span><br><span class="line">1 2 3 4</span><br><span class="line">5 6 7 8</span><br><span class="line">9 10 11 12</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">19</span><br></pre></td></tr></table></figure>

<p><strong>评测用例规模与约定</strong><br>对于 30% 的数据，N, M ≤ 20.<br>对于 70% 的数据，N, M ≤ 100.<br>对于 100% 的数据，1 ≤ N, M ≤ 500; 0 ≤ Ai j ≤ 1000; 1 ≤ K ≤ 250000000  </p>
<p><strong>代码实现：</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[N][N];</span><br><span class="line"><span class="keyword">int</span> s[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">			s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="built_in">map</span>[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> x1 = <span class="number">1</span>; x1 &lt;= n; x1 ++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> y1 = <span class="number">1</span>; y1 &lt;= m; y1 ++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> x2 = x1; x2 &lt;= n; x2 ++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> y2 = y1; y2 &lt;= m; y2 ++)&#123;</span><br><span class="line">					<span class="keyword">int</span> cnt = s[x2][y2] - s[x2][y1 - <span class="number">1</span>] - s[x1 - <span class="number">1</span>][y2] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>];</span><br><span class="line">					<span class="keyword">if</span>(cnt &lt;= k) res ++;</span><br><span class="line">				&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-G-积木画"><a href="#试题-G-积木画" class="headerlink" title="试题 G: 积木画"></a>试题 G: 积木画</h1><p>之前做过差不多的，忘了，不会，之后再更新  </p>
<h1 id="试题-H-扫雷"><a href="#试题-H-扫雷" class="headerlink" title="试题 H: 扫雷"></a>试题 H: 扫雷</h1><p><strong>【问题描述】</strong><br>小明最近迷上了一款名为《扫雷》的游戏。其中有一个关卡的任务如下，在一个二维平面上放置着 n 个炸雷，第 i 个炸雷 (xi, yi,ri) 表示在坐标 (xi, yi) 处存在一个炸雷，它的爆炸范围是以半径为 ri 的一个圆。<br>为了顺利通过这片土地，需要玩家进行排雷。玩家可以发射 m 个排雷火箭，小明已经规划好了每个排雷火箭的发射方向，第 j 个排雷火箭 (xj, yj,rj) 表示这个排雷火箭将会在 (xj, yj) 处爆炸，它的爆炸范围是以半径为 rj 的一个圆，在其爆炸范围内的炸雷会被引爆。同时，当炸雷被引爆时，在其爆炸范围内的炸雷也会被引爆。现在小明想知道他这次共引爆了几颗炸雷？<br>你可以把炸雷和排雷火箭都视为平面上的一个点。一个点处可以存在多个炸雷和排雷火箭。当炸雷位于爆炸范围的边界上时也会被引爆。</p>
<p>暴力bfs</p>
<p><strong>输入格式</strong><br>输入的第一行包含两个整数 n、m.<br>接下来的 n 行，每行三个整数 xi, yi,ri，表示一个炸雷的信息。<br>再接下来的 m 行，每行三个整数 xj, yj,rj，表示一个排雷火箭的信息。  </p>
<p><strong>输出格式</strong><br>一个整数代表答案。  </p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">2 2 4</span><br><span class="line">4 4 2</span><br><span class="line">0 0 5</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>评测用例规模与约定</strong><br>对于 40% 的评测用例：0 ≤ x, y ≤ 109, 0 ≤ n, m ≤ 103, 1 ≤ r ≤ 10.<br>对于 100% 的评测用例：0 ≤ x, y ≤ 109, 0 ≤ n, m ≤ 5 × 104, 1 ≤ r ≤ 10.</p>
<p><strong>代码实现：</strong> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> xx;</span><br><span class="line">	<span class="keyword">int</span> yy;</span><br><span class="line">	<span class="keyword">int</span> rr;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node h[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; h3[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; h4[N]; </span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> t: h4[x])&#123;</span><br><span class="line">		<span class="keyword">if</span>(!st[t])&#123;</span><br><span class="line">			q.push(t);</span><br><span class="line">			st[t] = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">		<span class="keyword">int</span> t = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		res ++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> i: h3[t])&#123;</span><br><span class="line">			<span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">				q.push(i);</span><br><span class="line">				st[t] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x, y, r;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; r;</span><br><span class="line">		h[i].xx = x;</span><br><span class="line">		h[i].yy = y;</span><br><span class="line">		h[i].rr = r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x1 = h[i].xx;</span><br><span class="line">		<span class="keyword">int</span> y1 = h[i].yy;</span><br><span class="line">		<span class="keyword">int</span> r1 = h[i].rr;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)&#123;</span><br><span class="line">			<span class="keyword">int</span> x2 = h[j].xx;</span><br><span class="line">			<span class="keyword">int</span> y2 = h[j].yy;</span><br><span class="line">			<span class="keyword">if</span>(i != j)&#123;</span><br><span class="line">				<span class="keyword">double</span> dist = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);</span><br><span class="line">				dist = <span class="built_in">sqrt</span>(dist);</span><br><span class="line">				<span class="keyword">if</span>(dist &lt;= r1) h3[i].push_back(j);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x, y, r;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; r;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)&#123;</span><br><span class="line">			<span class="keyword">int</span> x2 = h[j].xx;</span><br><span class="line">			<span class="keyword">int</span> y2 = h[j].yy;</span><br><span class="line">			<span class="keyword">double</span> dist = (x - x2) * (x - x2) + (y - y2) * (y - y2);</span><br><span class="line">			dist = <span class="built_in">sqrt</span>(dist);</span><br><span class="line">			<span class="keyword">if</span>(dist &lt;= r) h4[i].push_back(j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">		bfs(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-I-李白打酒加强版"><a href="#试题-I-李白打酒加强版" class="headerlink" title="试题 I: 李白打酒加强版"></a>试题 I: 李白打酒加强版</h1><p><strong>【问题描述】</strong><br>话说大诗人李白，一生好饮。幸好他从不开车。<br>一天，他提着酒壶，从家里出来，酒壶中有酒 2 斗。他边走边唱：<br>无事街上走，提壶去打酒。<br>逢店加一倍，遇花喝一斗。<br>这一路上，他一共遇到店 N 次，遇到花 M 次。已知最后一次遇到的是花，他正好把酒喝光了。<br>请你计算李白这一路遇到店和花的顺序，有多少种不同的可能？<br>注意：壶里没酒 ( 0 斗) 时遇店是合法的，加倍后还是没酒；但是没酒时遇花是不合法的  </p>
<p>暴力肯定是过不了全部的，应该转换成三维dp，后来懒得想了，直接暴力做的。<br><strong>输入格式</strong><br>第一行包含两个整数 N 和 M  </p>
<p><strong>输出格式</strong><br>输出一个整数表示答案。由于答案可能很大，输出模 1000000007 的结果。     </p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 10</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure>

<p><strong>评测用例规模与约定</strong><br>对于 40% 的评测用例：1 ≤ N, M ≤ 10。<br>对于 100% 的评测用例：1 ≤ N, M ≤ 100。</p>
<p><strong>代码实现：</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span> * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(step == m + n - <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> store = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> flower = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + m - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]) store ++;</span><br><span class="line">			<span class="keyword">else</span> flower ++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(store != n || flower != m - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> e = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + m - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]) e *= <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">else</span> e -= <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(e &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(e == <span class="number">1</span>) res = (res + <span class="number">1</span>) % <span class="number">1000000007</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i ++)&#123;</span><br><span class="line">		a[step] = i;</span><br><span class="line">		dfs(step + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	dfs(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-J-砍竹子"><a href="#试题-J-砍竹子" class="headerlink" title="试题 J: 砍竹子"></a>试题 J: 砍竹子</h1><p><strong>【问题描述】</strong><br>这天，小明在砍竹子，他面前有 n 棵竹子排成一排，一开始第 i 棵竹子的高度为 hi.<br>他觉得一棵一棵砍太慢了，决定使用魔法来砍竹子。魔法可以对连续的一段相同高度的竹子使用，假设这一段竹子的高度为 H，那么使用一次魔法可以把这一段竹子的高度都变为 ⌊ √⌊ H2 ⌋ + 1⌋，其中 ⌊x⌋ 表示对 x 向下取整。小明想知道他最少使用多少次魔法可以让所有的竹子的高度都变为 1。  </p>
<p><strong>输入格式</strong><br>第一行为一个正整数 n，表示竹子的棵数。<br>第二行共 n 个空格分开的正整数 hi，表示每棵竹子的高度。  </p>
<p>感觉使用线段树维护，忘了怎么写，瞎写写暴力方法，不想空着（</p>
<p><strong>输出格式</strong><br>一个整数表示答案。    </p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">2 1 4 2 6 7</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<p><strong>评测用例规模与约定</strong><br>对于 20% 的数据，保证 n ≤ 1000, hi ≤ 10^6。<br>对于 100% 的数据，保证 n ≤ 2 × 105, hi ≤ 10^18  </p>
<p><strong>代码实现：</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> +<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> ban[N];</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;ban[i]);</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> maxv = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">			<span class="keyword">if</span>(maxv &lt; ban[i]) maxv = ban[i];</span><br><span class="line">		<span class="keyword">if</span>(maxv == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">		res ++;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(ban[i] == maxv)&#123;</span><br><span class="line">				ban[i] = <span class="built_in">sqrt</span>(ban[i] / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(flag &amp;&amp; ban[i] != maxv) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>practise</category>
      </categories>
      <tags>
        <tag>算法练习</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记——第二章</title>
    <url>/2021/05/09/os-2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>个人操作系统笔记整理，欢迎参考，时不时更新。  </p>
<span id="more"></span>

<h1 id="第二章-进程管理"><a href="#第二章-进程管理" class="headerlink" title="第二章 进程管理"></a>第二章 进程管理</h1><h2 id="2-1-前趋图和程序执行"><a href="#2-1-前趋图和程序执行" class="headerlink" title="2.1 前趋图和程序执行"></a>2.1 前趋图和程序执行</h2><h3 id="2-1-1-前趋图"><a href="#2-1-1-前趋图" class="headerlink" title="2.1.1 前趋图"></a>2.1.1 前趋图</h3><p>&ensp;&ensp;&ensp;&ensp;前趋图定义<br>&ensp;&ensp;&ensp;&ensp;定义：前趋图是一个有向无循环图,记为 DAG(Directed Acyclic Graph) ，用于描述进程之间执行的前后顺序。<br>&ensp;&ensp;&ensp;&ensp;表示方式：<br>&ensp;&ensp;&ensp;&ensp;（1）p1–&gt;p2<br>&ensp;&ensp;&ensp;&ensp;（2）–&gt;={(p1,p2)| p1 必须在p2开始前完成}<br>&ensp;&ensp;&ensp;&ensp;节点表示：一条语句，一个程序段，一个进程，节点上的权重表示该进程的程序量或执行时间。<br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%871.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;下图就不是前趋图，<strong>前趋图中不应出现循环</strong><br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%872.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;因为存在前趋关系: S2→S3 和 S3 →S2  </p>
<h3 id="2-1-2-程序的顺序执行及其特征"><a href="#2-1-2-程序的顺序执行及其特征" class="headerlink" title="2.1.2 程序的顺序执行及其特征"></a>2.1.2 程序的顺序执行及其特征</h3><p>&ensp;&ensp;&ensp;&ensp;单道程序环境下，程序段执行有固定的时序，仅当前一操作完成后，才能执行后继操作。<br>&ensp;&ensp;&ensp;&ensp;例如，进行计算时，总需要首先输入数据，然后进行计算，最后才能打印计算结果。假如用I表示输入，C表示计算，P表示打印，并且用箭头表示操作的先后次序。则输入数据，计算数据，打印计算结果这样一段程序。<br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%873.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;对于程序段中的多条语句来说，也有一个执行顺序问题，如对于包含下述三条语句的程序段：<br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%874.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;一切顺序执行的程序都具有下列特性：<br>&ensp;&ensp;&ensp;&ensp;（1）顺序性。即每一操作都必须在上一个操作结束之后开始。<br>&ensp;&ensp;&ensp;&ensp;（2）封闭性。程序运行时独占全机资源；资源的状态（除初始状态外）只有本程序才能改变它。程序一旦开始运行，其执行结果不受外界因素影响。<br>&ensp;&ensp;&ensp;&ensp;（3）可再现性。只要执行时的环境和初始条件相同，程序不论是连续执行还是“走走停停”地执行，都将获得相同的结果。  </p>
<h3 id="2-1-3-程序的并发执行及其特征"><a href="#2-1-3-程序的并发执行及其特征" class="headerlink" title="2.1.3 程序的并发执行及其特征"></a>2.1.3 程序的并发执行及其特征</h3><p>&ensp;&ensp;&ensp;&ensp;程序的两种执行方式：顺序执行、并发执行。<br>&ensp;&ensp;&ensp;&ensp;现在的操作系统多为并发执行（多道处理系统），具有许多新的特征。<br>&ensp;&ensp;&ensp;&ensp;引入并发执行的目的是为了<strong>提高资源利用率</strong>。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>并发</strong>与<strong>并行</strong>概念的区别：<br>&ensp;&ensp;&ensp;&ensp;concurrency,parallel</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.程序的并发执行</strong><br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%875.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;该例中存在下述前趋关系：<br>&ensp;&ensp;&ensp;&ensp;Ii→Ci ，Ii→Ii+1 ， Ci→Pi， Ci→Ci+1， Pi→Pi+1<br>&ensp;&ensp;&ensp;&ensp;而Ii+1和Ci及Pi-1是重迭的，亦即Ii+1和Ci及Pi-1可以并发执行。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.并发程序的特征</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）间断性：进程“时走时停”<br>&ensp;&ensp;&ensp;&ensp;（2）非封闭性：多个程序共享资源<br>&ensp;&ensp;&ensp;&ensp;（3）不可再现性：由于失去了封闭性，也失去了可在现性  </p>
<p>&ensp;&ensp;&ensp;&ensp;例：有2个循环程序A和B，它们共享变量N；<br>&ensp;&ensp;&ensp;&ensp;程序A：N=N+1；程序B: Print(N)；N=0<br>&ensp;&ensp;&ensp;&ensp;若程序A,B以不同的速度运行有以下三种不同的结果（假定某时刻变量Ｎ的值为ｎ）  </p>
<p>&ensp;&ensp;&ensp;&ensp;N:=N+1在Print(N)和N=0之前，得到的N值分别为：n+1, n+1, 0<br>&ensp;&ensp;&ensp;&ensp;N:=N+1在Print(N)和N=0之后，得到的N值分别为：n, 0, 1<br>&ensp;&ensp;&ensp;&ensp;N:=N+1在Print(N)和N=0之间，得到的N值分别为：n, n+1, 0  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.顺序执行与并发执行特征对比</strong><br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%876.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;程序的并发执行引发的问题  </p>
<ul>
<li>如何协调各程序的执行顺序？</li>
<li>多个执行程序共享系统资源，程序之间可能会相互影响，甚至影响输出结果。</li>
<li>选择哪些、多少个程序进入内存执行？</li>
<li>内存中的执行程序谁先执行？</li>
<li>内存如何有效分配？           </li>
</ul>
<h2 id="2-2-进程的描述"><a href="#2-2-进程的描述" class="headerlink" title="2.2 进程的描述"></a>2.2 进程的描述</h2><h3 id="2-2-1-进程的定义和特征"><a href="#2-2-1-进程的定义和特征" class="headerlink" title="2.2.1 进程的定义和特征"></a>2.2.1 进程的定义和特征</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.进程的定义</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;通常的<strong>程序</strong>不能参与并发执行，为了让程序能并发执行，人们引入<strong>进程</strong>的概念对并发执行的程序加以描述和控制。<br>&ensp;&ensp;&ensp;&ensp;比较典型的进程定义有：<br>&ensp;&ensp;&ensp;&ensp;⑴进程是程序的一次执行。<br>&ensp;&ensp;&ensp;&ensp;⑵进程是一个程序及其数据在处理机上顺序执行时所发生的活动。<br>&ensp;&ensp;&ensp;&ensp;⑶进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。<br>&ensp;&ensp;&ensp;&ensp;本教材定义进程为：<strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</strong><br>&ensp;&ensp;&ensp;&ensp;资源分配：获得除了处理机以外的资源<br>&ensp;&ensp;&ensp;&ensp;资源调度：获得处理机资源  </p>
<p>&ensp;&ensp;&ensp;&ensp;进程与程序<br>&ensp;&ensp;&ensp;&ensp;程序：静态概念，是指令和数据的集合，可长期存储。<br>&ensp;&ensp;&ensp;&ensp;进程与程序对应关系：<br>&ensp;&ensp;&ensp;&ensp;一个程序可以对应一个进程或多个进程。<br>&ensp;&ensp;&ensp;&ensp;一个进程可以对应一个程序，或者一段程序。<br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%877.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;引入进程带来的问题<br>&ensp;&ensp;&ensp;&ensp;1）增加了空间开销：为进程建立数据结构<br>&ensp;&ensp;&ensp;&ensp;2）额外的时间开销：管理和协调、跟踪、填写和更新有关数据结构、切换进程、保护现场。<br>&ensp;&ensp;&ensp;&ensp;3）更难控制：<br>&ensp;&ensp;&ensp;&ensp;①协调多个进程竞争和共享资源。<br>&ensp;&ensp;&ensp;&ensp;②预防解决多个进程因为竞争资源而出现故障。<br>&ensp;&ensp;&ensp;&ensp;③处理机的竞争尤为突出。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.进程的特征</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）动态性：动态性是进程的最基本特征。表现在，进程由创建而产生，由调度而执行，由撤销而消亡。即进程具有一定的生命周期。（而程序是静态的）。<br>&ensp;&ensp;&ensp;&ensp;2）独立性：各进程的地址空间相互独立，互不干扰。<br>&ensp;&ensp;&ensp;&ensp;3）并发性：指多个进程实体同存于内存中，且能在一段时间内同时运行。并发性是进程的重要特征。<br>&ensp;&ensp;&ensp;&ensp;4）异步性：指进程按各自独立的、不可预知的速度向前推进  </p>
<p>&ensp;&ensp;&ensp;其它：<br>&ensp;&ensp;&ensp;&ensp;1）为使程序能独立运行，为之配置一进程控制块，即PCB（Process Control Block)。<br>&ensp;&ensp;&ensp;&ensp;2）进程是一个动态的实体，随着程序中指令的执行而不断地变化。在某个时刻进程的内容被称为进程映像。<br>&ensp;&ensp;&ensp;&ensp;3）进程由程序段、相关数据段和PCB三部分构成。  </p>
<h3 id="2-2-2-进程的基本状态及其转换"><a href="#2-2-2-进程的基本状态及其转换" class="headerlink" title="2.2.2 进程的基本状态及其转换"></a>2.2.2 进程的基本状态及其转换</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.进程的三种基本状态</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）就绪状态：进程已分配到除CPU以外的所有必要资源，只要获得CPU，便可立即执行，此时的状态称为就绪状态。一个系统中处于就绪状态的进程有多个，通常排成一个就绪队列。<br>&ensp;&ensp;&ensp;&ensp;2）执行状态：进程已获得CPU，其程序正在执行。单处理机系统中，只有一个进程在执行；多处理机系统中，可以是多个进程在同时执行。<br>&ensp;&ensp;&ensp;&ensp;3）阻塞状态：正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，这种状态称为阻塞状态（等待状态或封锁状态）。处于阻塞状态的进程也可排成队列。导致进程阻塞的事件有：请求I/O，申请缓冲空间等。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.三种基本状态的转换</strong> </p>
<p>&ensp;&ensp;&ensp;&ensp;进程在运行过程中灰经常发生状态的转换。例如，处于就绪状态的进程，在调度程序为之分配了处理及之后便可执行，相应地，其状态就由就绪态转变为执行态；正在执行的进程如果因分配给它的时间片已完而被剥夺处理机暂停执行时，其状态便由执行态转为就绪；如果因发生某事件，致使当前进程的执行受阻（如进程访问某临界资源，而该资源正在被其它进程访问时），则该进程状态将由执行变为阻塞。<br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%878.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.进程的创建状态和终止状态</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）创建状态  </p>
<p>&ensp;&ensp;&ensp;&ensp;创建过程一般包括多个步骤：①首先，为一个新进程创建PCB，并填写必要的管理信息；②然后为该进程分配运行时必须的资源；③最后把该进程转让就绪状态并插入就绪队列中。当新进程被创建时，如果该进程所必需的资源或其它信息，如主存资源尚未分配等。此时，<strong>进程已拥有了自己的PCB，但进程自身还未进入主存</strong>，即创建工作尚未完成，进程还不能被调度运行。<strong>该状态即为创建状态</strong>。  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）终止状态<br>&ensp;&ensp;&ensp;&ensp;进程的终止包含两个步骤：①首先，等待操作系统进行善后处理，②然后将其PCB清零，并将PCB空间返还系统。<br>&ensp;&ensp;&ensp;&ensp;如果进程到达了自然结束点，或出现了无法克服的错误，或被操作系统所终结，或是被其他有终止权的进程所终结，将进入终止状态。<br>&ensp;&ensp;&ensp;&ensp;虽然进入终止状态的进程不能再执行，但是在操作系统中依然保留一个记录，其中保持状态码和一些计时统计数据，供其他进程收集。一旦其他进程完成了对终止状态进程的信息提取之后，操作系统将删除该进程。<br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%879.png">   </p>
<h3 id="2-2-3-挂起操作和进程状态的转换"><a href="#2-2-3-挂起操作和进程状态的转换" class="headerlink" title="2.2.3 挂起操作和进程状态的转换"></a>2.2.3 挂起操作和进程状态的转换</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.挂起操作的引入</strong>  </p>
<p>挂起：当该操作作用于某个进程时，该进程将被挂起，意味着此时此刻该进程处于静止状态。如果进程正在执行。它将暂停执行。若原本处于就绪状态，则该进程此时暂不接受调度。与挂起操作相对应的操作是激活操作。<br>&ensp;&ensp;&ensp;&ensp;引入挂起操作的原因：  </p>
<ul>
<li>终端用户的请求：终端用户在自己的程序运行期间发现有可疑问题时，希望暂时使自己的程序静止下来。这种静止状态就是挂起状态。</li>
<li>父进程请求：父进程要求挂起自己的子进程，以便考查和修改；</li>
<li>负荷调节的需要：实时系统中负荷较重时，系统会把一些不重要的进程挂起；</li>
<li>操作系统的需要：操作系统希望挂起一些进程，以便检查运行中的资源使用情况。</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;挂起（Suspend）：把一个进程从内存转到外存；<br>&ensp;&ensp;&ensp;&ensp;激活（Activate）：把一个进程从外存转到内存；  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.引入挂起原语操作后三个进程状态的转换</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;活动就绪：进程在主存中并可以执行<br>&ensp;&ensp;&ensp;&ensp;活动阻塞：进程在主存中并等待一个事件<br>&ensp;&ensp;&ensp;&ensp;静止就绪：进程在辅存中，只要被载入主存就可以执行<br>&ensp;&ensp;&ensp;&ensp;静止阻塞：进程在辅存中并等待一个事件  </p>
<p>&ensp;&ensp;&ensp;&ensp;进程状态的转换<br>&ensp;&ensp;&ensp;&ensp;活动就绪 -&gt; 静止就绪<br>&ensp;&ensp;&ensp;&ensp;活动阻塞 -&gt; 静止阻塞<br>&ensp;&ensp;&ensp;&ensp;静止就绪 -&gt; 活动就绪<br>&ensp;&ensp;&ensp;&ensp;静止阻塞 -&gt; 活动阻塞<br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%8710.png">    </p>
<p><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%8711.png">  </p>
<h3 id="2-2-4-进程管理中的数据结构"><a href="#2-2-4-进程管理中的数据结构" class="headerlink" title="2.2.4 进程管理中的数据结构"></a>2.2.4 进程管理中的数据结构</h3><p>&ensp;&ensp;&ensp;&ensp;一方面为了<strong>便于管理计算机资源，OS将它们抽象为各种数据结构</strong>，以及提供一组对资源进行<strong>操作</strong>的命令，用户可以通过这些数据结构和命令来执行相关操作。<br>&ensp;&ensp;&ensp;&ensp;另一方面，OS作为计算机资源的管理者，为了协调用户共享资源，它还<strong>需记录和查询各种资源的使用以及各类进程的运行情况信息。</strong>OS对于这些信息的组织和维护也是通过建立和维护各种数据结构的方式实现的。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.操作系统中用于管理控制的数据结构</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;计算机系统对每个资源和进程都设置了一个数据结构，称之为资源信息表或进程信息表，其中包含了资源或进程的标识，描述，状态等信息以及一批指针。<br>&ensp;&ensp;&ensp;&ensp;OS管理的这些数据结构一般可分为四类：内存表，设备表、文件表和进程表，其中进程表又称作进程控制块PCB。本章着重介绍PCB。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.进程控制块PCB的作用</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）<strong>作为独立运行的基本单位的标志。</strong>当一个程序配置了PCB后，就表示它是一个能在多道环境下独立运行的基本单位。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）<strong>能实现间断性运行方式。</strong>当程序阻塞时，保存现场，进程被再度调用时恢复现场。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（3）<strong>提供进程管理所需要的信息。</strong>在进程的整个生命周期，OS根据PCB实施对进程的控制和管理。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（4）<strong>提供进程调度所需要的信息。</strong>PCB提供了进程处于何种状态的信息，供进程调度使用。   </p>
<p>&ensp;&ensp;&ensp;&ensp;（5）<strong>实现与其它进程的同步与通信。</strong>PCB中具有用于实现进程同步的信号量和进程通信的区域或通信队列指针。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.进程管理块中的信息</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;（1）进程标识符。用于唯一的标识一个进程。<br>&ensp;&ensp;&ensp;&ensp;内部标识符：方便系统对进程的使用。在所有的操作系统中，都为每一个进程赋予一个唯一的数字标识符，它通常是一个进程的序号。<br>&ensp;&ensp;&ensp;&ensp;外部标识符：方便用户对进程的访问。由创建者提供，通常由字母数字组成。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）处理机状态信息。主要是由处理机的各种寄存器中的内容组成的。 处理机运行时，许多信息都存放在寄存器中。当处理机被中断时，所有这些信息都必须保存在PCB中，以便该进程重新执行时，能从断点继续执行。这些寄存器包括：①<strong>通用寄存器</strong>：用户可视寄存器，用于暂存信息，用户程序可以访问（8-32）②<strong>指令计数器</strong>：存放了要访问的下一条指令的地址；③<strong>程序状态字PSW</strong>:  其中包含了状态信息，如条件码、执行方式、终端屏蔽标志等；④<strong>用户栈指针</strong>：每个用户进程都有一个或若干个与之相关的系统栈，用于存放过程和系统调用参数及调用地址。栈指针指向栈顶。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（3）进程调度信息。在PCB中还存放一些与进程调度的信息，包括：①<strong>进程状态</strong>：指明进程的当前状态，作为进程调度和对换时的依据；②<strong>进程优先级</strong>：优先级高的进程应先获得处理机③<strong>进程调度所需的其它信息</strong>：与所采用的进程调度算法有关，比如，进程已等待CPU的时间总和、进程已执行的时间总和等；④<strong>事件</strong>：即阻塞原因，指进程由执行状态转变为阻塞状态所等待发生的事件。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（4）进程控制信息。①<strong>程序和数据的地址</strong>: 指进程的程序和数据所在的内存或外存地址，以便再调度到该程序执行时，能从PCB中找到其程序和数据；②<strong>进程同步和通信机制</strong>:指实现进程同步和通信必需的机制，如消息队列指针、信号量等；③<strong>资源清单</strong>：是一张列出了使用CPU以外的、进程所需的全部资源及已经分配到该进程的资源的清单；④<strong>链接指针</strong>：它给出了本进程（PCB）所在队列中的下一个进程的PCB的首地址。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.进程控制块的组织方式</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;为了能对系统中多个PCB有效的管理，应该用适当的方式将这些PCB组织起来。目前常用的方式有三种：  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）线性方式，即将所有的PCB组织在一张线性表中，将该表的首地址放在内存的一个专用区域中。<br>&ensp;&ensp;&ensp;&ensp;（2）链接方式，把具有相同状态进程的PCB链接成一个队列，诸如就绪队列，阻塞队列等。<br>&ensp;&ensp;&ensp;&ensp;（3）索引方式，根据所有进程状态的不同，建立几张索引表，例如就绪索引表，阻塞索引表等，并把各个索引表在内存的首地址记录在内存的一些专用单元中。在每个索引表的表项中，记录具有相应状态的某个PCB在PCB表中的地址。</p>
<h2 id="2-3-进程控制"><a href="#2-3-进程控制" class="headerlink" title="2.3 进程控制"></a>2.3 进程控制</h2><p>&ensp;&ensp;&ensp;&ensp;进程控制是进程管理中最基本的功能。它用于创建一个新进程，终止一个进程，还有负责进程运行中的状态转换。进程控制一般由OS的内核来完成。<br>&ensp;&ensp;&ensp;&ensp;进程控制一般由OS的内核中的原语来实现。<br>&ensp;&ensp;&ensp;&ensp;原语（Primitive）：是由若干条指令组成的，用于完成一定功能的一个过程。它是原子操作（Action Operation），指一个操作中的所有动作要么全做，要么全不做。是一个不可分割的基本单位，执行过程中不允许中断。原子操作需要常驻内存。  </p>
<h3 id="2-3-1-操作系统内核"><a href="#2-3-1-操作系统内核" class="headerlink" title="2.3.1 操作系统内核"></a>2.3.1 操作系统内核</h3><p>&ensp;&ensp;&ensp;&ensp;现代操作系统一般分为若干层次，通常将与硬件关系紧密的模块，各种常用设备的驱动以及运行频率较高的模块安排在紧靠硬件的软件层次中，将它们常驻内存，即所谓的OS内核。<br>&ensp;&ensp;&ensp;&ensp;安排原因：<br>&ensp;&ensp;&ensp;&ensp;对这些软件进行保护，防止遭受其它应用程序的破坏<br>&ensp;&ensp;&ensp;&ensp;可以提高OS的运行效率  </p>
<p>&ensp;&ensp;&ensp;&ensp;对应内核，处理机的执行状态分为系统态和用户态。<br>&ensp;&ensp;&ensp;&ensp;系统态：又称为管态，也称为内核态。它具有较高的特权，能执行一切指令，访问所有寄存器和存储区，传统的OS都在系统态运行。<br>&ensp;&ensp;&ensp;&ensp;用户态：又称为目态。它具有较低的特权，仅能执行规定的指令，访问指定的寄存器和存储区。<br>&ensp;&ensp;&ensp;&ensp;一般情况下，应用程序只能在<strong>用户态</strong>运行。  </p>
<p>&ensp;&ensp;&ensp;&ensp;OS内核功能：<br>&ensp;&ensp;&ensp;&ensp;1）支撑功能：提供给OS其它众多模块所需的一些基本功能，以便支撑这些模块工作。三种最基本的支撑功能是：①中断处理，②时钟管理和③原语操作。<br>&ensp;&ensp;&ensp;&ensp;2）资源管理功能：包含①进程管理，存储器管理和设备管理。  </p>
<h3 id="2-3-2-进程的创建"><a href="#2-3-2-进程的创建" class="headerlink" title="2.3.2 进程的创建"></a>2.3.2 进程的创建</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.进程的层次结构</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;在OS中，允许一个进程创建子进程，通常把创建进程的进程称为父进程，而被创建的进程称为子进程。子进程可以继续创建更多的孙进程，由此形成进程的层次结构。（Unix系统）<br>&ensp;&ensp;&ensp;&ensp;在windows中不存在进程的层次结构概念，所有的进程具有相同地位。一个进程创建另外进程时获得了一个句柄用来控制被创建的进程。但句柄是可以传递的。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.进程图</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;进程图：进程图是一个有向树，用来描述进程的家族关系<br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%8712.png"><br>&ensp;&ensp;&ensp;&ensp;子进程可继承父进程所分配到的资源；<br>&ensp;&ensp;&ensp;&ensp;子进程运行完毕后，将资源归还给父进程；<br>&ensp;&ensp;&ensp;&ensp;撤销父进程时，其所有的子进程也随之撤销。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.引起进程创建的事件</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）用户登录 在分时系统中，用户在终端键入登录命令后，如果是合法用户，系统将为该终端建立一个进程，并把它插入到就绪队列中。  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）作业调度 在批处理系统中，当作业调度程序按一定的算法调度到某作业时，便将该作业装入内存，为它分配必要的资源，并立即为它创建进程，再插入到就绪队列中。  </p>
<p>&ensp;&ensp;&ensp;&ensp;3）提供服务 当运行中的用户程序提出某种请求后，系统将专门创建一个进程来提供用户所需要的服务。例如，运行过程中要求打印，系统会创建一个打印进程与该用户进程并发执行。  </p>
<p>&ensp;&ensp;&ensp;&ensp;4）应用请求 指的是基于应用程序的需求，为它创建一个新进程，以便使新进程以并发运行方式完成特定任务。通过这种方式可以使得几个操作并发执行，以加速任务的完成。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.进程创建</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;一旦操作系统发现了要求创建进程的事件后，便调用进程创建原语Creat( )来创建进程。进程的创建需要经历以下步骤：<br>&ensp;&ensp;&ensp;&ensp;①申请空白PCB：为新进程分配一个唯一的进程ID,并申请一个空白的PCB。<br>&ensp;&ensp;&ensp;&ensp;②为新进程分配资源：为进程的程序代码、数据用户栈分配内存空间。<br>&ensp;&ensp;&ensp;&ensp;③初始化进程控制块：<br>&ensp;&ensp;&ensp;&ensp;（1）初始化标识信息，将系统分配的进程ID、父进程ID写入PCB。<br>&ensp;&ensp;&ensp;&ensp;（2）初始化处理机状态信息，将程序计数器指向程序的入口地址、栈指针指向栈顶。<br>&ensp;&ensp;&ensp;&ensp;（3）初始化处理机控制信息，设置进程状态、优先级等。  </p>
<p>&ensp;&ensp;&ensp;&ensp;④将新进程插入到就绪队列<br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%8713.png">   </p>
<h3 id="2-3-3-进程的终止"><a href="#2-3-3-进程的终止" class="headerlink" title="2.3.3 进程的终止"></a>2.3.3 进程的终止</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.引起进程终止的事件</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）正常结束<br>&ensp;&ensp;&ensp;&ensp;2）异常结束 指的是出现某些错误和故障而迫使进程终止。常见的异常有：越界错误；保护错；非法指令；特权指令错；运行超时；等待超时；算术运算错和I/O故障。<br>&ensp;&ensp;&ensp;&ensp;3）外界干预   指的是进程应外界的请求而终止执行。常见的干预包括：操作员或操作系统干预；父进程请求；父进程终止等。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.进程终止过程</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;1）根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态；  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度；  </p>
<p>&ensp;&ensp;&ensp;&ensp;3）若该进程还有子孙进程，还应将其所有子孙进程予以终止，以防他们成为不可控制的进程；  </p>
<p>&ensp;&ensp;&ensp;&ensp;4）将被终止进程所拥有的全部资源，或者归还给父进程，或者归还给系统；  </p>
<p>&ensp;&ensp;&ensp;&ensp;5）将被终止进程（它的PCB）从所在队列（或链表）中移出，等待其他程序来搜集信息。  </p>
<h3 id="2-3-4-进程的阻塞与唤醒"><a href="#2-3-4-进程的阻塞与唤醒" class="headerlink" title="2.3.4 进程的阻塞与唤醒"></a>2.3.4 进程的阻塞与唤醒</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.引起进程阻塞和唤醒的事件</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;1）请求共享资源失败 由于操作系统不能马上满足进程的请求，导致进程只能转变为阻塞状态等待；<br>&ensp;&ensp;&ensp;&ensp;2）等待某种操作的完成 如果某进程必须在一个已启动的操作完成后才能继续执行，则必须先将该进程阻塞，以等待该操作的完成；<br>&ensp;&ensp;&ensp;&ensp;3）新数据尚未到达；<br>&ensp;&ensp;&ensp;&ensp;4）等待新任务的到达 系统往往设置一些具有某种特定功能的系统进程，每当这种进程完成任务后，便把自己阻塞起来以等待新任务到来  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.进程阻塞过程</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;进程可通过调用阻塞原语block把自己阻塞。阻塞过程为：<br>&ensp;&ensp;&ensp;&ensp;1）调用block原语；<br>&ensp;&ensp;&ensp;&ensp;2）停止当前进程的执行；把PCB中的状态由“执行”改为“阻塞”；<br>&ensp;&ensp;&ensp;&ensp;3）将PCB插入到阻塞队列；<br>&ensp;&ensp;&ensp;&ensp;4）转调度程序进行重新调度，保留被阻塞进程的处理机状态<br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%8714.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.进程唤醒过程</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;当被阻塞进程所期待的事件出现时，如I/O完成或其所期待的数据已经到达，则由有关进程（比如，用完并释放了该I/O设备的进程）调用唤醒原语wakeup( )，将等待该事件的进程唤醒。其执行过程为：  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）把被阻塞进程从等待该事件的阻塞队列中移出，将其PCB中的现行状态由阻塞改为就绪；<br>&ensp;&ensp;&ensp;&ensp;2）将该PCB插入到就绪队列中。  </p>
<h3 id="2-3-5-进程的挂起与激活"><a href="#2-3-5-进程的挂起与激活" class="headerlink" title="2.3.5 进程的挂起与激活"></a>2.3.5 进程的挂起与激活</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.进程的挂起</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;当出现了引起进程挂起的事件时，系统将利用挂起原语suspend( )将指定进程或处于阻塞状态的进程挂起。其执行过程为：  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）检查被挂起进程的状态，若处于活动就绪状态，则将其改为静止就绪；对于活动阻塞状态的进程，则将其改为静止阻塞。<br>&ensp;&ensp;&ensp;&ensp;2)把该进程的PCB复制到某指定的内存区域；<br>&ensp;&ensp;&ensp;&ensp;3)若被挂起的进程正在执行，则转向调度程序重新调度。<br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%8715.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.进程的激活</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;当发生激活进程的事件时，则可将在外存上处于静止就绪状态的进程换入内存。系统利用激活原语active( )将指定进程激活。其激活过程如下：  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）将进程从外存调入内存；<br>&ensp;&ensp;&ensp;&ensp;2）检查该进程的现行状态，若是静止就绪，便将之改为活动就绪；若为静止阻塞，则将其改为活动阻塞。<br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%8716.png">     </p>
<h2 id="2-4-进程同步"><a href="#2-4-进程同步" class="headerlink" title="2.4 进程同步"></a>2.4 进程同步</h2><p>&ensp;&ensp;&ensp;&ensp;同步：并发进程在执行次序上的协调，以达到有效的资源共享和相互合作，使程序执行有可再现性。  </p>
<h3 id="2-4-1-进程同步的基本概念"><a href="#2-4-1-进程同步的基本概念" class="headerlink" title="2.4.1 进程同步的基本概念"></a>2.4.1 进程同步的基本概念</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.两种形式的制约关系</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在多道程序环境下，当程序并发执行时，可能存在以下两种形式的制约关系：</p>
<p>&ensp;&ensp;&ensp;&ensp;①间接制约关系：同处于一个系统的进程，必然共享着某种系统资源，如CPU, I/O等。间接制约关系源于这种资源共享。</p>
<p>&ensp;&ensp;&ensp;&ensp;②直接制约关系：这种制约关系主要源于进程间的合作。</p>
<p>&ensp;&ensp;&ensp;&ensp;间接制约：进行竞争－－独占分配到的部分或全部的共享资源，“互斥”<br>&ensp;&ensp;&ensp;&ensp;直接制约：进行协作－－等待来自其他进程的信息，“同步”  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.临界资源(Critical Resouce)</strong> </p>
<p>&ensp;&ensp;&ensp;&ensp;在一段时间内只允许一个进程访问的资源，即仅当一个进程访问完并释放该资源后，才允许另一个进程访问的资源，称为临界资源或独占资源。如：打印机、磁带机、共享变量、队列等。  </p>
<p>&ensp;&ensp;&ensp;&ensp;生产者－消费者问题：<br>&ensp;&ensp;&ensp;&ensp;生产者投放一个产品后，输入指针in加1：in = ( in + 1 ) % n （n是缓冲区个数，整型常量），in初值为0； 消费者每取出一个产品，输出指针out加1：out = ( out + 1 ) % n，out初值为0；<br>&ensp;&ensp;&ensp;&ensp;引入一个共享变量counter,初值为0。<br>&ensp;&ensp;&ensp;&ensp;▲生产者投放一个产品，counter加1，counter = n时不能再投放产品<br>&ensp;&ensp;&ensp;&ensp;▲消费者每取一个产品，counter减1，counter = 0时不能再取出产品   </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Var n： integer;   缓冲区的个数</span><br><span class="line">Type item=…;</span><br><span class="line">var buffer:<span class="built_in">array</span>[<span class="number">0</span>,<span class="number">1</span>,…,n<span class="number">-1</span>] of item;</span><br><span class="line">in, out: <span class="number">0</span>,<span class="number">1</span>, …, n<span class="number">-1</span>;</span><br><span class="line">counter: <span class="number">0</span>,<span class="number">1</span>,…,n; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">producer()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		produce an item in nextp;</span><br><span class="line">              …</span><br><span class="line">		<span class="keyword">while</span>(counter==n) no-op;</span><br><span class="line">		buffer[in]=nextp;</span><br><span class="line">		in:=(in+<span class="number">1</span>)% n;</span><br><span class="line">		counter++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(counter==<span class="number">0</span>) no-op;</span><br><span class="line">		nextc=buffer[out];</span><br><span class="line">		out=(out+<span class="number">1</span>) % n;</span><br><span class="line">		counter--;</span><br><span class="line">		consumer the item in nextc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&ensp;&ensp;&ensp;&ensp;<strong>3.临界区(Critical Section)</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;Critical section:把每个进程中访问临界资源的那段<strong>代码</strong>叫临界区(Critical Section)。只要每个进程互斥进入临界区、便可以实现对临界资源的互斥访问。<br>算法:  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	entry section; <span class="comment">//进入区：用于检查临界资源是否空闲，有无进程进入</span></span><br><span class="line">	critical section;</span><br><span class="line">	<span class="built_in">exit</span> section; <span class="comment">//退出区：用于释放临界资源，将访问标志复位</span></span><br><span class="line">	remainder section;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;<strong>4.同步机制遵循的规则（进入临界区的准则）</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）空闲让进：当临界资源空闲时，允许一个进程进入临界区。<br>&ensp;&ensp;&ensp;&ensp;2）忙则等待：临界资源正被访问时，其它进程必须等待，以保证对临界资源的互斥访问。<br>&ensp;&ensp;&ensp;&ensp;3）有限等待：应保证进程能在有限时间内能进入自己的临界区，以免陷入“死等”。<br>&ensp;&ensp;&ensp;&ensp;4）让权等待：如果进程不能进入自己的临界区、应立即释放处理机，以免陷入“忙等”。  </p>
<h3 id="2-4-2-硬件同步机制"><a href="#2-4-2-硬件同步机制" class="headerlink" title="2.4.2 硬件同步机制"></a>2.4.2 硬件同步机制</h3><p>&ensp;&ensp;&ensp;&ensp;虽然可以利用软件方法解决诸进程互斥进入临界区的问题，但有一定难度，并且存在很大的局限性，因而现在已很少采用。相应地，目前许多计算机已提供了一些特殊的硬件指令，允许对一个字中的内容进行检测和修正，或者是对两个字的内容进行交换等。可利用这些特殊的指令来解决临界区问题。实际上，在对临界区进行管理时，可以将标志看作一个锁，“锁开”进入，“锁关”等待，初始时锁是打开的。每个要进入临界区的进程必须先对锁进行测试，当锁未开时，则必须等待，直至锁被打开。反之，当锁是打开的时候，则应立即把其锁上，以阻止其它进程进入临界区。显然，为防止多个进程同时测试到锁为打开的情况，测试和关锁操作必须是连续的，不允许分开进行。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.关中断</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;实现方法：<br>&ensp;&ensp;&ensp;&ensp;在单处理机环境下，在进入临界区之后，关闭中断，直到离开临界区再打开中断。  </p>
<p>&ensp;&ensp;&ensp;&ensp;优点：<br>&ensp;&ensp;&ensp;&ensp;①进程在临界区执行期间，计算机不响应中断，不会引发调度，不会发生进程切换或线程切换。<br>&ensp;&ensp;&ensp;&ensp;②保证了对锁的测试和关锁操作的连续性和完整性，有效地保证了互斥。<br>&ensp;&ensp;&ensp;&ensp;缺点：<br>&ensp;&ensp;&ensp;&ensp;①滥用关中断权力可能导致严重后果；<br>&ensp;&ensp;&ensp;&ensp;②关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力；<br>&ensp;&ensp;&ensp;&ensp;③关中断方法也不适用于多CPU系统，因为，在一个处理器上关中断，并不能防止进程在其它处理器上执行相同临界段代码。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.利用Test-and-Set指令实现互斥</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;方法：<br>&ensp;&ensp;&ensp;&ensp;借助一条硬件指令“测试并建立”指令TS（Test-and-Set），该指令看作为一条原语。为每个临界资源设置一个布尔变量lock，lock初值为false，表示该临界资源空闲。TS指令的一般性描述：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">TS</span><span class="params">(boolean *lock)</span></span>&#123;</span><br><span class="line">    boolean old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock = TRUE;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;如果不能进入临界区，进行循环测试，TS指令实现互斥的循环结构描述：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="keyword">while</span> <span class="title">TS</span><span class="params">(&amp;lock)</span></span>;</span><br><span class="line">    cirtical section;</span><br><span class="line">    lock=FALSE;</span><br><span class="line">…</span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE)</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 利用Swap指令实现进程互斥</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;含义:对换指令，在Intel 80x86又称为XCHG指令，用于交换两个字的内容。其处理过程描述如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(boolean *a, boolean *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	boolean temp;</span><br><span class="line">	temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;互斥访问临界资源的方法:<br>&ensp;&ensp;&ensp;&ensp;为每个临界资源设置一个全局的布尔变量lock，其初值为false，在每个进程中再利用一个局部布尔变量key。利用Swap指令实现进程互斥的循环进程:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    key=TRUE;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        swap(&amp;lock, &amp;key);</span><br><span class="line">       &#125; <span class="keyword">while</span> (key!=FALSE)</span><br><span class="line">   critical section;</span><br><span class="line">   lock=FALSE;</span><br><span class="line">   …</span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;利用硬件指令的出现的问题:<br>&ensp;&ensp;&ensp;&ensp;“忙等”，即进程在进入不了临界区时，不放弃处理器，而不断地进行测试。<br>&ensp;&ensp;&ensp;&ensp;结果:<br>&ensp;&ensp;&ensp;&ensp;不符合“让权等待”，造成处理机浪费<br>&ensp;&ensp;&ensp;&ensp;解决方法:<br>&ensp;&ensp;&ensp;&ensp;信号量机制    </p>
<h3 id="2-4-3-信号量机制"><a href="#2-4-3-信号量机制" class="headerlink" title="2.4.3 信号量机制"></a>2.4.3 信号量机制</h3><p>&ensp;&ensp;&ensp;&ensp;原理：进程通过传递信号进行合作，可迫使某进程在某个位置暂时停止执行（阻塞等待），直到它收到一个可以“向前推进”的信号（被唤醒）。<br>&ensp;&ensp;&ensp;&ensp;信号量(Semaphores)是一种卓越的进程同步工具。目前有：整型信号量、记录型信号量和信号量集。<br>&ensp;&ensp;&ensp;&ensp;信号量可以用于单处理机、多处理机和网络中的互斥访问问题。<br>&ensp;&ensp;&ensp;&ensp;信号量机制是由Dijkstra提出的一种实现进程同步与互斥的通用方法，包括信号量s以及对信号量的两个原子操作wait和signal。早期这两个原语被称为P(s),V(s)操作。（P、V分别是荷兰语的pass(passeren)和increment(verhoog) 。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 整型信号量</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;最初由Dijkstra把整型信号量定义为一个用于表示资源数目的整型量S，它与一般整型量不同，除初始化外，仅能通过两个标准的原子操作wait和signal来访问（即P、V）。</p>
<p>&ensp;&ensp;&ensp;&ensp;(1)定义一个信号量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var s:semaphore=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;(2)等待信号量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Wait(s)&#123;</span><br><span class="line">	<span class="keyword">while</span>(s&lt;= <span class="number">0</span>) ;</span><br><span class="line">	s--;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;(3)通知信号量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">signal(s)&#123;</span><br><span class="line">	s++;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 记录型信号量</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;因整型机制不断测试不满足“让权等待”而引入  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span> value;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">process_control_block</span>  *<span class="title">list</span>;</span></span><br><span class="line">&#125;semaphore;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;list:为进程链表，用于链接所有等待该类资源的进程。<br>&ensp;&ensp;&ensp;&ensp;用wait(s)和signal(s)实现同步与互斥。<br>&ensp;&ensp;&ensp;&ensp;在记录型信号量机制中：<br>&ensp;&ensp;&ensp;&ensp;s-&gt;value初值：表示系统中某类资源的数目。<br>&ensp;&ensp;&ensp;&ensp;s-&gt;value&lt;0:无可用资源，其绝对值表示系统中因请求该类资源而被阻塞的进程数目。  </p>
<p>等待：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">wait(semaphore *S)&#123;</span><br><span class="line">	S-&gt;value --;</span><br><span class="line">	<span class="keyword">if</span>(S-&gt;value &lt; <span class="number">0</span>)</span><br><span class="line">		block(S-&gt;<span class="built_in">list</span>);<span class="comment">//让权等待</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通知：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">signal(semaphore *S)&#123;</span><br><span class="line">	S-&gt;value ++;</span><br><span class="line">	<span class="keyword">if</span>(S-&gt;value &lt;= <span class="number">0</span>)</span><br><span class="line">		wakeup(S-&gt;<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;关于记录型信号量的说明<br>&ensp;&ensp;&ensp;&ensp;每次执行完S-&gt;value–操作后，若S-&gt;value&lt;0时，说明该类资源已分配完毕，因此进程应调用block原语，进行自我阻塞，放弃处理机，并插入到信号量链表S.list中。<br>&ensp;&ensp;&ensp;&ensp;每次执行完S-&gt;value++操作后，若S-&gt;value≤0时，则表示在该信号量链表中，仍有等待该资源的进程被阻塞，故还应调用wakeup原语，将S.list链表中的第一个等待进程唤醒。<br>&ensp;&ensp;&ensp;&ensp;若S-&gt;value的初值为1，表示只允许一个进程访问临界资源，此时的信号量转化为互斥信号量。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. AND型信号量</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;AND型信号量集用于同时需要多种资源且每种资源占用一个信号量时的信号量操作；<br>&ensp;&ensp;&ensp;&ensp;基本思想：在一个原语中，将一段代码同时需要的多个临界资源，要么全部分配给它，要么一个都不分配。为Swait(Simultaneous Wait)。<br>&ensp;&ensp;&ensp;&ensp;在Swait时，各个信号量的次序并不重要，虽然会影响进程归入哪个阻塞队列，但是由于是对资源全部分配或不分配。<br>&ensp;&ensp;&ensp;&ensp;所以总有进程获得全部资源，并在执行完毕之后释放资源，因此不会死锁。   </p>
<p>等待操作Swait()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Swait(S1,S2,…Sn)&#123;</span><br><span class="line">   <span class="keyword">while</span>( TRUE)</span><br><span class="line">    &#123;      </span><br><span class="line">		 <span class="keyword">if</span>(S1&gt;=<span class="number">1</span> &amp;&amp; S2&gt;=<span class="number">1</span>…&amp;&amp; Sn&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)  Si--;   / /满足资源要求时的处理；</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">			&#125;<span class="comment">//if</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//某些资源不够时的处理；调用进程进入第一个小于1信号量的等待队列Sj;并把该进程的程序计数器指向swait操作的开始。 </span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通知操作Ssignal()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Ssignal(S1,S2,…Sn)&#123;</span><br><span class="line">   <span class="keyword">while</span>(TRUE)</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        Si++;<span class="comment">//释放资源</span></span><br><span class="line">  把 Si等待队列中的进程调入就绪队列。</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;<strong>4. 信号量集</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;思想：若进程一次需要申请多类临界资源，则在进行临界资源分配时，先测试各类临界资源是否大于其下限值。若低于下限值，则不予分配。<br>&ensp;&ensp;&ensp;&ensp;对应的Swait 和Ssignal格式为：<br>&ensp;&ensp;&ensp;&ensp;Swait(S1,t1,d1,…,Sn,tn,dn)    Ssignal(S1,d1,…,Sn,dn)<br>这里S为信号量，d为需求值，t为下限值  </p>
<p>&ensp;&ensp;&ensp;&ensp;用于同时需要多种资源、每种资源的占用数目不同、且可分配的资源还存在一个临界值时的处理；<br>&ensp;&ensp;&ensp;&ensp;临界值，就是指在某些情况下，当资源数量低于某一下限值时，便不予分配。这个下限值称作临界值。<br>&ensp;&ensp;&ensp;&ensp;一次需要N个某类临界资源，就要进行N次wait操作－－低效又可能死锁<br>&ensp;&ensp;&ensp;&ensp;基本思想：在AND型信号量集的基础上进行扩充：进程对信号量Si的下限值为ti（用于信号量的判断，即Si &lt;= ti，表示资源数量低于ti时，便不予分配），需求值为di（用于信号量的增减，即Si = Si - di和Si = Si + di）  </p>
<p>等待操作Swait()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Swait(S1，t1，d1，…，Sn，tn，dn)</span><br><span class="line">　　　　<span class="keyword">if</span> (Si&gt;=t1 &amp;&amp; … &amp;&amp; Sn&gt;=tn )&#123;</span><br><span class="line">　　　　　　<span class="keyword">for</span> (i=<span class="number">1</span> ;i&lt;= n;i++)</span><br><span class="line">　　　　　　　　Si:=Si-di；</span><br><span class="line">　　　　　　<span class="keyword">else</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;三种特例：<br>&ensp;&ensp;&ensp;&ensp;（1）Swait(S,d,d)：允许每次申请d个资源。当资源数少于d时，不予分配。<br>&ensp;&ensp;&ensp;&ensp;（2）Swait (s,1,1)：S&gt;1，资源信号量。S=1时，互斥信号量。<br>&ensp;&ensp;&ensp;&ensp;（3）Swait(s,1,0)，可控开关，当s&gt;=1时，允许进入，当s变为0后，阻止任何进程不能进入。  </p>
<h3 id="2-4-4-信号量的应用"><a href="#2-4-4-信号量的应用" class="headerlink" title="2.4.4 信号量的应用"></a>2.4.4 信号量的应用</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 利用信号量实现互斥</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）为临界资源设置一个互斥信号量mutex，其初值为1，取值为（-1，0，1）；在每个进程中将临界区代码置于wait(mutex)和signal(mutex)原语之间。</p>
<p>&ensp;&ensp;&ensp;&ensp;2）代码描述   </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>;</span><br><span class="line">Pa()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		wait(mutex);</span><br><span class="line">		临界区；</span><br><span class="line">		signal(mutex);</span><br><span class="line">		剩余区；</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Pb()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		wait(mutex);</span><br><span class="line">		临界区；</span><br><span class="line">		signal(mutex);</span><br><span class="line">		剩余区；</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;必须成对使用wait和signal原语,不能次序错误、重复或遗漏.遗漏wait原语则不能保证互斥访问，遗漏signal原语则不能在使用临界资源之后将其释放（给其他等待的进程）。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 利用信号量来描述前趋关系</strong>   </p>
<p><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%8717.png">   </p>
<p>代码描述框架如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p1()&#123; S1; signal(a); signal(b); &#125;</span><br><span class="line">p2()&#123; wait(a); S2; signal(c); signal(d); &#125;</span><br><span class="line">p3()&#123; wait(b);S3; signal(e); &#125;</span><br><span class="line">p4()&#123; wait(c);S4; signal(f); &#125;</span><br><span class="line">p5()&#123; wait(d);S1; signal(g); &#125;</span><br><span class="line">p6()&#123; wait(e); wait(f);wait(g);S6; &#125;</span><br><span class="line">main()&#123;</span><br><span class="line">semaphore a,b,c,d,e,f,g;</span><br><span class="line">a.value=b.value=c.value=d.value=e.value=f.value=g.value=<span class="number">0</span>;</span><br><span class="line">cobegin</span><br><span class="line">    p1();p2();p3();p4();p5();p6();</span><br><span class="line">coend  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-5-管程机制"><a href="#2-4-5-管程机制" class="headerlink" title="2.4.5 管程机制"></a>2.4.5 管程机制</h3><p>&ensp;&ensp;&ensp;&ensp;信号量同步的缺点<br>&ensp;&ensp;&ensp;&ensp;1）同步操作分散：信号量机制中，同步操作分散在各个进程中，使用不当就可能导致各进程死锁（如P、V操作的次序错误、重复或遗漏）；<br>&ensp;&ensp;&ensp;&ensp;2）易读性差：要了解对于一组共享变量及信号量的操作是否正确，必须通读整个系统或者并发程序；<br>&ensp;&ensp;&ensp;&ensp;3）不利于修改和维护：各模块的独立性差，任一组变量或一段代码的修改都可能影响全局；<br>&ensp;&ensp;&ensp;&ensp;4）正确性难以保证：操作系统或并发程序通常很大，很难保证这样一个复杂的系统没有逻辑错误。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.管程的定义</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;管程（Mointors）：一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。<br>&ensp;&ensp;&ensp;&ensp;管程组成：① 局部于管程的共享变量说明；② 对该数据结构进行操作的一组过程；③ 对局部于管程的数据设置初始值的语句。④还须为管程赋予一个名字。<br>&ensp;&ensp;&ensp;&ensp;代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，共同构成了一个操作系统的资源管理模块，我们称之为管程。<br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%8718.png">   </p>
<p>管程语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  Monitor monitor-name&#123;</span><br><span class="line">  share variable declarations;</span><br><span class="line">  cond declarations;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">(…)</span>  </span>&#123;….&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">(…)</span>  </span>&#123;….&#125;;</span><br><span class="line">  ….</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Pn</span><span class="params">(…)</span>  </span>&#123;….&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">        initialization code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;管程的主要特性<br>&ensp;&ensp;&ensp;&ensp;1）模块化：一个管程是一个基本程序单位，可以单独编译；<br>&ensp;&ensp;&ensp;&ensp;2）抽象数据类型：管程是一种特殊的数据类型，其中不仅有数据，而且有对数据进行操作的代码；<br>&ensp;&ensp;&ensp;&ensp;3）信息封装：管程是半透明的，管程中的过程（函数）实现了某些功能，至于这些功能是怎样实现的，在其外部则是不可见的。  </p>
<p>&ensp;&ensp;&ensp;&ensp;管程与进程的区别<br>&ensp;&ensp;&ensp;&ensp;1）进程定义的是私有数据结构PCB，管程定义的是公共数据结构；<br>&ensp;&ensp;&ensp;&ensp;2）都有对各自数据结构的操作。进程的操作由对应的代码段决定，管程的操作主要是同步操作和初始化操作；<br>&ensp;&ensp;&ensp;&ensp;3）设置进程的目的是为了实现并发，管程的目的是解决临界资源的互斥使用；  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.条件变量</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;管程的设计：<br>&ensp;&ensp;&ensp;&ensp;必须设置同步工具，如操作原语wait和signal，来保证对临界资源的正确访问；<br>&ensp;&ensp;&ensp;&ensp;引入条件变量condition，解决进程调用管程过程中被阻塞或挂起时，释放管程的相关控制；<br>&ensp;&ensp;&ensp;&ensp;通常，进程被挂起或阻塞的原因可能有多个，为了区别它们，需设置多个条件变量condition。<br>&ensp;&ensp;&ensp;&ensp;对条件变量的操作仅仅是wait和signal，因此条件变量也是一种抽象数据类型，每个条件变量保存了一个链表，用于记录因该条件变量而阻塞的所有进程。同时提供的两个操作即可表示为x.wait和x.signal。<br>&ensp;&ensp;&ensp;&ensp;x.wait的作用是：正在调用管程的进程因x条件需要被阻塞或挂起，则调用x.wait将自己插入到x条件的等待对列上，并释放管程，直到x条件变化。此时其它进程可以使用该管程。<br>&ensp;&ensp;&ensp;&ensp;x.signal的作用是：正在调用管程的进程发现x条件发生了变化，则调用x.signal重新启动一个因x条件而被阻塞或挂起的进程。如果存在多个这样的进程，则选择其中的一个，但如果没有被阻塞的进程，则x.signal操作不产生任何后果。如果有进程Q因x条件处于阻塞状态，当进程P执行了x.signal操作后，进程Q被重新启动，此时两个进程P和Q，怎样决定哪个进程执行，哪个等待，可采用下述两种方式之一：<br>&ensp;&ensp;&ensp;&ensp;（1） P等待，直至Q离开管程或等待另一条件；<br>&ensp;&ensp;&ensp;&ensp;（2） Q等待，直至P离开管程或等待另一条件。  </p>
<h2 id="2-5-经典进程的同步问题"><a href="#2-5-经典进程的同步问题" class="headerlink" title="2.5 经典进程的同步问题"></a>2.5 经典进程的同步问题</h2><h3 id="2-5-1-生产者——消费者问题"><a href="#2-5-1-生产者——消费者问题" class="headerlink" title="2.5.1 生产者——消费者问题"></a>2.5.1 生产者——消费者问题</h3><p>书p65<br>记录型信号量、AND型信号量、管程  </p>
<h3 id="2-5-2-哲学家进餐问题"><a href="#2-5-2-哲学家进餐问题" class="headerlink" title="2.5.2 哲学家进餐问题"></a>2.5.2 哲学家进餐问题</h3><p>书p69<br>记录型信号量、AND型信号量</p>
<h3 id="2-5-3-读者——写者问题"><a href="#2-5-3-读者——写者问题" class="headerlink" title="2.5.3 读者——写者问题"></a>2.5.3 读者——写者问题</h3><p>书p71<br>记录型信号量、信号量集</p>
<h2 id="2-6-进程通信"><a href="#2-6-进程通信" class="headerlink" title="2.6 进程通信"></a>2.6 进程通信</h2><p>&ensp;&ensp;&ensp;&ensp;进程通信的方式<br>&ensp;&ensp;&ensp;&ensp;进程之间的通信内容包含两种类型：控制信息和大批量数据。<br>&ensp;&ensp;&ensp;&ensp;低级通信：进程之间交换控制信息的过程<br>&ensp;&ensp;&ensp;&ensp;高级通信：进程之间交换批量数据的过程<br>&ensp;&ensp;&ensp;&ensp;进程之间同步与互斥是一种低级通信来控制进程的执行速度。</p>
<p>&ensp;&ensp;&ensp;&ensp;高级通信：利用操作系统提供的通信命令，高效传送大量数据的一种通信方式。<br>&ensp;&ensp;&ensp;&ensp;高级通讯方式有：<br>&ensp;&ensp;&ensp;&ensp;1、共享存储器系统，<br>&ensp;&ensp;&ensp;&ensp;2、管道通信系统<br>&ensp;&ensp;&ensp;&ensp;3、消息传递系统<br>&ensp;&ensp;&ensp;&ensp;4、C/S系统  </p>
<h3 id="2-6-1-进程通信的类型"><a href="#2-6-1-进程通信的类型" class="headerlink" title="2.6.1 进程通信的类型"></a>2.6.1 进程通信的类型</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.共享存储器系统（Shared-Memory System）</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在共享存储器系统中，相互通信的进程共享某些数据结构或共享存储区，进程之间能够通过这些空间进行通信。又可以分为以下两种类型：  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）基于共享数据结构的通信方式（低级通信）<br>&ensp;&ensp;&ensp;&ensp;该种通信方式中，要求诸进程公用某些数据结构，借以实现诸进程间的信息交换。如生产者-消费者问题中的共享缓冲池。这种通信方式仅适于传递相对少量的数据，通信效率低下，属于低级通信。<br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%8719.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）基于共享存储区的通信方式（高级通信）<br>&ensp;&ensp;&ensp;&ensp;为了传输大量数据，在存储器中划出了一块共享存储区，诸进程可通过对共享存储区中数据的读和写来实现通信。<br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%8720.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;步骤：<br>&ensp;&ensp;&ensp;&ensp;（1）申请共享存储区。<br>&ensp;&ensp;&ensp;&ensp;（2）连接共享存储区到进程的存储空间。<br>&ensp;&ensp;&ensp;&ensp;（3）互斥访问共享存储区。<br>&ensp;&ensp;&ensp;&ensp;（4）归还共享存储区。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.管道（pipe）通信系统</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。<br>&ensp;&ensp;&ensp;&ensp;向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入管道；<br>&ensp;&ensp;&ensp;&ensp;而接受管道输出的接收进程（即读进程），则从管道中接收（读）数据。<br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%8721.png">     </p>
<p>&ensp;&ensp;&ensp;&ensp;管道机制须提供的协调能力<br>&ensp;&ensp;&ensp;&ensp;①互斥 即当一个进程正在对pipe执行读/写操作时，其他进程必须等待；<br>&ensp;&ensp;&ensp;&ensp;②同步  指当写（输入）进程把一定数量的数据写入pipe，便去睡眠等待，直到读（输出）进程取走数据后，再把它唤醒。当读进程读一空pipe时，也应睡眠等待，直至写进程将数据写入管道后，才将之唤醒；<br>&ensp;&ensp;&ensp;&ensp;③确定对方是否存在，只有确定了对方已存在时，才能进行通信。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.消息传递系统（Message passing system）</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在消息传递系统中，进程间的数据交换，是以格式化的消息（Message）为单位的。程序员直接利用系统提供的一组通信命令进行通信。<br>&ensp;&ensp;&ensp;&ensp;当今最为流行的微内核操作系统中，微内核与服务器之间的通信，无一例外地都采用了消息传递机制。<br>&ensp;&ensp;&ensp;&ensp;当基于消息传递系统的通信方式属于高级通信方式，因其实现方式的不同，可进一步分成两类：<br>&ensp;&ensp;&ensp;&ensp;1）直接通信方式：发送进程利用OS所提供的发送命令，直接把消息发送给目标进程；<br>&ensp;&ensp;&ensp;&ensp;2）间接通信方式：进程之间的通信，通过中间实体（也称为信箱）来暂存发送进程发送给目标进程的消息，接收进程则从该实体中接收发送给自己的消息。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.客户机-服务器系统（Client-server system）</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;客户机-服务器系统的通信机制，在网络环境下的各种应用领域以成为当前主流的通信实现机制。<br>&ensp;&ensp;&ensp;&ensp;其主要的实现方法有三类：①套接字，②远程方法调用和③远程过程调用。  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）套接字：起源于BSD Unix,最初用于同一台主机上多个应用程序之间的通信，随着网络技术和Unix操作系统的广泛使用，套接字已经逐渐成为最流行的网络程序接口之一。通常包括两类：<br>&ensp;&ensp;&ensp;&ensp;（1）基于文件型：通信进程运行在同一台机器的环境中，套接字是基于本地文件系统支持的，一个套接字关联到一个特殊的文件，通信双方通过对这个特殊文件的读写实现通信，原理类似于管道。<br>&ensp;&ensp;&ensp;&ensp;（2）基于网络型：采用非对称方式通信，即发送者需要提供接收者命名。通信双方的进程运行在不同主机的网络环境下，被分配了一对套接字，分别属于发送者和接收者。  </p>
<p>&ensp;&ensp;&ensp;&ensp;套接字的优势在于，它不仅适用于同一台计算机内部的通信，也适用于网络环境中不同计算机间的进程通信。由于每个套接字拥有唯一标识符，因而可以方便加以区分。  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）远程过程调用和远程方法调用：远程过程调用RPC是一个通信协议，允许一台主机（本地）系统上的进程调用另一台主机（远程）系统上的进程。如果涉及的软件采用面向对象编程，那么RPC亦可称为远程方法调用。<br>&ensp;&ensp;&ensp;&ensp;负责RPC的进程有两个，一个是本地客户进程，另一个是远程服务进程。它们通常也被称为网络守护进程，主要负责网络间的消息传递，一般都处于阻塞状态，等待消息。  </p>
<h3 id="2-6-2-消息传递通信的实现方式"><a href="#2-6-2-消息传递通信的实现方式" class="headerlink" title="2.6.2 消息传递通信的实现方式"></a>2.6.2 消息传递通信的实现方式</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.直接消息传递系统</strong>：发送进程利用OS提供的发送命令（原语），直接把消息发送给目标进程。  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）直接通信原语<br>&ensp;&ensp;&ensp;&ensp;a.对称寻址方式<br>&ensp;&ensp;&ensp;&ensp;send(Receiver, message)   send(P2,m1)<br>&ensp;&ensp;&ensp;&ensp;receive(Sender, message)  receive(P1,m1)<br>&ensp;&ensp;&ensp;&ensp;b.非对称寻址方式<br>&ensp;&ensp;&ensp;&ensp;send(P,message)  receive     </p>
<p>&ensp;&ensp;&ensp;&ensp;2）消息格式:传递的消息要有统一的格式<br>&ensp;&ensp;&ensp;&ensp;①单机系统环境下，由于发送者和接收者处于同一台机器中，所以消息的格式采用比较短的定长消息格式。<br>&ensp;&ensp;&ensp;&ensp;（系统开销小，用户不便）<br>&ensp;&ensp;&ensp;&ensp;②对于发送较长消息的用户，可采用变长消息格式，即进程所发送的消息长度是可变的。<br>&ensp;&ensp;&ensp;&ensp;（开销大，用户方便）  </p>
<p>&ensp;&ensp;&ensp;&ensp;3）进程间的同步方式：通信进程之间需要协调通信。<br>&ensp;&ensp;&ensp;&ensp;①发送和接收进程阻塞（汇合）：用于紧密同步，无缓冲区时。<br>&ensp;&ensp;&ensp;&ensp;②发送进程不阻塞，接收进程阻塞：相当于接收进程（可能是多个）一直等待发送进程，如：打印进程等待打印任务。<br>&ensp;&ensp;&ensp;&ensp;③发送/接收进程均不阻塞：一般在发、收进程间有多个缓冲区时。  </p>
<p>&ensp;&ensp;&ensp;&ensp;4）通信链路<br>&ensp;&ensp;&ensp;&ensp;两种方式建立通信链路<br>&ensp;&ensp;&ensp;&ensp;显式建立：（使用“建立连接”原语）由发送进程在通信之前，用显式的“建立连接”命令（原语），请求系统为之建立一条通信链路，在链路使用完后拆除链路。<br>&ensp;&ensp;&ensp;&ensp;隐式建立：（使用发送原语）发送进程无须明确提出建立链路的请求，只须利用系统提供的发送命令（原语），系统会自动地为之建立一条链路。（多用于单机系统）   </p>
<p>&ensp;&ensp;&ensp;&ensp;根据通信方式的不同，则又可把链路分成两种<br>&ensp;&ensp;&ensp;&ensp;①单向通信链路，只允许发送进程向接收进程发送消息，或者相反；<br>&ensp;&ensp;&ensp;&ensp;②双向通信链路，既允许由进程A向进程B发送消息，也允许进程B同时向进程A发送消息。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.信箱通信（间接通信）</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;基本方式：通过邮箱发送、接收、回答信件通信发送进程申请建立一个与接收进程链接的邮箱。发送进程的消息送往邮箱，接收进程可在任何时候从邮箱中取出消息，从而完成进程间信息交换。</p>
<p>&ensp;&ensp;&ensp;&ensp;1）信箱的结构<br>&ensp;&ensp;&ensp;&ensp;信箱是一种数据结构，由信箱头和信箱体组成。<br>&ensp;&ensp;&ensp;&ensp;①信箱头：描述信箱名、大小及拥有该信箱的进程名称等<br>&ensp;&ensp;&ensp;&ensp;②信箱体：包含多个格子，用于存放消息正文<br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%8722.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）信箱的类型  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）私用信箱：<br>&ensp;&ensp;&ensp;&ensp;用户进程可为自己建立一个新信箱，并作为该进程的一部分，当拥有该信箱的进程结束时，信箱也随之消失；<br>&ensp;&ensp;&ensp;&ensp;（2）公用信箱：<br>&ensp;&ensp;&ensp;&ensp;由操作系统创建，并提供给系统中的所有核准进程使用，核准进程既可把消息发送到该信箱中，也可从信箱中读取发送给自己的消息；<br>&ensp;&ensp;&ensp;&ensp;（3）共享信箱：<br>&ensp;&ensp;&ensp;&ensp;由某进程创建，在创建时或创建后，指明它是可共享的，同时须指出共享进程（用户）的名字。  </p>
<h3 id="2-6-3-直接消息传递系统实例"><a href="#2-6-3-直接消息传递系统实例" class="headerlink" title="2.6.3 直接消息传递系统实例"></a>2.6.3 直接消息传递系统实例</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.消息缓冲队列通信系统中的数据结构</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）消息缓冲区  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type <span class="class"><span class="keyword">struct</span> <span class="title">message_buffer</span>&#123;</span></span><br><span class="line">　　<span class="keyword">int</span> sender； 发送者进程标识符</span><br><span class="line">　　<span class="keyword">int</span> size；   消息长度</span><br><span class="line">　　<span class="keyword">char</span> *text；   消息正文</span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">message_buffer</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;2）PCB中有关通信的数据项   </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type <span class="class"><span class="keyword">struct</span> <span class="title">processcontrol_block</span>&#123;</span></span><br><span class="line">	…</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">message_buffer</span> *<span class="title">mq</span>； 消息队列队首指针</span></span><br><span class="line"><span class="class">	<span class="title">semaphore</span> <span class="title">mutex</span>；  消息队列互斥信号量</span></span><br><span class="line"><span class="class">	<span class="title">semaphore</span> <span class="title">sm</span>；     消息队列资源信号量</span></span><br><span class="line"><span class="class">	…</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;<strong>2.发送原语</strong>   </p>
<p><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%8723.png">  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(receiver, a)</span></span>&#123;</span><br><span class="line">	 getbuf(a.size, i);向系统申请一个消息缓冲区</span><br><span class="line">	 i.sender=a.sender;</span><br><span class="line">	 i.size=a.size;</span><br><span class="line">	 i.text=a.text;</span><br><span class="line">	 i.next=<span class="number">0</span>;将发送的消息送消息缓冲区</span><br><span class="line">	 getid(PCBset, receiver.j);</span><br><span class="line">	 wait(j.mutex);</span><br><span class="line">	 insert(j.mq, i);将消息缓冲区插入消息队列     </span><br><span class="line">     signal(j.mutex);</span><br><span class="line">	 signal(j.sm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.接收原语</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">(b)</span></span>&#123;</span><br><span class="line">	 j=internal name;</span><br><span class="line">	 wait(j.sm);</span><br><span class="line">	 wait(j.mutex);</span><br><span class="line">	 remove(j.mq, i);取消息队列中的消息</span><br><span class="line">	 signal(j.mutex);</span><br><span class="line">	 b.sender=i.sender;</span><br><span class="line">	 b.size=i.size;</span><br><span class="line">	 b.text=i.text;将消息从缓冲区复制到接收区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-7-线程（THREAD）的基本概念"><a href="#2-7-线程（THREAD）的基本概念" class="headerlink" title="2.7 线程（THREAD）的基本概念"></a>2.7 线程（THREAD）的基本概念</h2><p>&ensp;&ensp;&ensp;&ensp;在20世纪60年代中期，人们设计多道OS时引入了进程的概念，从而解决了程序并发性的问题。此后的20多年时间里，进程一直作为资源分配和调度的基本单位。<br>&ensp;&ensp;&ensp;&ensp;80年代中期，为了进一步提高程序的并发度，引入了线程这一更小的基本单位。它特别适用于多处理机OS。  </p>
<h3 id="2-7-1-线程的引入"><a href="#2-7-1-线程的引入" class="headerlink" title="2.7.1 线程的引入"></a>2.7.1 线程的引入</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.程序并发执行所付出的时空开销</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）创建进程。系统在创建进程时，必须为之分配其所必需的、除处理机以外的所有资源。如内存空间、I/O设备以及建立相应的PCB。<br>&ensp;&ensp;&ensp;&ensp;（2）撤消进程。系统在撤消进程时，又必须先对这些资源进行回收操作，然后再撤消PCB。<br>&ensp;&ensp;&ensp;&ensp;（3）进程切换。在对进程进行切换时，由于要保留当前进程的CPU环境和设置新选中进程的CPU环境，为此需花费不少处理机时间。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.线程——作为调度和分派的基本单位</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;由于进程是一个资源的拥有者，所以在创建、撤销和切换中，系统必须付出较大的时空开销。正因如此，系统中设置的进程数目不宜过多，进程切换频率也不宜过高，这就限制了并发程度的进一步提高。<br>&ensp;&ensp;&ensp;&ensp;引入线程，以线程作为调度、分派和切换的基本单位，则可以有效地改善系统性能。  </p>
<h3 id="2-7-2-线程与进程的比较"><a href="#2-7-2-线程与进程的比较" class="headerlink" title="2.7.2 线程与进程的比较"></a>2.7.2 线程与进程的比较</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.调度的基本单位</strong>：在传统的操作系统中，拥有资源的基本单位和独立调度、分派的基本单位都是进程，因而调度时，开销较大。引入线程则把它作为独立运行的基本单位，切换线程时，仅需保存和设置少量的寄存器内容，代价较低。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.并发性</strong>：在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，因而使操作系统具有更好的并发性，从而能更有效地使用系统资源和提高系统吞吐量。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.拥有资源</strong>：不论是传统的操作系统，还是设有线程的操作系统，进程都是拥有资源的一个独立单位，它可以拥有自己的资源。线程本身并不拥有系统资源，而是仅有一点必需，保证独立运行的资源。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.独立性</strong>：同一进程中的不同线程之间的独立性比不同进程之间的独立性低得多。   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>5.系统开销</strong>：由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等。因此，操作系统所付出的开销将明显地大于在创建或撤消线程时的开销。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>6.支持多处理机系统</strong>：在多处理机系统中，传统的进程只能运行在一个处理机上。对于多线程进程，可将多个线程分配到多个处理机上，使它们并行执行。     </p>
<h3 id="2-7-3-线程的状态和线程控制块"><a href="#2-7-3-线程的状态和线程控制块" class="headerlink" title="2.7.3 线程的状态和线程控制块"></a>2.7.3 线程的状态和线程控制块</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.线程运行的三个状态</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;与传统进程一样，线程之间也存在着相互制约关系，使得线程运行时出现间断性，因而线程也有三种基本状态：<br>&ensp;&ensp;&ensp;&ensp;（1）执行状态。线程获得处理机正在运行。<br>&ensp;&ensp;&ensp;&ensp;（2）就绪状态。线程已具备了各种执行条件，只需再获得CPU便可执行。<br>&ensp;&ensp;&ensp;&ensp;（3）阻塞状态。线程因某个事件而处于暂停状态。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.线程控制块TCB</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;线程控制块通常包含以下几项内容：<br>&ensp;&ensp;&ensp;&ensp;①线程标识符；②一组寄存器，包括程序计数器，状态寄存器和通用寄存器；③线程运行状态；④线程优先级；⑤线程专有存储区；⑥信号屏蔽；⑦堆栈指针。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.多线程OS中的进程属性</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）作为系统资源分配的单位。（线程是资源调度的基本单位）<br>&ensp;&ensp;&ensp;&ensp;（2）可包括多个线程。一个进程都含有多个相对独立的线程，其数目可多可少，但至少要有一个线程，由进程为这些线程提供资源及运行环境，使这些线程可并发执行。<br>&ensp;&ensp;&ensp;&ensp;（3）进程不是一个可执行的实体。在多线程OS中，线程作为独立运行的基本单位。虽然如此，进程仍具有与执行相关的状态。所谓进程处于“执行”状态，实际上是指该进程中的<strong>某线程正在执行</strong>。把某<strong>进程挂起</strong>，该进程中的<strong>所有线程都将被挂起</strong>。    </p>
<h2 id="2-8-线程的实现"><a href="#2-8-线程的实现" class="headerlink" title="2.8 线程的实现"></a>2.8 线程的实现</h2><h3 id="2-8-1-线程的实现方式"><a href="#2-8-1-线程的实现方式" class="headerlink" title="2.8.1 线程的实现方式"></a>2.8.1 线程的实现方式</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.内核支持线程KST（Kernel Supported Threads）</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;内核支持线程KST（Kernel Supported Threads），指的是在内核支持下运行的，即无论是用户进程中的线程，还是系统进程中的线程，他们的创建、撤销和切换等也是依靠内核，在内核空间实现的。线程管理的所有工作都由内核完成。 </p>
<p>&ensp;&ensp;&ensp;&ensp;优点：<br>&ensp;&ensp;&ensp;&ensp;1）在多处理器系统中，内核能同时调度同一进程中的多个线程并行执行；<br>&ensp;&ensp;&ensp;&ensp;2）如果进程中的一个线程被阻塞了，内核可以调度该进程中的其他线程或运行其他进程中的线程；<br>&ensp;&ensp;&ensp;&ensp;3）内核支持线程具有很小的数据结构和堆栈，线程的切换比较快，切换开销小；<br>&ensp;&ensp;&ensp;&ensp;4）内核本身也可以采用多线程技术，可以提高系统的执行速度和效率。  </p>
<p>&ensp;&ensp;&ensp;&ensp;缺点：对于用户的线程切换而言，其切换的开销较大，在同一个进程中，从一个线程切换到另一个线程时，需要从用户态转到内核态进行。这是因为用户进程的线程在用户态运行，而线程调度和管理在内核实现，系统开销较大。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.用户级线程ULT（User Level Threads）</strong>    </p>
<p>&ensp;&ensp;&ensp;用户级线程ULT(User Level Threads)仅存在于用户空间中。对于这种线程的创建、撤销、线程之间的同步与通信等功能，都无须利用系统调用来实现。线程的管理由应用程序完成，在用户空间中实现，内核无需感知线程的存在。<br>&ensp;&ensp;&ensp;对于用户级线程的切换，通常发生在一个应用进程的诸多线程之间，这时，也同样无须内核的支持。  </p>
<p>&ensp;&ensp;&ensp;&ensp;优点：<br>&ensp;&ensp;&ensp;&ensp;1）线程切换不需要转换到内核空间；<br>&ensp;&ensp;&ensp;&ensp;2）调度算法可以是线程专用的；<br>&ensp;&ensp;&ensp;&ensp;3）用户级线程的实现与操作系统平台无关；  </p>
<p>&ensp;&ensp;&ensp;&ensp;缺点：<br>&ensp;&ensp;&ensp;&ensp;1）系统调用的阻塞问题。用户级线程执行系统调用时，不仅该线程阻塞，而且进程内的所有线程都会阻塞，而内核支持线程方式中，进程中的其它线程仍然可以运行；<br>&ensp;&ensp;&ensp;&ensp;2）单纯的用户级线程实现方式中，多线程应用不能利用多处理机进行多重处理的优点。内核每次分配给进程的只有一个CPU，因此进程中仅有一个线程能执行。<br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%8724.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.组合方式</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;在该方式中，内核支持多个内核支持线程的建立，调度和管理，同时，也允许用户应用程序建立，调度和管理用户级线程。线程的创建是在用户层进行线程的调度和同步在用户层进行选择一部分用户级线程映射到一些内核级线程上。<br>&ensp;&ensp;&ensp;&ensp;它能够结合KST和ULT两者的优点，并克服了各自的不足。  </p>
<p>&ensp;&ensp;&ensp;&ensp;三种不同模型：<br>&ensp;&ensp;&ensp;&ensp;（1）多对一模型。即将多个用户线程映射到一个内核控制线程。这些用户线程一般属于一个进程，运行在该进程的用户空间，对这些线程的调度和管理也是在该进程的用户空间完成。仅当用户线程需要访问内核时，才将其映射到内核线程，每次只允许一个线程进行映射。<br>&ensp;&ensp;&ensp;&ensp;（2）一对一模型。即将每个用户线程映射到一个内核控制线程。当一个线程阻塞时允许另一个线程运行。此外，它允许多个线程并行运行在多处理机系统中。<br>&ensp;&ensp;&ensp;&ensp;（3）多对多模型。将多个用户线程映射到同样数量或更少数量的内核线程上。结合了上述两种模型的优点。  </p>
<h3 id="2-8-2-线程的实现"><a href="#2-8-2-线程的实现" class="headerlink" title="2.8.2 线程的实现"></a>2.8.2 线程的实现</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.内核支持线程的实现</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在仅设置了内核支持线程的OS中，一种可能的线程控制方法是，系统在创建一个进程时，便为它分配一个任务数据区PTDA（Per Task Data Area）其中包括若干个线程控制块TCB。TCB中可保存线程标识符、优先级、线程运行的CPU状态等信息。这些信息是被保存在内核空间中的。<br>&ensp;&ensp;&ensp;&ensp;之后对线程的创建、撤销均与进程的相类似；<br>&ensp;&ensp;&ensp;&ensp;内核支持线程的调度和切换与进程的调度和切换也类似  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.用户级线程的实现</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;用户级线程是在用户空间实现的。所有的用户级线程都具有相同的结构，它们都运行在一个中间系统的上面。<br>&ensp;&ensp;&ensp;&ensp;1）运行时系统：实质上是用于管理和控制线程的函数（过程）的集合，其中包括用于创建和撤销线程的函数、线程同步和通信的函数以及实现线程调度的函数等。<br>&ensp;&ensp;&ensp;&ensp;运行时系统的所有函数都驻留在用户空间，作为用户级线程和内核之间的接口。<br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%8725.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）内核控制线程（组合方式）：这种线程又称为轻型进程LWP（Light Weight Process）。每一个进程都可拥有多个LWP，每个LWP都有自己的数据结构（如TCB）。LWP可以通过系统调用来获得内核提供的服务。<br><img src="/2021/05/09/os-2/%E5%9B%BE%E7%89%8726.png">   </p>
<h3 id="2-8-3-线程的创建和终止"><a href="#2-8-3-线程的创建和终止" class="headerlink" title="2.8.3 线程的创建和终止"></a>2.8.3 线程的创建和终止</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.线程的创建</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;应用程序在启动时，通常仅有一个线程在执行，人们把线程称为“初始化线程”，它的主要功能是用于创建新线程。在创建新线程时，需要利用一个线程创建函数（或系统调用），并提供相应的参数。创建函数执行完成后，返回一个线程标识符供以后使用。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.线程的终止</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;当一个线程完成了自己的任务后，或是线程在运行中出现异常情况而须被强行终止时，由终止线程通过调用相应的函数对它执行终止操作。在大多数OS中，线程被中止后并不立即释放它所占有的资源，只有当进程中的其它线程执行了分离函数后，被终止的线程才与资源分离，此时的资源才能被其它线程利用。<br>&ensp;&ensp;&ensp;&ensp;虽已被终止但尚未释放资源的线程，仍可以被需要它的线程所调用，以使被终止线程重新恢复运行。为此，调用者线程须调用一条被称为“等待线程终止”的连接命令，来与该线程进行连接。如果在一个调用者线程调用“等待线程终止”的连接命令试图与指定线程相连接时，若指定线程尚未被终止，则调用连接命令的线程将会阻塞，直至指定线程被终止后才能实现它与调用者线程的连接并继续执行；若指定线程已被终止，则调用者线程不会被阻塞而是继续执行。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记——第五章</title>
    <url>/2021/06/16/os-5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>个人操作系统笔记整理，欢迎参考，时不时更新。  </p>
<span id="more"></span> 

<h1 id="第五章-虚拟存储器"><a href="#第五章-虚拟存储器" class="headerlink" title="第五章 虚拟存储器"></a>第五章 虚拟存储器</h1><p>&ensp;&ensp;&ensp;&ensp;第四章所介绍的各种存储管理方式有一个共同的特点，即它们都要求将一个作业全部装入内存后方能运行。于是，可能出现以下两种情况：<br>&ensp;&ensp;&ensp;&ensp;（1）有的作业很大，其所要求的内存空间超过了内存总容量，作业不能全部被装入内存，致使该作业无法运行；<br>&ensp;&ensp;&ensp;&ensp;（2）有大量作业要求运行，但由于内存容量不足以容纳所有这些作业，只能将少数作业装入内存让它们先运行，而将其它大量作业留在外存上等待。<br>&ensp;&ensp;&ensp;&ensp;出现上述两种情况的原因都是由于内存容量不够大，解决方法有：<br>&ensp;&ensp;&ensp;&ensp;物理上增加内存容量：但这往往受到机器自身的限制，而且无疑增加了系统成本，因此这种方法是受到一定限制的。<br>&ensp;&ensp;&ensp;&ensp;逻辑上扩充内存容量：这正是虚拟存储技术所要解决的问题。  </p>
<h2 id="5-1-虚拟存储器概述"><a href="#5-1-虚拟存储器概述" class="headerlink" title="5.1 虚拟存储器概述"></a>5.1 虚拟存储器概述</h2><h3 id="5-1-1-常规存储管理方式的特征和局部性原理"><a href="#5-1-1-常规存储管理方式的特征和局部性原理" class="headerlink" title="5.1.1 常规存储管理方式的特征和局部性原理"></a>5.1.1 常规存储管理方式的特征和局部性原理</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.常规存储管理的特征</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）一次性（指全部装入）<br>&ensp;&ensp;&ensp;&ensp;2）驻留性（指驻留在内存不换出）  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.局部性原理</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）时间局部性：一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内；（循环操作<br>&ensp;&ensp;&ensp;&ensp;2）空间局部性：当前指令和邻近的几条指令，当前访问的数据和邻近的数据都集中在一个较小区域内。（顺序执行     </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.虚拟存储器的基本工作情况</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;应用程序仅将当前要运行的少数页面或段调入内存便可运行，其余部分暂留在外存上，运行时如果出现所需访问的页／段尚未调入内存，则发出缺页／段请求，此时，OS利用请求调入功能将它们调入内存，如果此时内存已满，OS利用置换功能，将内存中不用的页／段调至外存。 </p>
<h3 id="5-1-2-虚拟存储器的定义和特征"><a href="#5-1-2-虚拟存储器的定义和特征" class="headerlink" title="5.1.2 虚拟存储器的定义和特征"></a>5.1.2 虚拟存储器的定义和特征</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.虚拟存储器的定义</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;所谓的虚拟存储器，是指<strong>具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统</strong>。<br>&ensp;&ensp;&ensp;&ensp;这样，可使一个大程序在小内存中运行。该系统具有的内存容量，将比实际大的多，这只是一种感觉，是虚的，故把这样的存储器称作虚拟存储器。其实质：<strong>以时间换空间</strong>，但时间牺牲不大。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 虚拟存储器的特征</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）多次性：指一个作业被分成多次调入内存运行，即在作业运行时没有必要将其全部装入，只须将当前要运行的那部分程序和数据装入内存即可。<br>&ensp;&ensp;&ensp;&ensp;2）对换性：指允许在作业的运行过程中在内存和外存的对换区之间换进、换出。<br>&ensp;&ensp;&ensp;&ensp;3）虚拟性：指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。它是虚拟存储器最重要的特征。<br>&ensp;&ensp;&ensp;&ensp;4）离散性：部分装入,支持大作业小内存运行,若连续则不可能提供虚存  </p>
<h3 id="5-1-3-虚拟存储器的实现方法"><a href="#5-1-3-虚拟存储器的实现方法" class="headerlink" title="5.1.3 虚拟存储器的实现方法"></a>5.1.3 虚拟存储器的实现方法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 分页请求系统</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;分页请求系统是在分页系统的基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）硬件支持<br>&ensp;&ensp;&ensp;&ensp;（1）请求分页的页表机制。<br>&ensp;&ensp;&ensp;&ensp;（2）缺页中断机构。<br>&ensp;&ensp;&ensp;&ensp;（3）地址变换机构。  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）实现请求分页的软件<br>&ensp;&ensp;&ensp;&ensp;具体包括用于实现请求调页的软件和实现页面置换的软件。它们在硬件的支持下，将程序正在运行时所需的页面 (尚未在内存中的)调入内存，再将内存中暂时不用的页面从内存置换到磁盘上。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 请求分段系统</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;请求分段系统是在分段系统的基础上增加了请求调段功能和分段置换功能所形成的段式虚拟存储系统。    </p>
<p>&ensp;&ensp;&ensp;&ensp;1）硬件支持<br>&ensp;&ensp;&ensp;&ensp;（1）请求分段的段表机制。<br>&ensp;&ensp;&ensp;&ensp;（2）缺段中断机构。<br>&ensp;&ensp;&ensp;&ensp;（3）地址变换机构。  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）实现请求分段的软件<br>&ensp;&ensp;&ensp;&ensp;具体包括用于实现请求调段的软件和实现分段置换的软件。它们在硬件的支持下，将程序正在运行时所需的分段 (尚未在内存中的)调入内存。相对于请求分段系统，因为请求分页系统换进和换出的进本单位是固定大小的页面，所以实现要容易些。</p>
<p>&ensp;&ensp;&ensp;&ensp;请求分页系统是建立在基本分页基础上的，为了能支持虚拟存储器的功能，而增加了请求调页功能和页面置换功能。相应的，每次调入和换出的基本单位都是长度固定的页面，这使得请求分页系统在实现上要比请求分段系统简单。因此，请求分页便成为目前最为常用的一种实现虚拟存储器的方式。  </p>
<h2 id="5-2-请求分页存储管理方式"><a href="#5-2-请求分页存储管理方式" class="headerlink" title="5.2 请求分页存储管理方式"></a>5.2 请求分页存储管理方式</h2><h3 id="5-2-1-请求分页中的硬件支持"><a href="#5-2-1-请求分页中的硬件支持" class="headerlink" title="5.2.1 请求分页中的硬件支持"></a>5.2.1 请求分页中的硬件支持</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 页表机制</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;它是在纯分页的页表机制上形成的，由于只将应用程序的一部分调入内存，还有一部分仍在磁盘上，故需在页表中再增加4个字段，满足页面换进换出的需要。在请求分页系统中的每个页表项如图所示。<br><img src="/2021/06/16/os-5/%E5%9B%BE%E7%89%871.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）状态位P：用于指示该页是否已调入内存，供程序访问时参考。 1—在内存；0—不在内存。<br>&ensp;&ensp;&ensp;&ensp;2）访问字段A：用于记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问，提供给置换算法选择换出页面时参考。页面访问频度。<br>&ensp;&ensp;&ensp;&ensp;3）外存地址：用于指出该页在外存上的地址，通常是物理块号，供调入该页时使用。<br>&ensp;&ensp;&ensp;&ensp;4）修改位M：表示该页在调入内存后是否被修改过。由于内存中的每一页都在外存上保留一份副本，因此，若未被修改，在置换该页时就不需将该页写回到外存上，以减少系统的开销和启动磁盘的次数；若已被修改，则必须将该页重写到外存上，以保证外存中所保留的始终是最新副本。 </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 缺页中断机构</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;在请求分页系统中，每当所要访问的页面不在内存时，便要产生一缺页中断，请求OS将所缺页调入内存。缺页中断是一种特殊的中断，与一般中断的主要区别在于：<br>&ensp;&ensp;&ensp;&ensp;1）缺页中断在指令执行期间产生和处理中断信号，而一般中断在一条指令执行完后检查和处理中断信号。所缺的页面调入之后，重新执行被中断的指令。<br>&ensp;&ensp;&ensp;&ensp;2）一条指令在执行期间，可能产生多次缺页中断。  </p>
<p>&ensp;&ensp;&ensp;&ensp;在执行一条指令 copy A to B，可能产生6次缺页中断，其中指令本身跨越了两个页面。A和B又分别各是一个数据块，也跨越了两个页面。<br><img src="/2021/06/16/os-5/%E5%9B%BE%E7%89%872.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 地址变换机构</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;请求分页系统中的地址变换机构，是在分页系统的地址变换机构的基础上，再为实现虚拟存储器而增加了某些功能所形成的，如产生和处理缺页中断，以及从内存中换出一页的功能等等，下图给出了请求分页系统的地址变换过程。<br><img src="/2021/06/16/os-5/%E5%9B%BE%E7%89%873.png">   </p>
<h3 id="5-2-2-请求分页中的内存分配"><a href="#5-2-2-请求分页中的内存分配" class="headerlink" title="5.2.2 请求分页中的内存分配"></a>5.2.2 请求分页中的内存分配</h3><p>&ensp;&ensp;&ensp;&ensp;在为进程分配内存时，将涉及到三个问题：<br>&ensp;&ensp;&ensp;&ensp;1）为保证进程能正常运行，所需要的最小物理块数的确定；<br>&ensp;&ensp;&ensp;&ensp;2）在为每个进程分配物理块时，应采取什么样的分配策略，即所分配的物理块数是固定的还是可变的；<br>&ensp;&ensp;&ensp;&ensp;3）为不同进程所分配的物理块数，是采取平均分配算法，还是根据进程的大小按比例分配。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 最小物理块数的确定</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在为进程分配物理块时，首先应该考虑的问题是：能保证进程能正常运行所需的最少物理块数。若系统为某进程所分配的物理块数少于此值时，进程将无法运行，这取决于指令的格式、功能和寻址方式。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 内存分配策略</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在请求分页系统中，可采取两种分配策略，固定和可变分配策略。在进行置换时，也可采取两种策略，全局置换和局部置换。于是可组合成以下三种策略。  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）固定分配局部置换<br>&ensp;&ensp;&ensp;&ensp;所谓固定分配，是指为每个进程分配一固定数目的物理块，在进程整个运行期间都不再改变。所谓局部置换，是指如果进程在运行中发现缺页，则只能从固定物理块中选出一页换出，然后再调入另一页，保证分配给该进程的内存空间不变。  </p>
<p>&ensp;&ensp;&ensp;&ensp;困难：物理块数目难以确定<br>&ensp;&ensp;&ensp;&ensp;太少：缺页中断频繁，吞吐量降低<br>&ensp;&ensp;&ensp;&ensp;太多：进程数目少，资源利用率低；进程对换耗时  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）可变分配全局置换<br>&ensp;&ensp;&ensp;&ensp;所谓可变分配，是指先为每个进程分配一定数目的物理块，在进程运行期间可根据情况做适当的增加或减少。所谓全局置换，是指如果进程在运行中发现缺页，则将OS所保留的空闲物理块取出一块分配给该进程，或以所有进程的全部物理块为标的，选择一块换出，然后将所缺之页调入。这样，分配给该进程的内存空间随之增加。  </p>
<p>&ensp;&ensp;&ensp;&ensp;采用这种策略时，凡产生缺页中断的进程，都将获得新的物理块，仅当空闲物理块用完时，OS才从内存中选择一页调出，被选择调出的页可能是系统中任何一个进程中的页，因此，这个被选中的进程拥有的物理块会减少，导致缺页率增加。  </p>
<p>&ensp;&ensp;&ensp;&ensp;3）可变分配局部置换<br>&ensp;&ensp;&ensp;&ensp;根据进程的类型或程序员的要求，为每个进程分配一定数目的内存空间；但当某进程发生缺页时，只允许从该进程在内存的页面中选出一页换出，而不影响其它进程的运行。系统根据该进程运行中缺页率的高低来增加或减少分配给该进程的物理块。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 物理块分配算法</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;在采用固定分配策略时，可采用以下几种物理块分配方法：  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）平均分配算法：将系统中所有可供分配的物理块，平均分配给各个进程。<br>&ensp;&ensp;&ensp;&ensp;2）按比例分配算法：这是根据进程的大小按比例分配物理块。<br>&ensp;&ensp;&ensp;&ensp;3）考虑优先权的分配算法：该方法是把内存中可供分配的所有物理块分成两部分：<strong>一部分按比例分配给各进程</strong>；另一部分则根据各进程的优先权，适当地增加其相应份额后，分配给各进程。  </p>
<h3 id="5-2-3-页面调入策略"><a href="#5-2-3-页面调入策略" class="headerlink" title="5.2.3 页面调入策略"></a>5.2.3 页面调入策略</h3><p>&ensp;&ensp;&ensp;&ensp;为使进程能够正常运行，必须事先将要执行的那部分程序和数据所在的页面调入内存。现在的问题是：  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）系统应在何时调入所需的页面；<br>&ensp;&ensp;&ensp;&ensp;2）系统应从何处调入这些页面；<br>&ensp;&ensp;&ensp;&ensp;3）页面是如何调入的。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 何时调入页面</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）预调页策略：是一种主动的缺页调入策略，即将那些预计在不久的将来会被访问的程序或数据所在的页面，预先调入内存。一次调入若干个相邻的页，会比一次调入一页更高效些。但如果调入的一批页面中的大多数都未被访问，则又是低效的。可采用一种以预测为基础的预调页策略，将那些预计在不久之后便会被访问的页面预先调入内存。<br>&ensp;&ensp;&ensp;&ensp;2）请求调页策略：是指当进程在运行中发生缺页时，就立即提出请求，由系统将缺页调入内存。目前的虚拟存储器中，大多采用此策略。但这种策略每次仅调入一页，在调页时须花费较大的系统开销，如需频繁启动磁盘I/O。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 从何处调入页面</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;虚拟存储系统中，外存（硬盘）常常被分成两部分:文件区和对换区。通常，对换区的磁盘I/O速度比文件区要高。缺页调入分为三种情况：  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）系统有足够大的对换区空间，这时可以全部从对换区调入所需页面，以提高调页速度。为此，在进程运行前，须将与该进程有关的文件从文件区拷贝到对换区。<br>&ensp;&ensp;&ensp;&ensp;2）系统缺少足够的对换空间，这时凡是不会被修改的文件，都直接从文件区调入；而当换出这些页面时，由于它们未被修改，不必重写入磁盘，以后再调入时，仍从文件区直接调入。对于那些被修改的部分，在将它们换出时便须调到对换区，以后需要时再从对换区调入。<br>&ensp;&ensp;&ensp;&ensp;3）UNIX方式： 在UNIX系统中，对于从未运行过的页面，都应从硬盘文件区调入；对于曾经运行过而又被换出的页面，可以从对换区调入；对于共享页面，该页面可能已由其它进程调入内存，此时就无须再从对换区调入。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 页面调入过程</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;每当程序所需访问的页面未在内存时（状态位为“0”），①便向CPU发出缺页中断，中断处理程序首先保留CPU环境，分析中断原因后转入中断处理程序。②该程序通过查找页表得到该页在外存的物理块后，如果此时内存尚能容纳新页，则启动磁盘I/O，将所缺之页调入内存，然后修改页表。③如果内存已满，则须按照某种置换算法，从内存中选出一页换出。如果该页未被修改，可不必将其写回磁盘；但如果该页已被修改，则必须将它写回磁盘，然后将所缺页调入，修改页表项，④并将该<strong>页表项写入快表</strong>。在缺页调入内存后，利用修改的页表形成所需访问的物理地址，再去访问内存数据。</p>
<p>&ensp;&ensp;&ensp;&ensp;①程序缺页时，发出一缺页中断请求，转入中断处理程序。<br>&ensp;&ensp;&ensp;&ensp;②该程序查找页表，得到缺页在外存的物理块号；若内存有空间，则调入所缺页，并修改页表。<br>&ensp;&ensp;&ensp;&ensp;③若内存已满，则按照某种置换算法从内存中选出一页换出，并调入所缺页，修改页表。<br>&ensp;&ensp;&ensp;&ensp;④更新快表，利用修改后的页表，形成所访问的物理地址，再去访问内存数据。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4. 缺页率</strong> </p>
<p>&ensp;&ensp;&ensp;&ensp;假设一个进程的逻辑空间为n页，系统为其分配的物理块数为m(m&lt;=n).如果在进程的运行中，访问页面成功的次数为S，访问页面失败的次数为F，则该进程总的页面访问次数为A=S+F，那么进程运行过程中的缺页率为：<br> &ensp;&ensp;&ensp;&ensp;f=F/A<br>&ensp;&ensp;&ensp;&ensp;通常，缺页率受以下因素影响：<br>&ensp;&ensp;&ensp;&ensp;（1）页面大小。页面划分较大，则缺页率较低；反之，缺页率较高。<br>&ensp;&ensp;&ensp;&ensp;（2）进程所分配的物理块数。所分配的物理块数目越多，则缺页率越低；反之，缺页率越高。<br>&ensp;&ensp;&ensp;&ensp;（3）页面置换算法。算法的优劣决定了进程执行过程中缺页中断的次数，因此缺页率是衡量页面置换算法的一个重要指标。<br>&ensp;&ensp;&ensp;&ensp;（4）程序固有特性。程序本身的编制方法对缺页中断的次数有影响，根据程序执行的局部性原理，程序的局部化程度越高，相应执行时的缺页程度越低。<br>&ensp;&ensp;&ensp;&ensp;事实上，在缺页中断时，当内存不足需要置换部分页面到外存时，选择被置换页面还需要考虑到置换的代价。如页面是否被修改过。<br>&ensp;&ensp;&ensp;&ensp;假设被置换页面被修改的概率为β ，其缺页中断处理时间为ta, 被置换页面未被修改的中断处理时间为tb, 那么缺页中断处理时间为：<br>&ensp;&ensp;&ensp;&ensp;t = β*ta + (1- β)*tb  </p>
<p>练习ppt 第五章 40-42</p>
<h2 id="5-3-页面置换算法"><a href="#5-3-页面置换算法" class="headerlink" title="5.3 页面置换算法"></a>5.3 页面置换算法</h2><p>&ensp;&ensp;&ensp;&ensp;在进程运行过程中，如果发生缺页，此时内存中又无空闲块时，为了保证进程能正常运行，就必须从内存中调出一页程序或数据送磁盘的对换区。<br>&ensp;&ensp;&ensp;&ensp;置换算法的好坏将直接影响系统的性能，不适当的算法可能会导致进程发生“抖动”（Thrashing)。即刚被换出的页很快又被访问，需重新调入，导致系统频繁地更换页面，以致一个进程在运行中把大部分时间花费在完成页面置换的工作上，我们称该进程发生了“抖动”。  </p>
<h3 id="5-3-1-最佳置换算法和先进先出置换算法"><a href="#5-3-1-最佳置换算法和先进先出置换算法" class="headerlink" title="5.3.1 最佳置换算法和先进先出置换算法"></a>5.3.1 最佳置换算法和先进先出置换算法</h3><p>&ensp;&ensp;&ensp;&ensp;下面介绍的是两种极端的算法。最佳置换算法是一种理想化的算法，它具有最好的性能，但实际上是无法实现的。通常使用最佳置换算法作为标准，来评价其他算法的优劣。<br>&ensp;&ensp;&ensp;&ensp;先进先出置换算法是最直观的算法，由于与通常页面的使用规律不符，可能是性能最差的算法，故实际应用极少。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 最佳(Optimal)置换算法</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;即选择那些永不使用的，或者是在最长时间内不再被访问的页面置换出去。<br>&ensp;&ensp;&ensp;&ensp;但是要确定哪一个页面是未来最长时间内不再被访问的，目前来说是很难估计的，所以该算法通常用来评价其它算法。<br>&ensp;&ensp;&ensp;&ensp;它是一种理想化的算法，性能最好，但难以实现。<br>&ensp;&ensp;&ensp;&ensp;假定系统为进程分配了三个物理块， 页面号引用序列为：7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1. 采用最佳置换算法，其置换过程如下：<br><img src="/2021/06/16/os-5/%E5%9B%BE%E7%89%874.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 先进先出(FIFO)页面置换算法</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。该算法实现简单，只需把一个进程已调入内存的页面按先后次序链接成一个队列，并设置一个指针，称为替换指针，它总是指向最老的页面。但该算法与进程<strong>实际运行的规律不相适应</strong>，因为在进程中，<strong>有些页面会被经常访问</strong>。<br><img src="/2021/06/16/os-5/%E5%9B%BE%E7%89%875.png">   </p>
<h3 id="5-3-2-最近最久未使用和最少使用置换算法"><a href="#5-3-2-最近最久未使用和最少使用置换算法" class="headerlink" title="5.3.2 最近最久未使用和最少使用置换算法"></a>5.3.2 最近最久未使用和最少使用置换算法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. LRU(Least Recently Used)置换算法的描述</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;LRU算法是根据页面调入内存后的使用情况作出决策的。由于无法预测各页面将来的使用情况，只能利用“最近的过去”作为“最近的未来”的近似。<br>&ensp;&ensp;&ensp;&ensp;该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面淘汰。<br><img src="/2021/06/16/os-5/%E5%9B%BE%E7%89%876.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. LRU置换算法的硬件支持</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）寄存器<br>&ensp;&ensp;&ensp;&ensp;为了记录某进程在内存中各页的使用情况，须为每个在内存中的页面配置一个移位寄存器，可表示为：<br>&ensp;&ensp;&ensp;&ensp;R=Rn-1Rn-2Rn-3 … R2R1R0<br>&ensp;&ensp;&ensp;&ensp;当进程访问某物理块时，要将相应寄存器的Rn-1位置成1。此时，定时信号每隔一定时间将寄存器右移一位。<br>&ensp;&ensp;&ensp;&ensp;如果把寄存器的数看做是一个整数，那么具有最小数值的寄存器所对应的页面，就是最近最久未使用的页面。<br><img src="/2021/06/16/os-5/%E5%9B%BE%E7%89%877.png">      </p>
<p>&ensp;&ensp;&ensp;&ensp;2）栈<br>&ensp;&ensp;&ensp;&ensp;可利用一个特殊的栈保存当前使用的各个页面的页面号。每当进程访问页面时，便将该页的页面号从栈中移出，将它压入栈顶。因此，栈顶始终是最新被访问页面的编号，而栈底则是最近最久未使用页面的页号。<br><img src="/2021/06/16/os-5/%E5%9B%BE%E7%89%878.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 最少使用(Least Frequently Used, LFU)置换算法</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;为在内存的每个页面设置一个移位寄存器，用来记录该页面被访问的频率。该算法选择在最近时间使用最少的页面作为淘汰页。<br>&ensp;&ensp;&ensp;&ensp;具体而言，每次访问某页时，将该页移位寄存器的最高位置为1，每隔一定时间右移一次，这样，∑Ri最小的页即为最近一段时间最少使用的页面。  </p>
<h3 id="5-3-3-Clock置换算法"><a href="#5-3-3-Clock置换算法" class="headerlink" title="5.3.3 Clock置换算法"></a>5.3.3 Clock置换算法</h3><p>&ensp;&ensp;&ensp;&ensp;虽然LRU是一种较好的算法，但实现成本较高。故在实际中，大多采用LRU的近似算法。Clock算法就是用得较多的一种LRU的近似算法。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 简单的Clock置换算法</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;只需为每一页设置一位访问位，再将内存中所有页面通过链接指针链成一个循环队列。当某页被访问时，其访问位置为1。算法在选择一页淘汰时，只需检查访问位。如果为0，则选择该页换出；若为1，则重新将它置为0。继续检查下一页。当最后一页访问位仍为1时，返回队首检查。<br><img src="/2021/06/16/os-5/%E5%9B%BE%E7%89%879.png">   <img src="/2021/06/16/os-5/%E5%9B%BE%E7%89%8710.png">       </p>
<p>也称最近未用（NRU）算法，它是LRU和FIFO的折中。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 改进型Clock置换算法</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;该算法除考虑页面的使用情况外，还增加了一个因素即置换代价。这样，选择页面换出时，既要是未使用过的页面，又要是未被修改过的页面。把同时满足两个条件的页面作为首选淘汰的页面。<br>&ensp;&ensp;&ensp;&ensp;由访问字段A和修改位M可以组合成下面四种类型的页面。<br>&ensp;&ensp;&ensp;&ensp;1类（A=0, M=0）：表示该页最近既未被访问，又未被修改，是最佳淘汰页。<br>&ensp;&ensp;&ensp;&ensp;2类（A=0, M=1）：表示该页最近未被访问，但已被修改，并不是很好的淘汰页。<br>&ensp;&ensp;&ensp;&ensp;3类（A=1, M=0）：最近已被访问，但未被修改，该页有可能再被访问。<br>&ensp;&ensp;&ensp;&ensp;4类（A=1, M=1）：最近已被访问且被修改，该页可能再被访问。   </p>
<p>&ensp;&ensp;&ensp;&ensp;算法执行分为以下三步：<br>&ensp;&ensp;&ensp;&ensp;①从指针所指示的当前位置开始，扫描循环队列，寻找A=0且M=0的第一类页面，将所遇到的一个页面选为淘汰页。在此期间不改变访问位A。<br>&ensp;&ensp;&ensp;&ensp;②如果第一步失败，则开始第二轮扫描，寻找A=0且M=1的页面，把所遇到的一个页面选为淘汰页。在<strong>此期间将所有扫描过的页面访问位设置为0</strong>。<br>&ensp;&ensp;&ensp;&ensp;③如果第二步也失败，则重复第一步。如果仍然失败，重复第二步，必能找到淘汰页。  </p>
<p>练习 ppt 第五章 63</p>
<h3 id="5-3-4-页面缓冲算法（PBA）"><a href="#5-3-4-页面缓冲算法（PBA）" class="headerlink" title="5.3.4 页面缓冲算法（PBA）"></a>5.3.4 页面缓冲算法（PBA）</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 影响页面换进换出的若干因素</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）页面置换算法。好的页面算法可以使进程运行中的缺页率降低，从而减少换入换出开销。<br>&ensp;&ensp;&ensp;&ensp;2）写回磁盘的频率。对于已经被修改的页面，在将其换出时，应当写回磁盘。写回磁盘的频率决定了磁盘I/O次数。<br>&ensp;&ensp;&ensp;&ensp;3）读入内存的频率。如果设置了已修改换出页面链表，将减少页面从磁盘读入内存的频率，进而减少页面换进的开销  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 页面缓冲算法PBA</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;特点：1）显著的降低了页面换进换出的频率，进而减少了系统开销。2）可以采用简单的置换策略，不需特殊硬件支持，实现简单。<br>&ensp;&ensp;&ensp;&ensp;该算法在页面分配时，采用可变分配和局部置换的方式。即系统为每个进程分配一定数目的物理块，系统自己保留一部分空闲物理块。为了降低页面换进换出的频率，在内存中设置如下两个链表：<br>&ensp;&ensp;&ensp;&ensp;1）空闲页面链表<br>&ensp;&ensp;&ensp;&ensp;实际是一个空闲物理块链表。当进程因缺页需要读入新的一页时，可利用该链表的第一个物理块来装入该页。当一个未被修改的页面要换出时，是将其所在物理块挂在该链表末尾。当以后进程再需要该页时，可以从链表中将之取下，减少页面换进开销。<br>&ensp;&ensp;&ensp;&ensp;2）修改页面链表<br>&ensp;&ensp;&ensp;&ensp;它由已修改的页面形成。当一个已修改页面换出时，系统并不立即把它换至外存，而是将它的物理块挂在修改页面链表末尾。  </p>
<p>&ensp;&ensp;&ensp;&ensp;它是对FIFO算法的发展，通过被置换页面的缓冲，有机会找回刚被置换的页面；<br>&ensp;&ensp;&ensp;&ensp;被置换页面的选择和处理：用FIFO算法选择被置换页，把被置换的页面放入两个链表之一。<br>&ensp;&ensp;&ensp;&ensp;如果页面未被修改，就将其归入到空闲页面链表的末尾否则将其归入到已修改页面链表。<br>&ensp;&ensp;&ensp;&ensp;需要调入新的物理页面时，将新页面内容读入到空闲页面链表的第一项所指的物理块中，并修改其页表项。<br>&ensp;&ensp;&ensp;&ensp;空闲页面和已修改页面，仍停留在内存中一段时间，如果这些页面被再次访问，只需较小开销，而被访问的页面可以返还作为进程的内存页。<br>&ensp;&ensp;&ensp;&ensp;当已修改页面达到一定数目后，再将它们一起写回到外存，然后将它们归入空闲页面链表，这样能大大减少I/O操作的次数。  </p>
<h3 id="5-3-5-访问内存的有效时间"><a href="#5-3-5-访问内存的有效时间" class="headerlink" title="5.3.5 访问内存的有效时间"></a>5.3.5 访问内存的有效时间</h3><p>&ensp;&ensp;&ensp;&ensp;与基本分页方式不同，在请求分页系统中，EAT不仅要考虑访问页表和访问实际物理地址数据时间，还要考虑缺页中断的处理时间。具体分析如下：<br>&ensp;&ensp;&ensp;&ensp;EAT：内存的有效访问时间，λ：查找快表的时间，t：访问实际物理地址所需的时间 ，ε：缺页中断时间，a：命中率，f：缺页率<br>&ensp;&ensp;&ensp;&ensp;（1）被访问页在内存中，且其对应的页表项在快表中。<br>&ensp;&ensp;&ensp;&ensp;EAT = λ + t<br>&ensp;&ensp;&ensp;&ensp;（2）被访问页在内存中，但其对应的页表项不在快表中。<br>&ensp;&ensp;&ensp;&ensp;EAT = λ + t + λ + t = 2*(λ + t)<br>&ensp;&ensp;&ensp;&ensp;（3）被访问页不在内存中假设缺页中断处理时间为 ε，则<br>&ensp;&ensp;&ensp;&ensp;EAT = λ + t + ε + λ + t = ε + 2*(λ + t)<br>&ensp;&ensp;&ensp;&ensp;上述没有考虑快表命中率和缺页率等因素，加入这两个因素后，内存的有效访问时间为:<br>&ensp;&ensp;&ensp;&ensp;EAT = λ + a<em>t + (1-a)</em> [t + f*(ε + λ + t) + (1-f)*(λ + t)]  </p>
<p>习题 ppt 第五章 70-77</p>
<h2 id="5-4-抖动与工作集（略）"><a href="#5-4-抖动与工作集（略）" class="headerlink" title="5.4 抖动与工作集（略）"></a>5.4 抖动与工作集（略）</h2><p>&ensp;&ensp;&ensp;&ensp;由于请求分页式虚拟存储器系统的性能优越，在正常情况下，它能有效地减少内存碎片，提高处理机的利用率和吞吐量，故是目前最常用的一种系统。但如果在系统中运行的进程太多，进程频繁的发生缺页情况，这又会对系统的性能产生很大的影响，故还须对请求分页系统的性能做简单的分析。  </p>
<h3 id="5-4-1-多道程序度与“抖动”"><a href="#5-4-1-多道程序度与“抖动”" class="headerlink" title="5.4.1 多道程序度与“抖动”"></a>5.4.1 多道程序度与“抖动”</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 多道程序度与处理机的利用率</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在虚拟存储系统中，由于进程只需装入部分程序和数据即可运行，故人们希望在系统中运行更多的进程，即增加多道程序度，以提高处理机的利用率。利用率急剧下降的原因是系统中发生了“抖动”。<br><img src="/2021/06/16/os-5/%E5%9B%BE%E7%89%8711.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 产生抖动的原因</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;根本原因是：同时在系统中运行的进程太多，由此分配给每个进程的物理块数太少，不能满足进程正常运行的需求，致使每个进程在运行时，频繁的发生缺页，必须请求系统将所缺之页调入内存。   </p>
<p>&ensp;&ensp;&ensp;&ensp;页面淘汰算法不合理<br>&ensp;&ensp;&ensp;&ensp;系统分配给进程的物理块太少<br>&ensp;&ensp;&ensp;&ensp;当大量的进程大部分时间用于页面换进换出时，会导致处理机利用率急剧下降趋于0的情况，我们称此时的进程处于“抖动”状态。  </p>
<h3 id="5-4-2-工作集"><a href="#5-4-2-工作集" class="headerlink" title="5.4.2 工作集"></a>5.4.2 工作集</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 工作集的基本概念</strong>  </p>
<p><img src="/2021/06/16/os-5/%E5%9B%BE%E7%89%8712.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;从图中可以看出，缺页率随着所分得的物理块数目的减少而递增，并在所分到的物理块数目较少处，出现一个拐点。在拐点上限以左时，随着分到的物理块数目的增加，缺页率明显地减少；而过了拐点，在下限以右时，随着分到的物理块数目的增加，却对缺页率的改善并不明显。所以，为进程分配的物理块数，应取在该曲线的拐点左右。   </p>
<p>&ensp;&ensp;&ensp;&ensp;工作集的理论是在1968年由Denning提出来的。他认为，程序在运行时对页面的访问是不均匀的，即往往在某段时间内的访问仅局限于较少的若干个页面，如果能够预知程序在某段时间间隔内要访问哪些页面，并能将它们提前调入内存，将会大大地降低缺页率，从而减少置换工作，提高CPU的利用率。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 工作集的定义</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;所谓工作集是指，在某段时间间隔（Δ）里，进程实际要访问的页面的集合。<br>&ensp;&ensp;&ensp;&ensp;Denning认为，虽然程序只需少量的几页在内存就可以运行，但为了使程序能够有效地运行，较少地产生缺页、就必须使程序的工作集全部在内存中。把某进程在时间t的工作集记为w（t，Δ），把变量Δ称为工作集“窗口尺寸”（Windows Size）。正确选择工作集窗口（Δ）的大小，对存储器的有效利用和系统吞吐量的提高，都将产生重要的影响。  </p>
<p>&ensp;&ensp;&ensp;&ensp;具体地说，是把某进程在时间t的工作集记为w(t，Δ),其中的变量Δ称为工作集的“窗口尺寸”。右图是某进程访问页面的序列和窗口大小分别为3、4、5时的工作集。<br>&ensp;&ensp;&ensp;&ensp;由此可将工作集定义为：进程在时间间隔（t-Δ，t）中引用页面的集合。<br>&ensp;&ensp;&ensp;&ensp;工作集w(t，Δ)是二元函数，即在不同时间t的工作集大小不同，所含的页面数也不同；与窗口尺寸Δ有关。工作集大小是窗口尺寸Δ的非降函数：<br><img src="/2021/06/16/os-5/%E5%9B%BE%E7%89%8713.png">   </p>
<p><img src="/2021/06/16/os-5/%E5%9B%BE%E7%89%8714.png">  </p>
<h3 id="5-4-3-抖动的预防方法"><a href="#5-4-3-抖动的预防方法" class="headerlink" title="5.4.3 抖动的预防方法"></a>5.4.3 抖动的预防方法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 采取局部置换策略</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;*在页面分配和置换策略中，如果使用的是可变分配方式则为了预防“抖动”，可采取局部置换策略。<br>&ensp;&ensp;&ensp;&ensp;*当进程发生缺页时，只能在分配给自己的内存空间内进行置换，不允许从其他进程去获得新的物理块。这样即使进程发生了“抖动”，也不会对其他进程产生影响，把该进程“抖动”所造成的影响限制在较小的范围内。<br>&ensp;&ensp;&ensp;&ensp;*但该方法的效果并不是很好。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 把工作集算法融入到处理机调度中</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;当调度程序发现处理机利用率低下时，它将试图从外存调入一个新作业进入内存，来改善处理机的利用率。如果在调度中融入了工作集算法，则在调度程序从外存调入作业之前，必须先检查每个进程在内存的驻留页面是否足够多。如果足够多，则可以调入新作业；反之，此时则不再调入新的作业。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 利用“L=S”准则调节缺页率</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;Denning于1980年提出了“L=S”的准则来调节多道程序度，其中L是缺页之间的平均时间，S是平均缺页服务时间，即用于置换一个页面的时间。如果L远比S大，说明很少发生缺页，磁盘的能力尚未充分利用；反之，L远比S小，说明频繁发生缺页，缺页的速度已经超出了磁盘的处理能力。只有当L与S接近时，磁盘和处理机都可达到它们的最大利用率。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4. 选择暂停的进程</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;当多道程序度很高时，已影响到处理机的利用率，为了防止“抖动”，系统必须减少多道程序的数目。此时应基于某种原则选择暂停某些当前活动的进程，将它们调出到磁盘上，以便把腾出的内存空间分配给缺页率发生偏高的进程。  </p>
<h2 id="5-5-请求分段存储管理方式"><a href="#5-5-请求分段存储管理方式" class="headerlink" title="5.5 请求分段存储管理方式"></a>5.5 请求分段存储管理方式</h2><h3 id="5-5-1-请求分段中的硬件支持"><a href="#5-5-1-请求分段中的硬件支持" class="headerlink" title="5.5.1 请求分段中的硬件支持"></a>5.5.1 请求分段中的硬件支持</h3><p>&ensp;&ensp;&ensp;&ensp;在请求分段系统中，是以分段为单位进行换入换出的。程序运行之前，只需先调入少数几个分段（不必调入所有的分段）便可启动运行。当所访问的分段不在内存中时，可请求OS将所缺的段调入内存。<br>&ensp;&ensp;&ensp;&ensp;同请求分页系统一样，为实现请求分段存储管理方式，需要一定的硬件支持和相应的软件。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 请求段表机制</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;在请求分段式管理中在段表中增加若干项，以供程序在调进、调出时参考。请求分段的段表项如下：<br><img src="/2021/06/16/os-5/%E5%9B%BE%E7%89%8715.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;在段表项中，除了段名，段长和段基址外，还增加了以下字段：<br>&ensp;&ensp;&ensp;&ensp;1）存取方式：用于标识本分段的存取属性是只执行、只读，还是允许读／写。<br>&ensp;&ensp;&ensp;&ensp;2）访问字段A：用于记录该段被访问的频繁程度。<br>&ensp;&ensp;&ensp;&ensp;3）修改位M：用于表示该段进入内存后，是否已被修改过。<br>&ensp;&ensp;&ensp;&ensp;4）存在位P：说明本段是否已调入内存。<br>&ensp;&ensp;&ensp;&ensp;5）增补位：用于表示本段在运行过程中，是否进行过动态增长。<br>&ensp;&ensp;&ensp;&ensp;6）外存起址：指示本段在外存中的起始地址，即起始盘块号。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 缺段中断机构</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在请求分段系统中采用的是请求调段策略。每当发现运行进程所要访问的段尚未调入内存时，便由缺段中断机构产生一个中断信号，进入OS后，由缺段中断处理程序将所需的段调入内存。<br>&ensp;&ensp;&ensp;&ensp;在请求分段系统中，由于分段是信息的逻辑单位，因而不可能出现一条指令被分割在两个分段中，和一组信息被分割在两个分段中的情况。<br><img src="/2021/06/16/os-5/%E5%9B%BE%E7%89%8716.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 地址变换机构</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;请求分段系统中的地址变换机构，是在分段系统地址变换机构的基础上形成的。由于被访问的段并非全在内存，所以在地址变换时，若发现所要访问的段不在内存时，必须先将所缺的段调入内存，并修改了段表之后，才能再利用段表进行地址变换。为此，在地址变换机制中又增加了某些功能，如缺段中断的请求及其处理等。<br><img src="/2021/06/16/os-5/%E5%9B%BE%E7%89%8717.png">   </p>
<h3 id="5-5-2-分段的共享和保护"><a href="#5-5-2-分段的共享和保护" class="headerlink" title="5.5.2 分段的共享和保护"></a>5.5.2 分段的共享和保护</h3><p>&ensp;&ensp;&ensp;&ensp;分段存储管理方式实现分段的共享和保护只须在每个进程的段表中，用相应的表项来指向共享段在内存中的起始地址。为了实现分段共享，应配置相应的共享段表，用来对共享段进行操作。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 共享段表</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;为实现段的共享，系统中配置一张共享段表，所有各共享段都在共享段表中占有一个表项。在表项上记录了共享段的段号，段长，内存始址，状态位，外存始址以及共享计数等信息。<br><img src="/2021/06/16/os-5/%E5%9B%BE%E7%89%8718.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;共享进程计数器COUNT：记录有多少个进程需要共享该分段。<br>&ensp;&ensp;&ensp;&ensp;存取控制字段：说明不同的进程对该分段不同的存取权限。<br>&ensp;&ensp;&ensp;&ensp;段号：对于同一个共享段，不同的进程可以使用不同的段号去共享该段。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 共享段的分配与回收</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）分配：<br>&ensp;&ensp;&ensp;&ensp;第一次访问：分配内存，（1）增加共享段表；（2）修改进程段表。<br>&ensp;&ensp;&ensp;&ensp;第二次访问：（1）修改共享段表；（2）修改进程段表。<br>&ensp;&ensp;&ensp;&ensp;2）回收：撤销调用进程段表中共享段所对应的表项，执行Count减1。<br>&ensp;&ensp;&ensp;&ensp;（1）count=0系统回收共享段的物理内存，以及取消在共享段表中该段所对应的表项。<br>&ensp;&ensp;&ensp;&ensp;（2）count≠0取消调用者进程在共享段表中的记录。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 分段保护</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）越界检查<br>&ensp;&ensp;&ensp;&ensp;段号越界检查。<br>&ensp;&ensp;&ensp;&ensp;段内偏移越界检查。<br>&ensp;&ensp;&ensp;&ensp;2）存取控制检查。<br>&ensp;&ensp;&ensp;&ensp;R；R/W；E<br>&ensp;&ensp;&ensp;&ensp;3）环保护机构<br>&ensp;&ensp;&ensp;&ensp;内环可访问外环数据；<br>&ensp;&ensp;&ensp;&ensp;外环可请求内环服务。<br><img src="/2021/06/16/os-5/%E5%9B%BE%E7%89%8719.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;程序间的控制传输：一个程序可以调用驻留在相同环或较高特权环中的服务<br>&ensp;&ensp;&ensp;&ensp;数据访问：一个程序可以调用驻留在相同环或较低特权环中的数据  </p>
<p>练习 ppt 第五章 111</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记——第三章</title>
    <url>/2021/05/10/os-3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>个人操作系统笔记整理，欢迎参考，时不时更新。  </p>
<span id="more"></span>

<h1 id="第三章-处理机调度与死锁"><a href="#第三章-处理机调度与死锁" class="headerlink" title="第三章 处理机调度与死锁"></a>第三章 处理机调度与死锁</h1><h2 id="3-1-处理机调度的层次和调度算法的目标"><a href="#3-1-处理机调度的层次和调度算法的目标" class="headerlink" title="3.1 处理机调度的层次和调度算法的目标"></a>3.1 处理机调度的层次和调度算法的目标</h2><h3 id="3-1-1-处理机调度的层次"><a href="#3-1-1-处理机调度的层次" class="headerlink" title="3.1.1 处理机调度的层次"></a>3.1.1 处理机调度的层次</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.高级调度</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;又称长程调度或作业调度，它的调度对象是作业将外存作业调入内存，创建PCB等，插入就绪队列。一般用于批处理系统，分/实时系统一般直接入内存，无此环节。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.低级调度</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;又称进程调度或短程调度，调度对象是进程。进程调度是最基本的一种调度，在多道批处理、分时和实时三种类型的OS中，都必须配置这级调度。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.中级调度</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;中级调度又称为内存调度。引入中级调度的主要目的是，提高内存利用率和系统吞吐量。中级调度实际上就是存储器管理中的对换功能。<br>&ensp;&ensp;&ensp;&ensp;三种调度中，进程调度运行频率最高，在分时系统中通常是10~100ms便进行一次进程调度，因而进程调度算法不能太复杂。<br>&ensp;&ensp;&ensp;&ensp;作业调度往往是发生在一个（批）作业运行完毕，退出系统，而需要重新调入一个（批）作业进入时，帮作业调度的周期较长，大约几分钟一次。中级调度的运行频率，介于上述两种调度之间。  </p>
<p><img src="/2021/05/10/os-3/%E5%9B%BE%E7%89%871.png">  </p>
<h3 id="3-1-2-处理机调度算法的目标"><a href="#3-1-2-处理机调度算法的目标" class="headerlink" title="3.1.2 处理机调度算法的目标"></a>3.1.2 处理机调度算法的目标</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.处理机调度算法的共同目标</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）资源利用率。为提高系统的资源利用率，应使系统中的处理机和其它所有资源尽可能的保持忙碌状态。其中CPU的利用率可计算如下：<img src="/2021/05/10/os-3/%E5%9B%BE%E7%89%872.png"><br>&ensp;&ensp;&ensp;&ensp;（2）公平性。指应使诸进程都获得合理的CPU时间，不会发生进程饥饿现象。公平性是相对的。<br>&ensp;&ensp;&ensp;&ensp;（3）平衡性。由于系统中可能具有多种类型的进程，有的属于计算型作业，有的属于I/O型。为使CPU和各种外设经常处于忙碌状态，调度算法应尽可能保证系统资源使用的平衡性。<br>&ensp;&ensp;&ensp;&ensp;（4）策略强制执行。对于所制定的各种策略，如果需要，必须予以正确执行。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.批处理系统的目标</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）平均周转时间短。<br>&ensp;&ensp;&ensp;&ensp;周转时间：指作业被提交给系统开始，到作业完成为止的时间间隔。包括①作业在外存上的等待时间；②进程在就绪队列中等待时间；③进程在CPU上执行时间；④等待I/O时间。<br>&ensp;&ensp;&ensp;&ensp;对于每个用户，都希望自己的周转时间最短。作为计算机系统的管理者，则希望能使平均周转时间最短。  </p>
<p>平均周转时间可描述为：<img src="/2021/05/10/os-3/%E5%9B%BE%E7%89%873.png"><br>为了进一步反映调度的性能，描述各进程在其周转时间中，等待和执行时间的具体分配情况，往往使用带权周转时间。<br><img src="/2021/05/10/os-3/%E5%9B%BE%E7%89%874.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）系统吞吐量高。<br>&ensp;&ensp;&ensp;&ensp;吞吐量指在<strong>单位时间内系统完成的作业数</strong>。它与批处理作业的平均长度有关。如果单纯为了获得高的吞吐量，应尽量多的选择短作业运行。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（3）处理机利用率高<br>&ensp;&ensp;&ensp;&ensp;如果单纯为使处理机利用率高，应尽量选择计算量大的作业来运行。可以看出，上述要求之间存在着一定的矛盾。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.分时系统的目标</strong>（非重点，可略）  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）响应时间快。<br>&ensp;&ensp;&ensp;&ensp;响应时间：指从用户通过键盘提交一个请求开始，到系统首次产生响应为止的时间间隔。包括：键盘请求送入处理机时间；处理机处理请求时间；形成响应送回终端时间。<br>&ensp;&ensp;&ensp;&ensp;（2）均衡性。系统响应时间的快慢应与用户所请求服务的复杂性相适应。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.实时系统的目标</strong>（非重点，可略） </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）截止时间的保证。<br>&ensp;&ensp;&ensp;&ensp;截止时间：某任务必须开始执行的最迟时间，或必须完成的最迟时间。对于HRT任务，调度算法必须保证对截止时间的要求。对于SRT任务，调度算法应基本保证截止时间的要求。<br>&ensp;&ensp;&ensp;&ensp;（2）可预测性。  </p>
<h2 id="3-2-作业与作业调度"><a href="#3-2-作业与作业调度" class="headerlink" title="3.2 作业与作业调度"></a>3.2 作业与作业调度</h2><h3 id="3-2-1-批处理系统中的作业"><a href="#3-2-1-批处理系统中的作业" class="headerlink" title="3.2.1 批处理系统中的作业"></a>3.2.1 批处理系统中的作业</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.作业和作业步</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）作业：包含通常的程序和数据，配作业说明书，系统根据该说明书对程序的运行进行控制。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）作业步：作业运行经过的，相对独立又相互关联的加工步骤。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.作业控制块</strong> </p>
<p>&ensp;&ensp;&ensp;&ensp;作业控制块：它是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。<br>&ensp;&ensp;&ensp;&ensp;JCB中的内容：作业标识，用户名称，作业账号，作业类型，作业状态，调度信息，资源需求，资源使用情况。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.作业运行的三个阶段和三种状态</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;作业从进入系统到运行结束，通常需要经历收容、运行和完成三个阶段。相应作业也就有“后备状态”、“运行状态”和“完成状态”。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）收容阶段：操作员把用户提交的作业通过某种方式或SPOOLING系统输入到硬盘上，再为该作业建立JCB，并把它放入<strong>作业后备队列</strong>中。后备状态。<br>&ensp;&ensp;&ensp;&ensp;（2）运行阶段：当作业被作业调度选中后，便为它分配必要的资源和建立进程，并将它放入就绪队列。一个<strong>作业从第一次进入就绪状态开始，直到它运行结束前，在此期间都处于运行状态</strong>。<br>&ensp;&ensp;&ensp;&ensp;（3）完成阶段：当作业运行完成、或发生异常情况而提前结束时，作业便进入完成阶段，相应的作业状态为完成状态。  </p>
<h3 id="3-2-2-作业调度的主要任务"><a href="#3-2-2-作业调度的主要任务" class="headerlink" title="3.2.2 作业调度的主要任务"></a>3.2.2 作业调度的主要任务</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.接纳多少个作业（内存驻留数）</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;太多―――&gt;    周转时间T长<br>&ensp;&ensp;&ensp;&ensp;太少―――&gt;    系统效率低</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.接纳哪些作业</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;接纳哪些作业:接纳策略,取决于采用何种调度算法、FCFS、短作业优先等。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>作业调度仅存在于批处理系统中</strong>。  </p>
<h3 id="3-2-3-先来先服务和短作业优先调度算法"><a href="#3-2-3-先来先服务和短作业优先调度算法" class="headerlink" title="3.2.3 先来先服务和短作业优先调度算法"></a>3.2.3 先来先服务和短作业优先调度算法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.先来先服务调度算法（FCFS）</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;非剥夺式的调度算法；<br>&ensp;&ensp;&ensp;&ensp;以<strong>等待时间</strong>为主要的调度指标；<br>&ensp;&ensp;&ensp;&ensp;总是选择就绪队列的队首作业运行；<br>&ensp;&ensp;&ensp;&ensp;是一种最简单的调度算法，既可用于作业调度，也可用于进程调度。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.短作业优先算法（SJF）</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;以要求服务时间为主要的调度指标<br>&ensp;&ensp;&ensp;&ensp;优点：<br>&ensp;&ensp;&ensp;&ensp;（1）有效地降低作业的平均等待时间，缩短平均周转时间和平均带权周转时间（从而提高了系统吞吐量）<br>&ensp;&ensp;&ensp;&ensp;缺点：<br>&ensp;&ensp;&ensp;&ensp;（1）不利于长作业，会出现饿死现象；<br>&ensp;&ensp;&ensp;&ensp;（2）未考虑紧迫程度，不能保证紧迫性作业(进程)会被及时处理；<br>&ensp;&ensp;&ensp;&ensp;（3）该算法不一定能真正做到短作业优先调度。进程运行时间不易确定，通常采用近似估算方法值；<br>&ensp;&ensp;&ensp;&ensp;（4）必须预知作业的运行时间。  </p>
<h3 id="3-2-4-优先级调度算法和高响应比调度算法"><a href="#3-2-4-优先级调度算法和高响应比调度算法" class="headerlink" title="3.2.4 优先级调度算法和高响应比调度算法"></a>3.2.4 优先级调度算法和高响应比调度算法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.优先级调度算法（PSA）</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;从后备队列中选择若干个优先级最高的作业，调入内存运行。<br>&ensp;&ensp;&ensp;&ensp;从就绪队列中选择一个优先级最高的进程，让其获得处理器并执行。   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.响应比优先调度算法（HRRN）</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;非剥夺式的调度算法。<br>&ensp;&ensp;&ensp;&ensp;综合考虑等待时间和服务时间为调度指标<br>&ensp;&ensp;&ensp;&ensp;响应比Rp=（等待时间＋服务时间）/服务时间= 1+ tw/ts<br>&ensp;&ensp;&ensp;&ensp;（1）tw（等待时间）相同的进程，短作业RP大。<br>&ensp;&ensp;&ensp;&ensp;（2）ts（服务时间）相同的进程间相当于FCFS<br>&ensp;&ensp;&ensp;&ensp;（3）长作业等待一段时间仍能得到服务。<br>&ensp;&ensp;&ensp;&ensp;总是选择响应比较高的作业（进程）运行<br>&ensp;&ensp;&ensp;&ensp;可用于作业调度，也可用于进程调度<br>&ensp;&ensp;&ensp;&ensp;优点：介于FCFS和SJF算法之间的一种拆衷的算法。长短兼顾<br>&ensp;&ensp;&ensp;&ensp;缺点：需计算Rp，增加系统开销  </p>
<p>习题：ppt（第三章 27-32）  </p>
<h2 id="3-3-进程调度"><a href="#3-3-进程调度" class="headerlink" title="3.3 进程调度"></a>3.3 进程调度</h2><h3 id="3-3-1-进程调度的任务、机制和方式"><a href="#3-3-1-进程调度的任务、机制和方式" class="headerlink" title="3.3.1 进程调度的任务、机制和方式"></a>3.3.1 进程调度的任务、机制和方式</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.进程调度的任务</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;进程调度的任务主要有：<br>&ensp;&ensp;&ensp;&ensp;（1）保存处理机的现场信息。在进行调度时首先需要保存当前进程的处理机现场信息。<br>&ensp;&ensp;&ensp;&ensp;（2）按某种算法选取进程。调度程序按照某种算法从就绪队列中选取一个进程，并准备把处理机分配给它。<br>&ensp;&ensp;&ensp;&ensp;（3）把处理机分配给进程。由分派程序把处理机分配给该进程。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.进程调度机制</strong>     </p>
<p>&ensp;&ensp;&ensp;&ensp;为了实现进程调度，在进程调度机制中，应具有：<br>&ensp;&ensp;&ensp;&ensp;（1）排队器。每当一个进程变为就绪状态，排队器便将它插入到相应的就绪队列。<br>&ensp;&ensp;&ensp;&ensp;（2）分派器。分派器依据进程调度程序所选出的进程，将其从就绪队列取出，然后进行从分派器到新选出进程间的上下文切换，将处理机分配给新选出的进程。<br>&ensp;&ensp;&ensp;&ensp;（3）上下文切换器。在处理机进行切换时，会发生两对上下文的切换。<br>&ensp;&ensp;&ensp;&ensp;第一对上下文切换时，OS将保存当前进程的上下文，再装入分派程序的上下文。<br>&ensp;&ensp;&ensp;&ensp;第二对上下文切换是移除分派程序的上下文，而把新选进程的CPU现场信息装入到处理机各个相应寄存器中，以便新选进程的运行。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.进程调度方式</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）非抢占方式<br>&ensp;&ensp;&ensp;&ensp;系统一旦把处理器分配给某进程后，该进程就占有处理器一直运行下去，直到该进程完成或因发生事件而阻塞，才退出处理器。<br>&ensp;&ensp;&ensp;&ensp;在这种方式下，引起进程调度的原因可归结为：<br>&ensp;&ensp;&ensp;&ensp;① 正在执行的进程运行完毕或无法再继续；<br>&ensp;&ensp;&ensp;&ensp;② 正在执行的进程提出I/O请求而暂停；<br>&ensp;&ensp;&ensp;&ensp;③ 在通信或同步中，执行了某种原语操作，如Block。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）抢占方式<br>&ensp;&ensp;&ensp;&ensp;允许调度程序根据某种原则，去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程。<br>&ensp;&ensp;&ensp;&ensp;抢占原则：<br>&ensp;&ensp;&ensp;&ensp;① 优先权原则<br>&ensp;&ensp;&ensp;&ensp;② 短进程原则<br>&ensp;&ensp;&ensp;&ensp;③ 时间片原则  </p>
<h3 id="3-3-2-轮转调度算法"><a href="#3-3-2-轮转调度算法" class="headerlink" title="3.3.2 轮转调度算法"></a>3.3.2 轮转调度算法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.轮转法的基本原理</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;系统将所有的就绪进程按进入就绪队列的先后次序排列。每次调度时把CPU分配给队首进程，让其执行一个时间片，当时间片用完，由计时器发出时钟中断，调度程序则暂停该进程的执行，使其退出处理器，并将它送到就绪队列的末尾，等待下一轮调度执行。<br>&ensp;&ensp;&ensp;&ensp;原则：将CPU时间划分为若干时间片，进程被调度到后，占用一个时间片，多个进程循环轮转占用CPU。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.进程切换时机</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）若一个时间片尚未用完，正在运行的进程已完成，就立即激活调度程序，将它从就绪队列删除，在重新调度并启动一个新的时间片。<br>&ensp;&ensp;&ensp;&ensp;（2）在一个时间片用完时，计时器中断处理程序被激活。如果进程尚未运行完毕，调度程序将之送往就绪队列的末尾。剥夺式调度算法  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.时间片大小的确定</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;过长－&gt;退化为FCFS算法，进程在一个时间片内都执行完，响应时间长。<br>&ensp;&ensp;&ensp;&ensp;过短－&gt;用户的一次请求需要多个时间片才能处理完，切换次数增加，系统开销大。  </p>
<p>例题ppt（第三章 42-47）  </p>
<h3 id="3-3-3-优先级调度算法"><a href="#3-3-3-优先级调度算法" class="headerlink" title="3.3.3 优先级调度算法"></a>3.3.3 优先级调度算法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.优先级调度算法的类型</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）非抢占式优先权算法<br>&ensp;&ensp;&ensp;&ensp;（2）抢占式优先权算法，实时性更好。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.优先级的类型</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）静态优先权：优先数在进程创建时确定，整个运行期不变不再变化。确定进程优先级的依据：①进程类型②进程对资源的需求③用户要求。简单，开销小，但低优先权作业可能长期不被调度。<br>&ensp;&ensp;&ensp;&ensp;（2）动态优先权：系统在运行的过程中，不断地调整进程的优先数。防止长作业长期垄断处理机。  </p>
<p>例题ppt（第三章 50）   </p>
<h3 id="3-3-4-多队列调度算法"><a href="#3-3-4-多队列调度算法" class="headerlink" title="3.3.4 多队列调度算法"></a>3.3.4 多队列调度算法</h3><p>&ensp;&ensp;&ensp;&ensp;该算法将系统中的进程就绪队列从一个拆分为若干个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法，一个就绪队列中的进程可以设置不同的优先级，不同的就绪队列本身也可以设置不同的优先级。</p>
<h3 id="3-3-5-多级反馈队列调度算法"><a href="#3-3-5-多级反馈队列调度算法" class="headerlink" title="3.3.5 多级反馈队列调度算法"></a>3.3.5 多级反馈队列调度算法</h3><p>（非重点）<br>多级反馈队列算法是时间片轮转算法和优先级算法的综合和发展。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.调度机制</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）系统中设置多个就绪队列，分别赋予不同的优先级，并逐级降低。为不同队列所规定的时间片长度不同，优先权越高的队列分配的时间片越小。依次逐级加倍。<br>&ensp;&ensp;&ensp;&ensp;（2）新进程进入内存后，先投入队列1的末尾，按FCFS算法排队调度；若按队列1的一个时间片未能执行完，则降低投入到队列2的末尾。如果在队列2的时间片内未能完成，则降低投入到队列3……；如此下去，降低到最后的队列，则按“时间片轮转”算法调度直到完成。<br>&ensp;&ensp;&ensp;&ensp;（3）仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾。 </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.调度算法的性能</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）终端型作业用户<br>&ensp;&ensp;&ensp;&ensp;提供高的响应时间。<br>&ensp;&ensp;&ensp;&ensp;（2）短批处理作业用户<br>&ensp;&ensp;&ensp;&ensp;在第一个或前2个时间片中即可完成，平均周转时间短。<br>&ensp;&ensp;&ensp;&ensp;（3）长批处理作业用户<br>&ensp;&ensp;&ensp;&ensp;不会饥饿。  </p>
<h3 id="3-3-6-基于公平原则的调度算法"><a href="#3-3-6-基于公平原则的调度算法" class="headerlink" title="3.3.6 基于公平原则的调度算法"></a>3.3.6 基于公平原则的调度算法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.保证调度算法</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;保证调度算法是另一种类型的调度算法，它向用户所作出的保证并不是优先运行，而是明确的性能保证，该算法可以做到调度的公平性。  </p>
<p>&ensp;&ensp;&ensp;&ensp;在实施公平调度算法时系统必须具备这样一些功能：<br>&ensp;&ensp;&ensp;&ensp;（1）跟踪计算每个进程自创建以来已经执行的处理时间。<br>&ensp;&ensp;&ensp;&ensp;（2）计算每个进程应获得的处理机时间，即自创建以来的时间除以n<br>&ensp;&ensp;&ensp;&ensp;（3）计算进程获得处理机时间的比率，即进程实际执行的处理时间和应获得的处理机时间之比<br>&ensp;&ensp;&ensp;&ensp;（4）比较各进程获得处理机时间的比率。<br>&ensp;&ensp;&ensp;&ensp;（5）调度程序应选择比率最小的进程将处理机分配给它，并让该进程一直运行，直到超过最接近它的进程比率为止。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.公平分享调度算法</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;分配给每个进程相同的处理机时间，显然，对诸进程而言，是体现了一定程度的公平，但如果各个用户所拥有的进程数不同，就会发生对用户的不公平问题。<br>&ensp;&ensp;&ensp;&ensp;调度的公平性主要是针对用户而言，然而调度又是以进程为单位的，所以，必须考虑每个用户所拥有的进程数目。</p>
<h2 id="3-4-实时调度"><a href="#3-4-实时调度" class="headerlink" title="3.4 实时调度"></a>3.4 实时调度</h2><h3 id="3-4-1-实现实时调度的基本条件"><a href="#3-4-1-实现实时调度的基本条件" class="headerlink" title="3.4.1 实现实时调度的基本条件"></a>3.4.1 实现实时调度的基本条件</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.提供必要的信息</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;为实现实时调度，系统应向调度程序提供相关任务的信息：<br>&ensp;&ensp;&ensp;&ensp;（1）就绪时间，是指某任务成为就绪状态的起始时间，在周期任务的情况下，它是事先预知的一串时间序列。<br>&ensp;&ensp;&ensp;&ensp;（2）开始截止时间和完成截止时间。<br>&ensp;&ensp;&ensp;&ensp;（3）处理时间，一个任务从开始执行，直至完成时所需要的时间。<br>&ensp;&ensp;&ensp;&ensp;（4）资源要求，任务执行时所需的一组资源。<br>&ensp;&ensp;&ensp;&ensp;（5）优先级，如果某任务的开始截止时间错过，势必引起故障，则应为该任务赋予“绝对优先级”；如果其开始截止时间的错过，并对任务的继续运行无重大影响，则可为其赋予“相对优先级”，供调度程序参考。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 系统处理能力强</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在实时系统中，通常都有着多个实时任务。若处理机的处理能力不够强，则有可能因处理机忙不过来而使某些实时任务不能得到及时处理，从而导致发生难以预料的后果。假定系统中有m个周期性的硬实时任务，它们的处理时间可表示为Ci，周期时间表示为Pi，则在单处理机情况下，必须满足下面的限制条件：系统才是可调度的。<br><img src="/2021/05/10/os-3/%E5%9B%BE%E7%89%875.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 采用抢占式调度机制</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在含有硬实时任务的实时系统中，广泛采用抢占机制。当一个优先权更高的任务到达时，允许将当前任务暂时挂起，而令高优先权任务立即投入运行，这样便可满足该硬实时任务对截止时间的要求。但这种调度机制比较复杂。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4. 具有快速切换机制</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;(1) 对外部中断的快速响应能力。为使在紧迫的外部事件请求中断时系统能及时响应，要求系统具有快速硬件中断机构，还应使禁止中断的时间间隔尽量短， 以免耽误时机(其它紧迫任务)。<br>&ensp;&ensp;&ensp;&ensp;(2) 快速的任务分派能力。在完成任务调度后，便应进行任务切换。为了提高分派程序进行任务切换时的速度， 应使系统中的每个运行功能单位适当的小，以减少任务切换的时间开销。  </p>
<h3 id="3-4-2-实时调度算法的分类"><a href="#3-4-2-实时调度算法的分类" class="headerlink" title="3.4.2 实时调度算法的分类"></a>3.4.2 实时调度算法的分类</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 非抢占式调度算法</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;(1) 非抢占式轮转调度算法。    秒级<br> &ensp;&ensp;&ensp;&ensp;用于工业生产的群控系统中。<br>&ensp;&ensp;&ensp;&ensp;(2) 非抢占式优先调度算法。    秒-毫秒级<br>&ensp;&ensp;&ensp;&ensp;用于有一定时间要求的实时控制系统之中。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 抢占式调度算法</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;(1)基于时钟中断抢占的优先权调度算法   毫秒级<br>&ensp;&ensp;&ensp;&ensp;基于时钟中断抢占<br>&ensp;&ensp;&ensp;&ensp;(2)立即抢占的优先权调度算法     毫秒-微秒级<br>&ensp;&ensp;&ensp;&ensp;只要不在临界区即抢占（中断引发）<br><img src="/2021/05/10/os-3/%E5%9B%BE%E7%89%876.png">    </p>
<h3 id="3-4-3-最早截止时间优先算法（EDF）"><a href="#3-4-3-最早截止时间优先算法（EDF）" class="headerlink" title="3.4.3 最早截止时间优先算法（EDF）"></a>3.4.3 最早截止时间优先算法（EDF）</h3><p>&ensp;&ensp;&ensp;&ensp;根据任务的截止时间来确定任务的优先级，截止时间越早，优先级越高，就绪队列中任务按其截止时间排列，队首任务先分配处理机，可以是抢占式或非抢占式。 </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 非抢占式调度方式用于非周期实时任务</strong><br><img src="/2021/05/10/os-3/%E5%9B%BE%E7%89%877.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 抢占式调度方式用于周期实时任务</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;有两个周期性任务，任务A的周期时间为20ms，每个周期处理时间为10ms；任务B的周期时间为50ms，每个周期处理时间为25ms。两个任务的到达时间，最后期限和执行时间如下图：<br><img src="/2021/05/10/os-3/%E5%9B%BE%E7%89%878.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）固定优先级调度（A有较高优先级）<br><img src="/2021/05/10/os-3/%E5%9B%BE%E7%89%879.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）固定优先级调度（B有较高优先级）<br><img src="/2021/05/10/os-3/%E5%9B%BE%E7%89%8710.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;（3）使用最早截止时间优先抢占调度算法<br><img src="/2021/05/10/os-3/%E5%9B%BE%E7%89%8711.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;固定优先级调度（A有较高优先级）时，B任务易错过截止最后期限；<br>&ensp;&ensp;&ensp;&ensp;固定优先级调度（B有较高优先级）时，A任务易错过截止最后期限，同时可能出现CPU空闲，降低系统效率。<br>&ensp;&ensp;&ensp;&ensp;在该例中利用最早截止完成时间优先算法可以满足系统要求  </p>
<h3 id="3-4-4-最低松弛度优先算法（LLF）"><a href="#3-4-4-最低松弛度优先算法（LLF）" class="headerlink" title="3.4.4 最低松弛度优先算法（LLF）"></a>3.4.4 最低松弛度优先算法（LLF）</h3><p>&ensp;&ensp;&ensp;&ensp;松弛度：由任务的完成截止时间决定。<br>&ensp;&ensp;&ensp;&ensp;松弛度＝完成截止时间－运行还需要时间－当前时刻<br>&ensp;&ensp;&ensp;&ensp;例如：若A进程需在200ms时完成，其本身运行需要100ms，当前时刻是10ms，则A的松弛度为：200－100－10＝90<br>该算法根据松弛度（任务紧急程度）来确定任务的优先级。<br>&ensp;&ensp;&ensp;&ensp;松弛度愈高，优先级愈低。<br>&ensp;&ensp;&ensp;&ensp;主要用于可抢占的调度方式中  </p>
<p>例题ppt（第三章 78-81）  </p>
<h3 id="3-4-5-优先级倒置"><a href="#3-4-5-优先级倒置" class="headerlink" title="3.4.5 优先级倒置"></a>3.4.5 优先级倒置</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 优先级倒置的形成</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;优先级倒置：即高优先级进程（线程）被低优先级进程（线程）延迟或阻塞。</p>
<p>&ensp;&ensp;&ensp;&ensp;示例：三个完全独立的进程P1，P2和P3，P1的优先级最高，P2次之，P3最低。P1和P3通过共享的一个临界资源进行交互。程序代码如下：<br>&ensp;&ensp;&ensp;&ensp;P1：… P(mutex); CS-1; V(mutex); …<br>&ensp;&ensp;&ensp;&ensp;P2:  … Program…<br>&ensp;&ensp;&ensp;&ensp;P3:  … P(mutex); CS-3; V(mutex); …<br>&ensp;&ensp;&ensp;&ensp;优先级：P1&gt;P2&gt;P3<br><img src="/2021/05/10/os-3/%E5%9B%BE%E7%89%8712.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;假如P3最先执行，在执行了P(mutex)后，进入到临界区CS-3。<br>&ensp;&ensp;&ensp;&ensp;在时刻a, P2就绪，因为它比P3优先级高，所以P2抢占了P3的处理机而运行。<br>&ensp;&ensp;&ensp;&ensp;在时刻b，P1就绪，因为它的优先级比P2高，所以P1抢占P2的处理机而运行。<br>&ensp;&ensp;&ensp;&ensp;在时刻c, P1 执行P(mutex)操作，试图进入临界区CS-1，但因为临界资源被P3占用，故P1阻塞，由P2继续运行直至时刻d。接着P3运行直至时刻e退出临界区进而唤醒P1，P1抢占P3处理机而运行。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 优先级倒置的解决方法</strong>  </p>
<p>（1）P3在进入临界区后所占用的处理机就不允许被抢占，<br>（2）当高优先级进入P1要进入临界区时，如果已有一个低优先级进程P3正在使用该临界区资源，此时一方面P1被阻塞，另一方面由P3继承P1的优先级并一直保持到P3退出临界区，以此来保证中间优先级进程插入申请处理机，延缓P3退出临界区。<br><img src="/2021/05/10/os-3/%E5%9B%BE%E7%89%8713.png">     </p>
<h2 id="3-5-死锁概述"><a href="#3-5-死锁概述" class="headerlink" title="3.5 死锁概述"></a>3.5 死锁概述</h2><h3 id="3-5-1-资源问题"><a href="#3-5-1-资源问题" class="headerlink" title="3.5.1 资源问题"></a>3.5.1 资源问题</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 可重用性资源和消耗性资源</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）可重用性资源：是一种可供用户重复使用的资源，它具有如下性质：<br>&ensp;&ensp;&ensp;&ensp;① 每一个可重用性资源中的单元只能分配一个进程使用，不允许多个进程共享；<br>&ensp;&ensp;&ensp;&ensp;② 进程使用可重用性资源时，按申请资源-&gt;使用资源-&gt;释放资源的顺序；<br>&ensp;&ensp;&ensp;&ensp;③ 每一类可重用资源中的单元数目是固定的，进程在运行期间既不能创建也不能删除它。  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）消耗性资源：又称为临时性资源，它是在进程运行期间，由进程动态创建和消耗的，具有如下性质：<br>&ensp;&ensp;&ensp;&ensp;①每一类消耗性资源中的单元数目在进程运行期间是可以变化的；<br>&ensp;&ensp;&ensp;&ensp;② 进程在运行期间，可以创造可消耗性资源；<br>&ensp;&ensp;&ensp;&ensp;③进程在运行期间，可以消耗可消耗性资源而不用归还。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.可抢占性资源和不可抢占性资源</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）可抢占性资源：分配给某进程后又可以被其他进程或系统抢占的资源。如处理机、内存。这类资源不会引起死锁的。  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）不可抢占资源：一旦分配给某进程后不能强行收回，只能由进程自行释放的资源。如刻录机和打印机等。  </p>
<h3 id="3-5-2-计算机系统中的死锁"><a href="#3-5-2-计算机系统中的死锁" class="headerlink" title="3.5.2 计算机系统中的死锁"></a>3.5.2 计算机系统中的死锁</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.竞争不可抢占性资源引起死锁</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;系统中所拥有的不可抢占资源数量往往不足以满足多个进程运行的需要，使得进程在运行的过程中，会因争夺资源而陷入僵局。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.竞争可消耗资源引起死锁</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;如消息通信按下述顺序进行，则不会发生死锁：<br>&ensp;&ensp;&ensp;&ensp;P1：…send(S1)；receive(S2)；…<br>&ensp;&ensp;&ensp;&ensp;P2：…send(S2)；Request(S1)；… </p>
<p>&ensp;&ensp;&ensp;&ensp;若按下述顺序，则可能发生死锁：<br>&ensp;&ensp;&ensp;&ensp;P1：… receive(S2)；send(S1)；…<br>&ensp;&ensp;&ensp;&ensp;P2：… receive(S1)；send(S2)；…  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.进程推进顺序不当引起的死锁</strong><br>合法的推进路线：①②③     不合法的推进线路：④<br><img src="/2021/05/10/os-3/%E5%9B%BE%E7%89%8714.png">  </p>
<h3 id="3-5-3-死锁的必要条件和处理方法"><a href="#3-5-3-死锁的必要条件和处理方法" class="headerlink" title="3.5.3 死锁的必要条件和处理方法"></a>3.5.3 死锁的必要条件和处理方法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.死锁的定义</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵局状态，若无外力作用，它们将无法再向前推进。<br>&ensp;&ensp;&ensp;&ensp;<strong>如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的</strong>。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.死锁的必要条件</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;(1) 互斥条件：进程所竞争的资源必须被互斥的使用（资源性质决定<br>&ensp;&ensp;&ensp;&ensp;(2) 请求和保持条件：当前已拥有资源的进程，仍能申请新的资源；而且当该进程因新的资源被其他的进程占用而阻塞时，它对自己已获得的资源仍保持不放（阻塞仍然保留<br>&ensp;&ensp;&ensp;&ensp;(3) 不可抢占条件：进程已获得的资源，只能在使用完时自行释放资源（不可抢占别的进程已占有的资源<br>&ensp;&ensp;&ensp;&ensp;(4) 循环等待条件：存在一个至少包括两个进程的循环等待链，链中的每个进程都正在等待下一个进程所占有的资源<br>&ensp;&ensp;&ensp;&ensp;四个条件必须同时存在才有可能发生死锁，有一个不成立也不能发生死锁。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.处理死锁的方法</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）预防死锁：设置限制条件，破坏产生死锁的四个必要条件中的一个或几个条件。<br>&ensp;&ensp;&ensp;&ensp;2）避免死锁：在每次的资源动态分配过程中，对系统能够满足的资源申请进行安全性检查 ，根据结果决定是否进行此次分配。<br>&ensp;&ensp;&ensp;&ensp;3）检测死锁：允许系统发生死锁，但设置检测机构，及时检测出死锁的发生。<br>&ensp;&ensp;&ensp;&ensp;4）解除死锁：外力推动解除死锁。具体方法有：撤消或挂起死锁进程、剥夺资源等。<br>&ensp;&ensp;&ensp;&ensp;3和4一般搭配使用<br>&ensp;&ensp;&ensp;&ensp;上述的四种方法，从（1）到（4）对死锁的防范程度逐渐减弱，但对应的事资源利用率的提高，以及进程因资源因素而阻塞的频度下降（即并发程度提高）。</p>
<h2 id="3-6-预防死锁"><a href="#3-6-预防死锁" class="headerlink" title="3.6 预防死锁"></a>3.6 预防死锁</h2><h3 id="3-6-1-破坏“请求和保持”条件"><a href="#3-6-1-破坏“请求和保持”条件" class="headerlink" title="3.6.1 破坏“请求和保持”条件"></a>3.6.1 破坏“请求和保持”条件</h3><p>&ensp;&ensp;&ensp;&ensp;为了能破坏该条件，系统必须保证做到：当一个进程在请求资源时，它不能持有不可抢占资源。 </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.第一种协议</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;进程必须在运行前一次性地申请运行期间所需的全部资源，这样进程在整个运行期间不会再提出资源请求，从而摒弃了请求和保持条件。<br>&ensp;&ensp;&ensp;&ensp;优点：简单，易于实现，安全<br>&ensp;&ensp;&ensp;&ensp;缺点：<br>&ensp;&ensp;&ensp;&ensp;（1）资源浪费严重。降低进程并发度。<br>&ensp;&ensp;&ensp;&ensp;（2）使进程经常会发生饥饿现象   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.第二种协议</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的，且已用毕的全部资源，然后再请求新的所需资源。  </p>
<h3 id="3-6-2-破坏“不可抢占”条件"><a href="#3-6-2-破坏“不可抢占”条件" class="headerlink" title="3.6.2 破坏“不可抢占”条件"></a>3.6.2 破坏“不可抢占”条件</h3><p>&ensp;&ensp;&ensp;&ensp;允许进程逐个申请资源，当进程新的资源请求未满足时，必须释放已占有的资源，待以后需要时再重新申请。<br>&ensp;&ensp;&ensp;&ensp;此策略表明进程已占有的资源可被暂时释放，即被抢占了，从而摒弃“不抢占”条件。  </p>
<p>&ensp;&ensp;&ensp;&ensp;缺点：<br>&ensp;&ensp;&ensp;&ensp;（1）复杂，实现困难且代价大。<br>&ensp;&ensp;&ensp;&ensp;（2）延长了进程的周转时间，增加系统开销  </p>
<h3 id="3-6-3-破坏“循环等待”条件"><a href="#3-6-3-破坏“循环等待”条件" class="headerlink" title="3.6.3 破坏“循环等待”条件"></a>3.6.3 破坏“循环等待”条件</h3><p>&ensp;&ensp;&ensp;&ensp;系统给每类资源赋予一个序号，每一个进程严格按照序号递增的顺序请求资源，释放则相反。此方法不可能形成资源占有与请求的环路，从而破坏循环等待条件。总有一个进程占据了较高序号的资源，此后它继续申请的资源必然是空闲的，因此进程可以一直向前推进。</p>
<p>&ensp;&ensp;&ensp;&ensp;优点：相对而言，系统利用率高，系统吞吐量大。<br>&ensp;&ensp;&ensp;&ensp;缺点：<br>&ensp;&ensp;&ensp;&ensp;（1）限制设备扩充。系统事先确定资源序号，限制了新类型设备的增加。<br>&ensp;&ensp;&ensp;&ensp;（2）限制了进程对资源的请求，编程困难。<br>&ensp;&ensp;&ensp;&ensp;（3）资源浪费。当进程使用顺序与资源序号不相符时，也会造成资源浪费。   </p>
<h2 id="3-7-避免死锁"><a href="#3-7-避免死锁" class="headerlink" title="3.7 避免死锁"></a>3.7 避免死锁</h2><p>&ensp;&ensp;&ensp;&ensp;避免死锁同样是属于事先预防的策略，但并不是事先采取某种限制措施，破坏产生死锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。<br>&ensp;&ensp;&ensp;&ensp;这种方法所施加的限制条件较弱，可能获得较好的系统性能，目前常用此方法来避免发生死锁。<br>&ensp;&ensp;&ensp;&ensp;死锁避免方法中将系统状态分为安全状态和不安全状态，只要系统始终都处于安全状态便可避免死锁的发生。  </p>
<h3 id="3-7-1-系统安全状态"><a href="#3-7-1-系统安全状态" class="headerlink" title="3.7.1 系统安全状态"></a>3.7.1 系统安全状态</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.安全状态</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在该方法中，允许进程动态申请资源，系统在进行资源分配前，先计算资源分配的安全性。若安全便将资源分配给进程，否则进程等待。<br>&ensp;&ensp;&ensp;&ensp;安全状态是指系统能按某种顺序如 (P1、P2… 、Pn) 来为每个进程 Pi 分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺利完成，则称此时的系统状态为安全状态，称序列 ( P1、P2、…、Pn ) 为安全序列。<br>&ensp;&ensp;&ensp;&ensp;若某一时刻系统中无法找到这样一个安全序列，则称此时的系统状态为不安全状态。<br>&ensp;&ensp;&ensp;&ensp;虽然并非所有不安全状态都必然会转为死锁状态，但当系统进入不安全状态后，便可能进而进入死锁状态；反之，只要系统处于安全状态，便不会进入死锁状态，因此避免死锁的实质是使系统不进入不安全状态。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.安全状态实例</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;假定系统中有三个进程P1，P2和P3，共有12台磁带机。进程P1共需要10台，P2和P3各需要4台和9台。假设在T0时刻，进程的资源分配情况如下：<br><img src="/2021/05/10/os-3/%E5%9B%BE%E7%89%8715.png">   </p>
<p>这时系统是安全的，因为可以找到一个安全序列（P2，P1, P3），即按此顺序分配资源，就可以使每个进程顺利完成。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 由安全状态向不安全状态的转换</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;若在T0之后，又将1个资源分配给了P3，则系统进入了不安全状态。<br><img src="/2021/05/10/os-3/%E5%9B%BE%E7%89%8716.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;一个系统开始处于安全状态，当有进程请求一个可用资源时，系统需对该进程的请求进行检测，若将资源分配给进程后系统仍然处于安全状态，才将该资源分配给进程   </p>
<h3 id="3-7-2-利用银行家算法避免死锁"><a href="#3-7-2-利用银行家算法避免死锁" class="headerlink" title="3.7.2 利用银行家算法避免死锁"></a>3.7.2 利用银行家算法避免死锁</h3><p>&ensp;&ensp;&ensp;&ensp;最具代表性的死锁避免算法是Dijkstra的银行家算法。之所以这样命名是因为该算法原本是为银行系统设计的。<br>&ensp;&ensp;&ensp;&ensp;为实现银行家算法，每一个新进程在进入系统时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应该超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，在进一步计算在将这些资源分配后，是否会使系统处于不安全状态。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 银行家算法中的数据结构</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）可利用资源向量Available<br>&ensp;&ensp;&ensp;&ensp;可利用资源向量Available是一个含有m个元素的数组，其中每一个元素代表一类资源的空闲资源数目<br>&ensp;&ensp;&ensp;&ensp;如果Available[j]＝K，表示系统中现有空闲的Rj类资源K个。  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）最大需求矩阵Max<br>&ensp;&ensp;&ensp;&ensp;最大需求矩阵Max是一个n×m的矩阵，定义了系统中每个进程对m类资源的最大需求数目。<br>&ensp;&ensp;&ensp;&ensp;如果Max[i，j]＝K ，表示进程i需要Rj类资源的最大数目为K。  </p>
<p>&ensp;&ensp;&ensp;&ensp;3）分配矩阵Allocation<br>&ensp;&ensp;&ensp;&ensp;分配矩阵Allocation是一个n×m 的矩阵，定义了系统中每一类资源当前已分配给每一个进程的资源数目。<br>&ensp;&ensp;&ensp;&ensp;如果Allocation[i，j]＝K ，表示进程i当前已分到Rj类资源的数目为K。  </p>
<p>&ensp;&ensp;&ensp;&ensp;4）需求矩阵Need<br>&ensp;&ensp;&ensp;&ensp;需求矩阵Need是一个n×m 的矩阵，它定义了系统中每一个进程还需要的各类资源数目。<br>&ensp;&ensp;&ensp;&ensp;如果Need[i，j]＝K，表示进程i还需要Rj类资源K个。Need[i，j]＝Max[i，j]－Allocation[i，j]  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 银行家算法</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;设Requesti是进程Pi的请求向量，Requesti[j]＝K表示进程Pi请求分配Rj类资源K个。<br>&ensp;&ensp;&ensp;&ensp;当Pi发出资源请求后，系统按下述步骤进行检查：<br>&ensp;&ensp;&ensp;&ensp;（1）若Requesti [j]≤Need[i,j], 转（2），否则错误返回；<br>&ensp;&ensp;&ensp;&ensp;（2）若Requesti [j]≤Available[j], 转（3）否则进程等待；<br>&ensp;&ensp;&ensp;&ensp;（3）假设系统分配了资源，则有：<br> &ensp;&ensp;&ensp;&ensp;Available[j]=Available[j]-Requesti[j];<br> &ensp;&ensp;&ensp;&ensp;Allocation[i,j]=Allocation[i,j]+Requesti[j];<br> &ensp;&ensp;&ensp;&ensp;Need[i,j]=Need[i,j]-Requesti[j]<br>&ensp;&ensp;&ensp;&ensp;（4）执行安全性算法，若系统新状态是安全的，则分配完成，若系统新状态是不安全的，则恢复原状态，进程等待  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 安全性算法</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）设置两个向量<br>&ensp;&ensp;&ensp;&ensp;工作向量Work：表示系统可提供给进程继续运行的各类空闲资源数目，含有m个元素，执行安全性算法开始时，Work＝Available。<br>&ensp;&ensp;&ensp;&ensp;Finish：表示系统是否有足够的资源分配给进程，使之运行完成，开始时，Finish[i]＝false；当有足够资源分配给进程Pi时，令Finish[i]＝true。<br>&ensp;&ensp;&ensp;&ensp;2） 从进程集合中找到一个能满足下述条件的进程：<br>&ensp;&ensp;&ensp;&ensp;Finish[i]= false；<br>&ensp;&ensp;&ensp;&ensp;Need[i,j]≤Work[j]；<br>&ensp;&ensp;&ensp;&ensp;如找到则执行步骤3；否则执行步骤4。<br>&ensp;&ensp;&ensp;&ensp;3）当进程Pi获得资源后，可顺利执行直到完成，并释放出分配给它的资源，故应执行：<br>&ensp;&ensp;&ensp;&ensp;Work[j]＝Work[j] ＋ Allocation[i,j]；<br>&ensp;&ensp;&ensp;&ensp;Finish[i]＝true；<br>&ensp;&ensp;&ensp;&ensp;goto step 2；<br>&ensp;&ensp;&ensp;&ensp;4）若所有进程的Finish[i]都为true ，则表示系统处于安全状态；否则，系统处于不安全状态。   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4. 银行家算法示例</strong><br>ppt（第三章  123-132）/ 书p121</p>
<h2 id="3-8-死锁的检测与解除"><a href="#3-8-死锁的检测与解除" class="headerlink" title="3.8 死锁的检测与解除"></a>3.8 死锁的检测与解除</h2><p>&ensp;&ensp;&ensp;&ensp;如果在系统中，既不采取死锁预防措施，也未配有死锁避免算法，系统很可能发生死锁。在这种情况下，系统应当提供两个算法：<br>&ensp;&ensp;&ensp;&ensp;（1）死锁检测算法。该算法用于检测系统状态，以确定系统中是否发生了死锁。<br>&ensp;&ensp;&ensp;&ensp;（2）死锁解除算法。当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。  </p>
<h3 id="3-8-1-死锁的检测"><a href="#3-8-1-死锁的检测" class="headerlink" title="3.8.1 死锁的检测"></a>3.8.1 死锁的检测</h3><p>&ensp;&ensp;&ensp;&ensp;系统必须：①保存有关资源的请求和分配信息;②提供一种算法，以利用这些信息来检测系统是否已进入死锁状态。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 资源分配图</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;系统死锁，可利用资源分配图来描述。该图是由一组结点N和一组边E所组成的一个二元组G=（N, E），它具有下述的形式定义和限制：<br>&ensp;&ensp;&ensp;&ensp;N：结点集，分为P，R两部分，P={P1,P2,…,Pn}进程结点；R={R1,R2,…,Rm}资源结点  ；E：边的集合，其元素为有序二元组(Pi,Rj)是资源请求边，由进程Pi指向资源Rj，它表示进程Pi请求一个单位的Rj资源。 (Rj,Pi)是资源分配边，由资源Rj指向进程Pi，它表示把一个单位资源Rj分配给进程Pi。<br><img src="/2021/05/10/os-3/%E5%9B%BE%E7%89%8717.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 死锁定理</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）资源分配图的简化：<br>&ensp;&ensp;&ensp;&ensp;①找一个既不阻塞又非孤立点进程结点，使进程获得所需资源继续运行，直至运行完毕，再释放其所占有的全部资源，即消去此进程的所有请求边和分配边，将其变为孤立结点<br>&ensp;&ensp;&ensp;&ensp;②再把相应的资源分配给一个等待该资源的进程，即将某进程的申请边变为分配边<br>&ensp;&ensp;&ensp;&ensp;③重复以上步骤，若所有进程成为孤立结点，称该图是可完全简化的，否则称该图是不可完全简化的。  </p>
<p>&ensp;&ensp;&ensp;&ensp;所有的简化顺序，都将得到相同的不可简化图<br>&ensp;&ensp;&ensp;&ensp;死锁状态的充分条件是：当且仅当资源分配图是不可完全简化的。（死锁定理）<br><img src="/2021/05/10/os-3/%E5%9B%BE%E7%89%8718.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 死锁检测中的数据结构</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;①可利用资源向量Available：表示m类资源中每类资源的可用数目。<br>&ensp;&ensp;&ensp;&ensp;②请求矩阵Request：表示每个进程当前对各类资源的请求数目。<br>&ensp;&ensp;&ensp;&ensp;③分配矩阵Allocation：表示每个进程当前已分配的资源数目。<br>&ensp;&ensp;&ensp;&ensp;④工作向量Work：表示系统当前可提供资源数。<br>&ensp;&ensp;&ensp;&ensp;⑤剩下的进程集合L：记录当前已不占用资源的进程。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Work=Available; </span><br><span class="line">L=&#123;Li|Allocationi=<span class="number">0</span>∩Requesti=<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> all  LiL <span class="keyword">do</span><span class="comment">//若占用资源</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span>（Requesti≤Work）</span><br><span class="line">      &#123;</span><br><span class="line">           Work=Work+Allocationi;</span><br><span class="line">           L=L∪ Li;<span class="comment">//不占用的</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">deadlock=~(L==&#123;p1,p2,…pn&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="3-8-2-死锁的解除"><a href="#3-8-2-死锁的解除" class="headerlink" title="3.8.2 死锁的解除"></a>3.8.2 死锁的解除</h3><p>&ensp;&ensp;&ensp;&ensp;一旦检测出系统中出现了死锁，就应将陷入死锁的进程从死锁状态中解脱出来，常用的死锁解除方法有两种：  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）抢占资源：从其他进程那里抢占足够数量的资源给死锁进程，以解除死锁状态。  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）终止进程法：终止系统中的一个或多个死锁进程，直至打破循环环路，使系统从死锁状态解脱出来。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 终止进程的方法</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）终止所有死锁进程<br>&ensp;&ensp;&ensp;&ensp;最简单的方法是撤消全部死锁进程，使系统恢复到正常状态。但这种做法付出的代价太大。<br>&ensp;&ensp;&ensp;&ensp;2）逐个终止进程<br>&ensp;&ensp;&ensp;&ensp;按照某种顺序逐个撤消死锁进程，直到有足够的资源供其他未被撤消的进程使用，消除死锁状态为止。这种方法的代价也很大。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 付出代价最小的死锁解除算法（了解）</strong><br><img src="/2021/05/10/os-3/%E5%9B%BE%E7%89%8719.png">  </p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记——第四章</title>
    <url>/2021/05/11/os-4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>个人操作系统笔记整理，欢迎参考，时不时更新。  </p>
<span id="more"></span>

<h1 id="第四章-存储器管理"><a href="#第四章-存储器管理" class="headerlink" title="第四章 存储器管理"></a>第四章 存储器管理</h1><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><ul>
<li>多道程序环境中,多个进程如何划分内存空间？</li>
<li>每个进程是否占用独立的空间？</li>
<li>多大的空间？</li>
<li>固定分配还是按需分配空间？</li>
<li>进程所需数据是一次性地装入内存？还是临时多次装入？该如何进行相应的管理。</li>
<li>内存中的进程如何自我保护？</li>
<li>进程之间如何共享数据</li>
</ul>
<h2 id="4-1-存储器的层次结构"><a href="#4-1-存储器的层次结构" class="headerlink" title="4.1 存储器的层次结构"></a>4.1 存储器的层次结构</h2><p>&ensp;&ensp;&ensp;&ensp;在计算机执行时，几乎每一条指令都涉及对存储器的访问，因此存储器的速度必须非常快，能与处理机的速度相匹配。<br>&ensp;&ensp;&ensp;&ensp;此外还要求存储器的具有非常大的容量，而且存储器的价格还应很便宜。<br>&ensp;&ensp;&ensp;&ensp;这样三个条件，目前是无法同时满足的，因而采取<font color="#FF0000">多层结构</font>的存储器系统。</p>
<h3 id="4-1-1-层次结构"><a href="#4-1-1-层次结构" class="headerlink" title="4.1.1 层次结构"></a>4.1.1 层次结构</h3><p><strong>一、存储器的多层结构</strong><br>&ensp;&ensp;&ensp;&ensp;1）系统管理：寄存器、高速缓存、主存储器和磁盘缓存<br>&ensp;&ensp;&ensp;&ensp;2）设备管理：固定磁盘和可移动存储介质<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%871.png">  </p>
<p><strong>二、可执行存储器：寄存器、主存</strong>  </p>
<ul>
<li>对于存放在可执行存储器和辅存中的信息访问机制不同</li>
<li>OS的存储管理负责对可执行存储器进行分配、回收、及管理</li>
<li>OS的设备和文件管理，根据用户的需要对辅存提供管理</li>
</ul>
<h3 id="4-1-2-主存储器与寄存器"><a href="#4-1-2-主存储器与寄存器" class="headerlink" title="4.1.2 主存储器与寄存器"></a>4.1.2 主存储器与寄存器</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>主存储器</strong>：  </p>
<ul>
<li>几十MB到数GB，<font color="#FF0000">用于存放进程运行时的程序和数据</font>  </li>
<li>CPU都是从主存中取指令和数据</li>
<li>CPU与外设交换信息时也依靠主存</li>
<li>主存与CPU的速度矛盾,引入寄存器和高速缓存  </li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;<strong>寄存器</strong>：  </p>
<ul>
<li>寄存器具有与处理机相同的速度，完全能与CPU协调工作，但价格十分昂贵，因此容量不可能很大</li>
<li>用于加速存储器的访问速度</li>
<li>存放处理机运行时的数据</li>
</ul>
<h3 id="4-1-3-高速缓存和磁盘缓存"><a href="#4-1-3-高速缓存和磁盘缓存" class="headerlink" title="4.1.3 高速缓存和磁盘缓存"></a>4.1.3 高速缓存和磁盘缓存</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>高速缓存</strong>：  </p>
<ul>
<li>从几十KB到几MB，访问速度快于主存。</li>
<li>将主存中一些经常访问的信息存放在高速缓存中，可提高程序执行速度。</li>
<li>它是介于寄存器和存储器之间的存储器件</li>
<li>其容量大于寄存器，速度快于主存。  </li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;<strong>磁盘缓存</strong>：  </p>
<ul>
<li>将频繁使用的一部分磁盘数据和信息，暂时存放在磁盘缓存中，可减少访问磁盘的次数。</li>
<li>提供对主存储器存储空间的扩充</li>
<li>一个文件的数据可能出现在不同存储器层次中</li>
</ul>
<h3 id="4-1-4-内存管理的功能目标"><a href="#4-1-4-内存管理的功能目标" class="headerlink" title="4.1.4 内存管理的功能目标"></a>4.1.4 内存管理的功能目标</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>内存分配</strong>：  </p>
<ul>
<li>使得各得其所、提高利用率及适应动态增长的需求</li>
<li>连续分配/离散分配  </li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;<strong>地址映射</strong>：  </p>
<ul>
<li>逻辑地址转换为物理地址，与分配方式有关</li>
<li>内存保护</li>
<li>基于地址的保护、存取访问控制保护</li>
<li>内存扩充</li>
<li>对换技术、虚拟技术</li>
</ul>
<h2 id="4-2-程序的装入和连接"><a href="#4-2-程序的装入和连接" class="headerlink" title="4.2 程序的装入和连接"></a>4.2 程序的装入和连接</h2><p>需要了解的几个重要概念：  </p>
<ul>
<li>物理地址及物理地址空间</li>
<li>逻辑地址及逻辑地址空间</li>
<li>为何要进行地址转换？</li>
<li>什么是重定位</li>
<li>可执行程序的生成步骤</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1、内存的物理组织</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;物理地址：<br>&ensp;&ensp;&ensp;&ensp;把内存分成若干个大小相等的存储单元(字节),每字节给一个编号，称为内存地址,(物理地址、绝对地址、实地址) 。  </p>
<p>&ensp;&ensp;&ensp;&ensp;物理地址空间：<br>&ensp;&ensp;&ensp;&ensp;即物理地址的集合（也叫主存空间），它是一维的线性空间。  </p>
<p><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%872.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2、程序的逻辑结构</strong><br>&ensp;&ensp;&ensp;&ensp;逻辑地址：<br>&ensp;&ensp;&ensp;&ensp;用户程序经过汇编或编译后形成的目标代码，通常采用相对地址形式，首地址为0，其余指令中的地址都相对于首地址而编址<br>&ensp;&ensp;&ensp;&ensp;逻辑地址空间：<br>&ensp;&ensp;&ensp;&ensp;用户的程序地址的集合（或程序地址空间、虚地址空间，用户地址空间）.<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%873.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3、重定位（地址映射）</strong><br>&ensp;&ensp;&ensp;&ensp;为何要进行地址转换？<br>&ensp;&ensp;&ensp;&ensp;1）程序装入内存时,OS要为其分配合适内存空间。<br>&ensp;&ensp;&ensp;&ensp;2）程序使用逻辑地址, 而CPU执行指令时，是按物理地址进行？<br>&ensp;&ensp;&ensp;&ensp;3）程序的逻辑地址与分配到内存物理地址不一定一致, 所以要进行地址转换。  </p>
<p>&ensp;&ensp;&ensp;&ensp;重定位：<br>&ensp;&ensp;&ensp;&ensp;即是将可执行文件中逻辑地址变换成主存中物理地址的过程，称为地址重定位（或地址映射）。<br>&ensp;&ensp;&ensp;&ensp;这一过程由OS的装入程序loader来完成。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4、可执行程序的生成步骤</strong><br>&ensp;&ensp;&ensp;&ensp;程序成为进程前所需的准备工作：<br>&ensp;&ensp;&ensp;&ensp;编译：形成目标模块(形成逻辑地址)<br>&ensp;&ensp;&ensp;&ensp;链接：由多个目标模块或程序库生成可执行装入模块(更新逻辑地址)<br>&ensp;&ensp;&ensp;&ensp;装入：构造PCB，形成进程(使用物理地址).<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%874.png">  </p>
<h3 id="4-2-1-程序的装入"><a href="#4-2-1-程序的装入" class="headerlink" title="4.2.1 程序的装入"></a>4.2.1 程序的装入</h3><p>&ensp;&ensp;&ensp;&ensp;可执行程序装入内存需要解决的问题：</p>
<p>&ensp;&ensp;&ensp;&ensp;1、如何装入待执行的程序及其所需的数据？<br>&ensp;&ensp;&ensp;&ensp;2、何时将程序的逻辑地址转换为物理地址？  </p>
<p>&ensp;&ensp;&ensp;&ensp;三种装入方式：  </p>
<ul>
<li>绝对装入方式       </li>
<li>静态重定位装入方式   </li>
<li>动态重定位装入方式  </li>
</ul>
<h4 id="1、绝对装入方式"><a href="#1、绝对装入方式" class="headerlink" title="1、绝对装入方式"></a>1、绝对装入方式</h4><ul>
<li><p>当计算机系统很小，仅能运行单道程序时，完全有可能知道程序驻留在内存的地址，此时可以采用绝对装入方式。</p>
</li>
<li><p>用户程序经编译后，将产生绝对地址的目标代码。程序可按照装入模块的地址将程序和数据装入内存。</p>
</li>
<li><p>程序中的相对地址与实际内存地址完全相同，故不需对程序和数据的地址进行修改。  </p>
</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;<strong>优点</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;1）按程序逻辑地址将程序和数据装入内存。逻辑地址即物理地址。<br>&ensp;&ensp;&ensp;&ensp;2）实现简单，无需进行地址变换。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>缺点</strong><br>&ensp;&ensp;&ensp;&ensp;1）程序中使用绝对地址<br>&ensp;&ensp;&ensp;&ensp;2）程序装入内存指定地址段<br>&ensp;&ensp;&ensp;&ensp;3）程序员熟悉内存的使用情况<br>&ensp;&ensp;&ensp;&ensp;4）程序动态修改或装入困难  </p>
<h4 id="2、可重定位装入方式"><a href="#2、可重定位装入方式" class="headerlink" title="2、可重定位装入方式"></a>2、可重定位装入方式</h4><p>&ensp;&ensp;&ensp;&ensp;装入程序把目标模块中的逻辑地址与本程序在内存中的起始地址相加得到正确的物理地址。<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%875.png">   </p>
<ul>
<li><p>允许程序装入与逻辑地址不同的物理地址空间。用户程序被装入内存时，需进行地址转换。</p>
</li>
<li><p>地址映射在装入时一次性完成，以后不再更改程序地址，故也称<strong>静态重定位</strong>。  </p>
</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;优点：实现简单，不要硬件的支持。<br>&ensp;&ensp;&ensp;&ensp;缺点：程序装入内存后，移动就比较困难。  </p>
<h4 id="3、动态运行时装入方式"><a href="#3、动态运行时装入方式" class="headerlink" title="3、动态运行时装入方式"></a>3、动态运行时装入方式</h4><p>&ensp;&ensp;&ensp;&ensp;可重定位装入方式的优点是不需硬件支持，可以装入多道程序；缺点是一个程序通常需要占用连续的内存空间，程序装入内存后不能移动。<br>&ensp;&ensp;&ensp;&ensp;把<strong>相对地址到绝对地址的转换</strong>推迟到程序真正执行时才进行。也称为动态重定位。  </p>
<ul>
<li><p>地址转换在程序<strong>运行时动态</strong>进行。需要硬件支持，即<strong>重定位寄存器</strong>。把相对地址和绝对地址的转换推迟到程序真正执行时才进行。</p>
</li>
<li><p>程序被执行时，通过<strong>重定位寄存器</strong>内的起始物理地址和指令或数据的逻辑地址计算其物理地址。</p>
</li>
<li><p>程序中不执行的部分就不做地址映射的工作，这样节省了CPU的时间。</p>
</li>
<li><p>现代计算机系统中都采用<strong>动态重定位</strong>技术</p>
</li>
</ul>
<p><strong>动态地址映射示意图：</strong><br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%876.png"></p>
<h3 id="4-2-2-程序的链接"><a href="#4-2-2-程序的链接" class="headerlink" title="4.2.2 程序的链接"></a>4.2.2 程序的链接</h3><p>&ensp;&ensp;&ensp;&ensp;链接：用于它将分别在不同的目标文件中编译或汇编的代码收集到一个可直接执行的文件中。<br>&ensp;&ensp;&ensp;&ensp;链接需要解决的问题：<br>&ensp;&ensp;&ensp;&ensp;1）如何将多个目标模块链接成一个装入模块？<br>&ensp;&ensp;&ensp;&ensp;2）如何将多组逻辑地址更新为一组逻辑地址？<br>&ensp;&ensp;&ensp;&ensp;3种链接方式： </p>
<ul>
<li>静态链接</li>
<li>装入时动态链接</li>
<li>运行时动态链接</li>
</ul>
<h4 id="1、静态链接方式"><a href="#1、静态链接方式" class="headerlink" title="1、静态链接方式"></a>1、静态链接方式</h4><p>&ensp;&ensp;&ensp;&ensp;静态链接：在程序运行之前，将所有目标模块及所需库函数，完全链接成一个装入模块，以后不再拆开。<br>&ensp;&ensp;&ensp;&ensp;①<strong>对逻辑地址进行更新</strong>：相对于整个模块第一条语句的起始地址重新计算。<br>&ensp;&ensp;&ensp;&ensp;②<strong>变换外部调用符号</strong>：程序被装入内存之前，将其中的外部调用符号全部转换为相对地址跳转语句。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>缺点</strong>：静态链接需要花费大量的处理机时间。而其中的很多模块将不会运行，浪费存储空间和处理机时间。  </p>
<h4 id="2、装入时动态链接方式"><a href="#2、装入时动态链接方式" class="headerlink" title="2、装入时动态链接方式"></a>2、装入时动态链接方式</h4><p>&ensp;&ensp;&ensp;&ensp;装入时动态链接：不用事先进行链接，系统装入可执行模块时，才进行链接。  </p>
<ul>
<li><p>生成的装入模块，含有未被链接的外部模块引用。这些外部模块可以在装入时链接。</p>
</li>
<li><p>在装入时，遇到未链接的外部模块引用，则查找并将其装入内存。同时更新模块内的指令地址。</p>
</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;通常被链接的共享代码称为动态链接库(DLL, Dynamic-Link Library)或共享库(shared library)。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>优点</strong>：<br>&ensp;&ensp;&ensp;&ensp;1）有便于目标模块的更新与升级；<br>&ensp;&ensp;&ensp;&ensp;2）有利于代码共享；<br>&ensp;&ensp;&ensp;&ensp;3）有利于扩充软件的功能，可以将扩充部分作为动态链接模块。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>缺点</strong>：<br>&ensp;&ensp;&ensp;&ensp;可能会链接一些不会执行的模块，浪费存储空间和处理机时间。</p>
<h4 id="3、运行时动态链接方式"><a href="#3、运行时动态链接方式" class="headerlink" title="3、运行时动态链接方式"></a>3、运行时动态链接方式</h4><p>&ensp;&ensp;&ensp;&ensp;运行时动态链接：外部模块引用直到程序执行时才装入内存，并连接到装入模块中，进行地址转换。<br>&ensp;&ensp;&ensp;&ensp;<strong>优点</strong>：<br>&ensp;&ensp;&ensp;&ensp;1）可以解决静态链接和装入时动态链接都面临的存储空间和处理机时间浪费问题，不需要执行的模块不会装入内存。<br>&ensp;&ensp;&ensp;&ensp;2）广泛用于事务处理系统，如银行管理系统，航空售票系统等。<br>&ensp;&ensp;&ensp;&ensp;3）操作系统自身的一些特殊处理例程，如错误处理例程，也无需实现全部装入内存。  </p>
<h2 id="4-3-连续分配存储管理方式"><a href="#4-3-连续分配存储管理方式" class="headerlink" title="4.3 连续分配存储管理方式"></a>4.3 连续分配存储管理方式</h2><p>&ensp;&ensp;&ensp;&ensp;<strong>一、连续分配的基本思想</strong><br>&ensp;&ensp;&ensp;&ensp; 连续分配是指为一个用户程序分配一个连续的内存空间，有两种方式。<br> &ensp;&ensp;&ensp;&ensp;把内存分成若干个大小不等的连续区域，称作分区，每个作业一般占用一个分区。<br>&ensp;&ensp;&ensp;&ensp;<strong>二、分类</strong><br>  &ensp;&ensp;&ensp;&ensp;1、单一连续分配<br>  &ensp;&ensp;&ensp;&ensp;2、固定分区分配<br>  &ensp;&ensp;&ensp;&ensp;3、动态分区分配<br>  &ensp;&ensp;&ensp;&ensp;4、动态重定位分区分配  </p>
<h3 id="4-3-1-单一连续分配方式"><a href="#4-3-1-单一连续分配方式" class="headerlink" title="4.3.1 单一连续分配方式"></a>4.3.1 单一连续分配方式</h3><p>&ensp;&ensp;&ensp;&ensp;内存分为两个区域：<strong>系统区</strong>，<strong>用户区</strong><br>&ensp;&ensp;&ensp;&ensp;最简单，适用于单用户、单任务的OS<br>&ensp;&ensp;&ensp;&ensp;优点：易管理,(因单任务)不设置存储保护<br>&ensp;&ensp;&ensp;&ensp;缺点：程序全部装入，对要求内存空间少的程序，造成内存浪费<br>&ensp;&ensp;&ensp;&ensp;地址重定位时，只要将指令或数据的逻辑地址加上用户区基地址，就可以形成物理地址    </p>
<p><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%877.png">  </p>
<h3 id="4-3-2-固定分区分配"><a href="#4-3-2-固定分区分配" class="headerlink" title="4.3.2 固定分区分配"></a>4.3.2 固定分区分配</h3><p>&ensp;&ensp;&ensp;&ensp;固定式分区是在作业装入之前，将内存空间划分为若干个固定大小的区域，每个分区中可以装入一道作业。<br>&ensp;&ensp;&ensp;&ensp;特点：有n个分区，则可同时装入n个作业/任务。  </p>
<p>&ensp;&ensp;&ensp;&ensp;分区大小相等：<br>&ensp;&ensp;&ensp;&ensp;简单但缺乏灵活性</p>
<p>&ensp;&ensp;&ensp;&ensp;分区大小不相等：<br>&ensp;&ensp;&ensp;&ensp;内存利用率更高  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 划分分区的方法</strong><br>&ensp;&ensp;&ensp;&ensp;1）分区大小相等</p>
<ul>
<li>当程序太大时，会造成内存空间的浪费；</li>
<li>当程序太小时，可能不足以装入程序，而使程序无法运行；</li>
<li>只适合于多个相同程序的并发执行（处理多个类型相同的对象）。  </li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;2）分区大小不等  </p>
<ul>
<li>将内存的用户区域划分成大小不等的分区，以适应不同大小的作业的需要。  </li>
<li>多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。  </li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.固定分区的数据结构</strong>    &ensp;&ensp;&ensp;&ensp;分区使用表(内存分配表):记录分区的区号、起始地址、大小、占用情况<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%878.png">  <img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%879.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.固定分区的内存分配</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;1）固定分区分配过程：  </p>
<ul>
<li><p>装入时，由内存分配程序检索内存分配表，找出能满足要求的空闲分区分配给用户  </p>
</li>
<li><p>修改内存分配表中该分区对应表项的状态；  </p>
</li>
<li><p>若找不到大小足够的分区，则拒绝分配内存。  </p>
</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;2）固定分区回收过程：  </p>
<ul>
<li><p>程序执行完毕，释放占用分区  </p>
</li>
<li><p>内存管理程序将改分区的状态置为未分配。  </p>
</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.固定分区特点</strong></p>
<ul>
<li>管理简单，最早的多道程序存储管理方式</li>
<li>内存利用率较低，存在“内碎片”。</li>
</ul>
<p><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8710.png"><br>内碎片(内零头)：  </p>
<p>分区内部不可使用的存储空间</p>
<h3 id="4-3-3-动态分区分配"><a href="#4-3-3-动态分区分配" class="headerlink" title="4.3.3 动态分区分配"></a>4.3.3 动态分区分配</h3><p>&ensp;&ensp;&ensp;&ensp;动态分区是指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。<br>&ensp;&ensp;&ensp;&ensp;动态分区中<strong>分区的大小和分区的个数</strong>都是可变的，而且是根据作业的大小和多少动态地划分。<br>&ensp;&ensp;&ensp;&ensp;这种存储管理技术是固定式分区的改进，既可以获得<strong>较大的灵活性</strong>，又能<strong>提高内存的利用率</strong>。</p>
<p>&ensp;&ensp;&ensp;&ensp;动态分区分配方式又称可变分区分配根据作业大小动态地建立分区，并使分区的大小正好适应作业的需要。<br>&ensp;&ensp;&ensp;&ensp;特点：分区的大小是可变的，分区的数目也是可变的。   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.动态分区分配中的数据结构</strong><br>&ensp;&ensp;&ensp;&ensp;1）空闲分区表<br>&ensp;&ensp;&ensp;&ensp;空闲分区表为每个尚未分配的分区设置一个表项，包括分区的序号、大小、始址和状态。<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8712.png"><br>&ensp;&ensp;&ensp;&ensp;2）空闲分区链<br>&ensp;&ensp;&ensp;&ensp;为了实现对空闲分区的分配和链接，在每个分区的起始部分，设置一些用于控制分区分配的信息以及用于链接其它分区的前向指针；在分区尾部，则设置了一个后向指针。通过前、后向指针将所有的分区链接成一个双向链表。<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8713.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 动态分区分配算法</strong><br>&ensp;&ensp;&ensp;&ensp;分区内存分配过程：  </p>
<ul>
<li>寻找适当容量的空闲分区  </li>
<li>将该分区分割成两个分区，其中一个分区为作业要求的大小，分配给申请者  </li>
<li>另一分区(余下部分)仍为“空闲”。</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;分区内存回收过程：  </p>
<ul>
<li>释放占用分区，在空闲分区表增加对应表项。  </li>
<li>相邻的空闲分区，合并成一个空闲分区。 </li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;需要解决的问题是：<strong>能否合并和何时合并</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>顺序搜索法：</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;1）首次适应算法(first fit)<br>&ensp;&ensp;&ensp;&ensp;2）循环首次适应算法(next fit)<br>&ensp;&ensp;&ensp;&ensp;3）最佳适应算法(best fit)<br>&ensp;&ensp;&ensp;&ensp;4）最坏适应算法(worst fit)  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>索引搜索法</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;1）快速适应算法(quick fit)<br>&ensp;&ensp;&ensp;&ensp;2）伙伴系统<br>&ensp;&ensp;&ensp;&ensp;3）哈希算法  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 分区分配操作</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在动态分区存储管理方式中，主要的操作是分配内存和回收内存。<br>&ensp;&ensp;&ensp;&ensp;（1） 分配内存<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8714.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4. 动态分区分配的缺点</strong><br>&ensp;&ensp;&ensp;&ensp;1）系统运行过程中，形成多个空闲的不连续的存储区，称为空闲区<br>&ensp;&ensp;&ensp;&ensp;2）<strong>外碎片</strong>：分区之间无法利用的存储空间，通常是小空闲区  </p>
<p>&ensp;&ensp;&ensp;&ensp;解决办法：<br>&ensp;&ensp;&ensp;&ensp;拼接或紧凑技术，把分散的多个小空闲区合并为一个大的空闲分区。  </p>
<h3 id="4-3-4-基于顺序搜索的动态分区分配算法"><a href="#4-3-4-基于顺序搜索的动态分区分配算法" class="headerlink" title="4.3.4 基于顺序搜索的动态分区分配算法"></a>4.3.4 基于顺序搜索的动态分区分配算法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 首次适应算法FF (first-fit)</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;要求：</p>
<ul>
<li>空闲分区表(链)按低址―&gt;高址链接；  </li>
<li>从表首顺序查找，找到第一个适合的空闲区  </li>
<li>从该分区划出适当空间分配给请求者；  </li>
<li>余下的空闲分区更新数据后，仍然留空闲分区表(链)中。<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8715.png">   </li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;<strong>回收过程</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;1）若有相邻空闲区，则合并<br>&ensp;&ensp;&ensp;&ensp;2）否则，将释放区按首地址升序的规则插入到空闲区表适当的位置。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>优点</strong>： </p>
<p>&ensp;&ensp;&ensp;&ensp;保留高地址大空闲区，利于<strong>大作业</strong>。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>缺点</strong>：  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）容易产生碎片<br>&ensp;&ensp;&ensp;&ensp;2）低地址端过多小空闲区，增加查找开销  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2．循环首次适应算法NF (next fit)</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）按地址递增的顺序链接<br>&ensp;&ensp;&ensp;&ensp;2）从上一次分配的下一个地址开始查找，找到第一个适合的空闲区。<br>&ensp;&ensp;&ensp;&ensp;3）划出适当空间分配给请求者，余下的空闲分区更新数据后，仍然留空闲分区表(链)中。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>优点</strong>：使存储空间更均衡，便于查找<br>&ensp;&ensp;&ensp;&ensp;<strong>缺点</strong>：缺乏大的空闲分区，不利于大作业。<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8716.png">      </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3．最佳适应算法BF (best-fit)</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）以容量递增的次序链接<br>&ensp;&ensp;&ensp;&ensp;2）从表(链)首开始顺序查找，直到找到第一个适合的空闲分区。<br>&ensp;&ensp;&ensp;&ensp;3）若该空闲区大于作业，则划出适当空间分配出去，剩余空闲区仍留在空闲分区表(链)中。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>优点</strong>：找到的空闲区总既满足要求又是最小的。<br>&ensp;&ensp;&ensp;&ensp;<strong>缺点</strong>：留下较小的无法利用的外碎片。<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8717.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4．最坏适应算法WF (worst-fit)</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;1）要求空闲分区按容量递减排列。<br>&ensp;&ensp;&ensp;&ensp;2）从表(链)首开始顺序查找，若第一个表目都不能满足要求，分配失败；<br>&ensp;&ensp;&ensp;&ensp;3）否则，划出适当分区给申请者，剩余空闲区插入空闲区表适当位置。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>优点</strong>：基本不留小分区<br>&ensp;&ensp;&ensp;&ensp;<strong>缺点</strong>：较大的空闲分区不被保留。<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8718.png">  </p>
<h3 id="4-3-5-基于索引搜索的动态分区分配算法"><a href="#4-3-5-基于索引搜索的动态分区分配算法" class="headerlink" title="4.3.5 基于索引搜索的动态分区分配算法"></a>4.3.5 基于索引搜索的动态分区分配算法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 快速适应算法（Quick Fit, QF）</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）空闲分区根据其容量大小进行分类，系统中存在多个空闲分区链表<br>&ensp;&ensp;&ensp;&ensp;2）内存中设立一张管理索引表<br>&ensp;&ensp;&ensp;&ensp;3）每个索引表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头指针  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>特点</strong>：节省空间，但算法复杂  </p>
<p>&ensp;&ensp;&ensp;&ensp;该算法分为两步：第一步根据进程长度，从索引表中寻找到能容纳它的最小空闲区链表；第二步是从链表中取下第一块进行分配即可。<br>&ensp;&ensp;&ensp;&ensp;<strong>优点</strong>：不会产生内存分割，能保留大的分区。也不会产生内存碎片；<br>&ensp;&ensp;&ensp;&ensp;<strong>缺点</strong>：为了有效合并分区，在分区归还时的算法复杂，且分配存在一定的浪费。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 伙伴系统（Buddy System）</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;该算法规定，无论已分配分区或空闲分区，其大小均为2的k次幂（1&lt;=k&lt;=m）。<br>&ensp;&ensp;&ensp;&ensp;对空闲分区按大小进行分类，为具有相同大小的所有空闲分区，设立一个双向链表。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>分配</strong>：单位进程分配一个大小为n的空间时，先计算一个i值（2i-1&lt;n&lt;=2i），然后在大小为2i的分区链表中查找。若找到，则分配成功。<br>&ensp;&ensp;&ensp;&ensp;若找不到，表明长度为2i的分区已经耗尽，则在分区2i+1的空闲链表中寻找。如果找到，则将其分为两个大小为2i的分区，这两个分区称为一对伙伴。一个用于分配，另一个加入大小为2i的空闲分区链表。<br>&ensp;&ensp;&ensp;&ensp;若找不到，继续在2i+2的空闲链表中寻找，找到后进行两次分割。  </p>
<p>&ensp;&ensp;&ensp;&ensp;回收时可能要进行多次合并，如回收大小为2i的空闲分区时，若已经存在2i的空闲分区，则应将其与伙伴分区进行合并为大小为2i+1的空闲分区，依此类推。<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8719.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;伙伴系统的宗旨就是用最小的内存块来满足内核的对于内存的请求。在最初，只有一个块，也就是整个内存，假如为1M大小，而允许的最小块为64K，那么当我们申请一块200K大小的内存时，就要先将1M的块分裂成两等分，各为512K，这两分之间的关系就称为伙伴，然后再将第一个512K的内存块分裂成两等分，各位256K，将第一个256K的内存块分配给内存，这样就是一个分配的过程。下面我们结合示意图来了解伙伴系统分配和回收内存块的过程。<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8720.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 哈希算法</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;分类搜索、伙伴系统算法，空闲区按大小分类链接，多个链，如果分类细，链表多，搜索索引表找适合的链表开销大，可能导致性能下降。  </p>
<p>&ensp;&ensp;&ensp;&ensp;哈希算法是利用哈希快速查找的优点，在分类索引表中快速查找空闲分区链。  </p>
<h3 id="4-3-6-动态可重定位分区分配"><a href="#4-3-6-动态可重定位分区分配" class="headerlink" title="4.3.6 动态可重定位分区分配"></a>4.3.6 动态可重定位分区分配</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 紧凑</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;如果系统中只有若干空闲小分区，即使<strong>总容量和大于要装入的程序</strong>，由于连<strong>续分配方式要求连续</strong>，所以还是<strong>不能装入新的程序</strong>。  </p>
<p>&ensp;&ensp;&ensp;&ensp;如果可以将所有程序进行移动，可以将原来分散的空闲的小分区挪成一个大分区。就可以装入新程序。这种方式叫<strong>“拼接”或“紧凑”</strong>。  </p>
<p>&ensp;&ensp;&ensp;&ensp;每次“紧凑”后原来程序的物理地址都发生了变化，需要通过<strong>相对地址进行重定位</strong>。<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8722.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 可重定位分区分配</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;动态运行时装入方式，程序装入内存后，所有地址都是相对地址，只有程序指令在执行的时候才将其转换为物理地址。</p>
<p>&ensp;&ensp;&ensp;&ensp;需要设置重定位寄存器，保存当前正在执行程序在内存中的起始地址。</p>
<p>&ensp;&ensp;&ensp;&ensp;执行程序时，将程序内的相对地址与重定位寄存器中保存起始地址相加得到物理地址。</p>
<h2 id="4-4-对换（swapping）"><a href="#4-4-对换（swapping）" class="headerlink" title="4.4 对换（swapping）"></a>4.4 对换（swapping）</h2><p>&ensp;&ensp;&ensp;&ensp;对换技术最早用在麻省理工学院的<strong>兼容分时系统</strong>CTSS中，该系统是单用户系统，所有用户都驻留在外存的后备队列中，<strong>每次只调入一个作业进入内存运行，此作业的时间的时间片用完时，又将该作业调至外存，再将后备队列中的一个作业调入内存运行一个时间片。</strong>这是早期的简单分时系统，它采用早期的交换（调进／调出）来满足多个程序共享主存的需要。</p>
<h3 id="4-4-1-多道环境下的对换技术"><a href="#4-4-1-多道环境下的对换技术" class="headerlink" title="4.4.1 多道环境下的对换技术"></a>4.4.1 多道环境下的对换技术</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 对换的引入</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;在多道程序环境下为了提高内存和CPU的利用率，增加<br>系统吞吐量，系统中增设了对换，<strong>把内存中暂不能运行的进程调出到外存上，以腾出足够的内存空间，把已具备运行条件的进程换入内存</strong>。  </p>
<p>&ensp;&ensp;&ensp;&ensp;UNIX早期已引入对换功能并一直保留至今，UNIX系统<br>设置一个对换进程完成以上功能。Windows OS 中也具有对换功能。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 对换的类型</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）整体对换。处理机中的中级调度实际上就是存储器的对换功能，其目的是为了解决内存紧张问题，进一步提高内存利用率和系统吞吐量。中级调度是以进程为单位的对换。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）页面（分段）对换。对换是以进程的一个“页面”或“分段”为单位进行的，则称之为“页面对换”或“分段对换”，又统称为“部分对换”。  </p>
<p>&ensp;&ensp;&ensp;&ensp;为了实现进程对换，系统必须实现对<strong>对换空间的管理</strong>，<strong>进程换入</strong>和<strong>进程换出</strong>等三项功能。  </p>
<h3 id="4-4-2-对换空间的管理"><a href="#4-4-2-对换空间的管理" class="headerlink" title="4.4.2 对换空间的管理"></a>4.4.2 对换空间的管理</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 对换空间管理的主要目标</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;在具有对换功能的OS中，通常把磁盘空间分为文件区和对换区两部分。<br>&ensp;&ensp;&ensp;&ensp;1）对文件区管理的主要目标<br>&ensp;&ensp;&ensp;&ensp;文件区用于存放文件，对文件区管理目标是提高文件存储空间的利用率，为此系统采用离散分配方式；<br>&ensp;&ensp;&ensp;&ensp;2）对对换空间管理的主要目标<br>&ensp;&ensp;&ensp;&ensp;对换区用于存放从内存频繁换出的进程，它的管理目标是提高进程换入换出速度，为此系统采用连续分配方式。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 对换区空闲盘块管理中的数据结构</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;其数据结构的形式与内存在动态分区分配方式中所用的数据结构类似，即同样可以用空闲分区表和空闲分区链。<br>&ensp;&ensp;&ensp;&ensp;其中，每个表目包含：对换区的首地址和大小，分别用盘块号和盘块数表示。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 对换空间的分配与回收</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;与内存中分配与回收方法类似</p>
<h3 id="4-4-3-进程的换出与换入"><a href="#4-4-3-进程的换出与换入" class="headerlink" title="4.4.3 进程的换出与换入"></a>4.4.3 进程的换出与换入</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 进程的换出</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;对换进程在实现进程换出时，是将内存中的某些进程调出至对换区，可分为以下两步：  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）选择被换出的进程。<strong>首先选择阻塞进程</strong>，存在多个时，<strong>优先选择优先级低的</strong>，同时还要考虑进程在内存中的贮存时间。<strong>如无阻塞，则选择优先级低的就绪进程换出</strong>。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）进程换出过程。<strong>只能换出非共享的程序和数据段</strong>。换出时，先申请对换空间，成功换出后修改进程控制块和内存分配表等数据结构。</p>
<h2 id="4-5-分页存储管理方式"><a href="#4-5-分页存储管理方式" class="headerlink" title="4.5 分页存储管理方式"></a>4.5 分页存储管理方式</h2><p>&ensp;&ensp;&ensp;&ensp;<strong>提出分页存储的原因</strong>：  </p>
<p>&ensp;&ensp;&ensp;&ensp;分区存储管理的主要问题是碎片问题。<br>&ensp;&ensp;&ensp;&ensp;小分区不能被系统中的任何用户（程序）利用<br>&ensp;&ensp;&ensp;&ensp;碎片问题的解决：紧凑方式消耗系统开销。<br>&ensp;&ensp;&ensp;&ensp;造成碎片的主要原因是程序整体连续装入内  存。<br>&ensp;&ensp;&ensp;&ensp;若取消作业对存储区的连续性要求，则能较好地解决碎片问题。<br>&ensp;&ensp;&ensp;&ensp;基于这一思想提出的<strong>离散分配</strong><br>&ensp;&ensp;&ensp;&ensp;分页、分段、段页  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>分页存储的基本原理</strong>：  </p>
<p>&ensp;&ensp;&ensp;&ensp;将进程的逻辑地址空间划分成若干大小相等的页(或页面),各页加以编号，从0开始。<br>&ensp;&ensp;&ensp;&ensp;主存空间也划分成与页大小相等的块（或物理块，存储块或页框）。<br>&ensp;&ensp;&ensp;&ensp;在为进程分配存储空间时，总是以块为单位来分配<br>&ensp;&ensp;&ensp;&ensp;页内碎片：由于进程最后一页装不满一个物理块而形成的碎片。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>分页存储的特点</strong>:  </p>
<p>&ensp;&ensp;&ensp;&ensp;将连续的逻辑地址空间的页面，通过页面地址转换机构，映射到不连续的内存块中，实现内存离散分配，节省空间。<br>&ensp;&ensp;&ensp;&ensp;在分页存储管理方式中，若不具备页面对换功能，则称为基本的分页存储管理方式，或称为纯分页存储管理方式。<br>&ensp;&ensp;&ensp;&ensp;基本的分页存储管理方式<strong>不支持虚拟存储器</strong>，要求把每个作业<strong>全部装入内存</strong>后方可运行。</p>
<h3 id="4-5-1-分页存储管理的基本方法"><a href="#4-5-1-分页存储管理的基本方法" class="headerlink" title="4.5.1 分页存储管理的基本方法"></a>4.5.1 分页存储管理的基本方法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 页面和物理块</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）页面。</p>
<p>&ensp;&ensp;&ensp;&ensp;将进程的逻辑地址空间分成若干个页，并为<br>各页加以编号。相应的，将内存物理地址分为若干个块，同时加以编号。</p>
<p>&ensp;&ensp;&ensp;&ensp;2）页面大小适中<br>&ensp;&ensp;&ensp;&ensp;若页面太大：以至和进程大小相差无几，则退化为分区分配，同时页内碎片也较大。<br>&ensp;&ensp;&ensp;&ensp;若页面太小：虽然可减少页内碎片，但会导致页表增长，换入/出效率低。<br>因此页面大小应适中，与计算机的物理内存大小有关：通常为2的幂，一般在1KB到8KB。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 地址结构</strong>    </p>
<p><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8723.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;它由两部分组成：<br>&ensp;&ensp;&ensp;&ensp;前部分为页号P；后一部分为位移量W，即页内地址d。图中的地址长度为32位，其中0～11位为页内地址（每页的大小为4KB），12～31位为页号，所以允许地址空间的大小最多为1M个页。  </p>
<p>&ensp;&ensp;&ensp;&ensp;逻辑地址:由页号和页内位移量（页内地址）两部分组成<br>&ensp;&ensp;&ensp;&ensp;物理地址:由块号和块内位移量（块内地址）两部分组成</p>
<p>&ensp;&ensp;&ensp;&ensp;由页表实现逻辑地址到物理地址的转换。  </p>
<p>&ensp;&ensp;&ensp;&ensp;逻辑地址A；页大小L(1024)；<br>&ensp;&ensp;&ensp;&ensp;页号：    P=int(A/L)<br>&ensp;&ensp;&ensp;&ensp;页内偏移：d=A mod L  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 页表</strong>    </p>
<p><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8724.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;在将进程的每一页离散地分配到内存的多个物理块中后，系统应能保证能在内存中找到每个页面所对应的物理块。为此，系统为每个进程建立了一张页面映射表，简称页表。<br>&ensp;&ensp;&ensp;&ensp;<strong>每个页在页表中占一个表项</strong>，记录该页在内存中对应的物理块号。进程在执行时，通过查找页表，就可以找到每页所对应的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>页表首地址一般用寄存器记录，其中包含页表在内存的始地址和长度</strong>。<br>&ensp;&ensp;&ensp;&ensp;页表的表项中设置一存取控制字段，用于对该存储块中的内容加以保护。当存取控制字段仅有一位时，可用来规定该存储块中的内容是允许读/写还是只读；若存取控制字段为两位时，则可规定为读/写，只读和只执行等存取方式。如果有进程试图去写一个只允许读的存储块时，将引起操作系统的一次中断。  </p>
<h3 id="4-5-2-地址变换机构"><a href="#4-5-2-地址变换机构" class="headerlink" title="4.5.2 地址变换机构"></a>4.5.2 地址变换机构</h3><p>&ensp;&ensp;&ensp;&ensp;地址变换机构完成：<br>&ensp;&ensp;&ensp;&ensp;逻辑页号—物理块号的映射，由页表完成。<br>&ensp;&ensp;&ensp;&ensp;页表驻留内存中，在系统中只设置一个页表寄存器PTR，其中存放页表在内存的始址和页表的长度。<br>&ensp;&ensp;&ensp;&ensp;进程未执行时，页表的起始地址和页表长度都存储在进程PCB中。进程被调度时，两数据被装入页表寄存器PTR中。  </p>
<p>&ensp;&ensp;&ensp;&ensp;地址变换机构的基本任务是利用页表把用户程序中的逻辑地址变换成内存中的物理地址，实际上就是将用户程序中的页号变换成内存中的物理块号。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 基本的地址变换机构</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）<strong>进程访问某个逻辑地址时</strong>，地址变换机构自动地把有效地址/相对地址分为两部分：页号与页内地址；<br>&ensp;&ensp;&ensp;&ensp;2）页内地址（0<del>1023，页面大小为1KB）与块内地址/页框内地址（0</del>1023）一 一对应，无须转换。<br>&ensp;&ensp;&ensp;&ensp;3）页表<strong>通常</strong>存放于内存中，在系统中设置页表寄存器，用来存放页表在内存的起始地址和页表的长度。在进程未执行时，每个进程对应的页表的始址和长度存放在进程的PCB中，当该进程被调度时，就将它们装入页表寄存器。<br>&ensp;&ensp;&ensp;&ensp;4）将物理地址放入物理地址寄存器中  </p>
<p>&ensp;&ensp;&ensp;&ensp;基本地址变换机构工作流程：<br>&ensp;&ensp;&ensp;&ensp;1）当进程访问某个逻辑地址中的数据时，分页地址变换机构根据PTR找到页表。<br>&ensp;&ensp;&ensp;&ensp;2）分页地址变换机构自动把逻辑地址分化为页号和页内地址。并把页号与页表寄存器中页表的大小比较,确定访问的合法性。<br>&ensp;&ensp;&ensp;&ensp;3）如果访问合法，则以页号为索引去检索页表。得到该页的物理块号，将之装入物理地址寄存器中。<br>&ensp;&ensp;&ensp;&ensp;4）页内地址送入物理地址寄存器的块内地址字段中，完成从逻辑地址到物理地址的变换。<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8725.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 具有快表的地址变换机构</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;因页表放在主存中，故存取数据时CPU至少要访问两次主存。降低了内存访问速度。<br>&ensp;&ensp;&ensp;&ensp;（1）访页表,得到绝对地址<br>&ensp;&ensp;&ensp;&ensp;（2）访问内存内容<br>&ensp;&ensp;&ensp;&ensp;增设一个具有并行查找能力的特殊高速缓冲寄存器，又称“联想寄存器”，或称“快表”。用它存放当前访问过的那些页表项。有快表，速度提高。  </p>
<p>&ensp;&ensp;&ensp;&ensp;具有快表的地址变换过程如下：</p>
<ul>
<li>在CPU给出有效地址后，由地址变换机构自动地将页号送入快表中。</li>
<li>若快表中有此页号，则直接从快表中读出该页对应的物理块号，送到物理地址寄存器。否则，再访问内存中的页表，从页表项中读出物理块号送到地址寄存器，</li>
<li>同时，将此页表项放入快表中。若快表已满，OS找到一个被认为不再需要的表项，将它换出。<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8726.png">  </li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;（1）由于成本的原因，快表不可能做得很大，通常只能存放16~512个页表项。这对中、小型作业来说，已可能把全部页表项放入快表中；但对于大型作业来说，则只能将一部分页表放入快表中。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）由于对程序和数据的访问往往带有局限性，所以快表的命中率可以达到90%。这样，由于增加了地址变换机构的速度损失可以降低到10%以下。达到了可以接受的程度</p>
<h3 id="4-5-3-访问内存的有效时间"><a href="#4-5-3-访问内存的有效时间" class="headerlink" title="4.5.3 访问内存的有效时间"></a>4.5.3 访问内存的有效时间</h3><p>&ensp;&ensp;&ensp;&ensp;从进程发出指定逻辑地址的访问请求，到在内存中找到对应的实际物理地址单元并取出数据，所需花费的总时间，内存的有效访问时间(Effective Access Time EAT)。  </p>
<p>&ensp;&ensp;&ensp;&ensp;无快表的分页管理系统<br>&ensp;&ensp;&ensp;&ensp;EAT=t+t=2t</p>
<p>&ensp;&ensp;&ensp;&ensp;有快表的分页管理系统<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8727.png">  </p>
<p>（t为访问一次内存的时间，a为访问快表的命中率，λ为访问一次快表的时间）  </p>
<h3 id="4-5-4-两级页表和多级页表"><a href="#4-5-4-两级页表和多级页表" class="headerlink" title="4.5.4 两级页表和多级页表"></a>4.5.4 两级页表和多级页表</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 两级页表</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;现代计算机系统都支持非常大的逻辑地址空间，致使页表很大，用连续空间存放页表显然不现实。<br>&ensp;&ensp;&ensp;&ensp;如逻辑地址32位，页面大小4KB，则页表项为1M，若每个页表项占4字节，则页表共需要4MB的连续内存空间。<br>&ensp;&ensp;&ensp;&ensp;解决方案：<br>&ensp;&ensp;&ensp;&ensp;用离散方式存储页表<br>&ensp;&ensp;&ensp;&ensp;仅将当前需要的部分页表项放在内存，其余放在磁盘上，需要时调入（请求调入）。  </p>
<p>&ensp;&ensp;&ensp;&ensp;逻辑地址结构：<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8728.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;两级页表系统将32位逻辑地址空间的地址分成三段：其中，页表目录号和页号各占10位，页内地址d占12位。每页的大小为4KB。由于物理块号和页表的物理地址都占4个字节，使每页中包含1024个页表项，所以页表目录和页表页面的大小也都是4KB，即一页。<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8729.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;在地址变换机构中，增设一个外层页表寄存器，用于存放外层页表的始址。使用外层页号，作为外层页表的索引，从中找到指定页表分页的始址，再利用p2作为指定页表分页的索引，找到指定的页表项，其中有该页在内存的物理块号，用该块号和页内地址既可构成访问的内存物理地址。<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8730.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;上述对页表施行离散分配的方法，虽然解决了对于大页表无需大片连续存储空间的问题，但并未解决用较少的内存空间去存放大页表的问题。<br>&ensp;&ensp;&ensp;&ensp;能够用较少的内存空间存放页表的唯一方法是，仅把当前需要的一批页表项调入内存，以后再根据所需要陆续调入。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 多级页表</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;对两级页表进行扩充，便可得到三级、四级或更多级的页表。<br>&ensp;&ensp;&ensp;&ensp;多级页表的实现方式与两级页表类似。<br>&ensp;&ensp;&ensp;&ensp;64位机器页表一般&gt;3级，最外层页表常驻内存。  </p>
<h3 id="4-5-5-反置页表"><a href="#4-5-5-反置页表" class="headerlink" title="4.5.5 反置页表"></a>4.5.5 反置页表</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 多级页表</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;为了减少页表所占用的内存空间，引入了反置页表。<br>&ensp;&ensp;&ensp;&ensp;反置页表是为每一个物理块设置一个页表项，并将它们按物理块的编号排序，其中的内容则是页号和其所隶属进程的标识符。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 地址变换</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;根据进程标识符和页号，检索反置页表，如果检索到与之匹配的页表项，则该页表项的序号即为该页所在的物理块号。反之则说明该页尚未装入内存。<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8731.png"></p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>基本的分页存储管理优点</strong>：<br>&ensp;&ensp;&ensp;&ensp;1）没有外碎片，每个内碎片不超过页大小。<br>&ensp;&ensp;&ensp;&ensp;2）一个程序不必连续存放。<br>&ensp;&ensp;&ensp;&ensp;3）便于内存扩充，随着程序运行而动态生成的数据增多，地址空间可相应增长。<br>&ensp;&ensp;&ensp;&ensp;<strong>缺点</strong>：<br>&ensp;&ensp;&ensp;&ensp;程序需全部装入内存。  </p>
<h2 id="4-6-分段存储管理方式"><a href="#4-6-分段存储管理方式" class="headerlink" title="4.6 分段存储管理方式"></a>4.6 分段存储管理方式</h2><h3 id="4-6-1-分段存储管理方式的引入"><a href="#4-6-1-分段存储管理方式的引入" class="headerlink" title="4.6.1 分段存储管理方式的引入"></a>4.6.1 分段存储管理方式的引入</h3><p>&ensp;&ensp;&ensp;&ensp;段式存储方式的引入<br>&ensp;&ensp;&ensp;&ensp;1）分页通常不是一个完整的程序或数据逻辑段。<br>&ensp;&ensp;&ensp;&ensp;2）分区和页式管理只能采用静态链接，花费大量cpu时间。<br>&ensp;&ensp;&ensp;&ensp;3）用户的作业可以按逻辑上完整的段来划分。<br>&ensp;&ensp;&ensp;&ensp;4）段式存储管理利用动态链接的方式有效节省时间和空间。<br>&ensp;&ensp;&ensp;&ensp;故可以将用户作业地址空间,按逻辑意义分段，以段作为内外存交换的单位。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 方便编程</strong>  </p>
<p>若将逻辑地址分为段名和段内偏移量，则有：  </p>
<pre><code>LOAD 1, [A]|&lt;D&gt;
STORE 1, [B]|&lt;C&gt;
</code></pre>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 信息共享</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;在实现对程序和数据共享时，是以信息的逻辑单位为基础的。比如共享某个过程，函数或文件。而分页系统中的“页”只是存放信息的单位，并无完整的逻辑意义，因而实现共享比较困难。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 信息保护</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;信息保护是以信息的逻辑单位为基础的，而且通常是以一个过程，函数或文件为基本单位进行保护的。而在分页中，一个函数可能占用多个页，而第一页和最后一页还会装入其他内容。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4. 动态增长</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;实际应用中，有些段，尤其是数据段，在它们的使用过程中，会不断的增加，相应的所需存储空间也会动态增加。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>5. 动态链接</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在程序运行时，先将主程序和立即需要用到的目标程序装入内存，即启动运行。在程序运行过程中，需要调用某个目标程序时，才将该段调入内存并进行链接。  </p>
<p>&ensp;&ensp;&ensp;&ensp;作业的地址空间分为多段，每段都从0开始编址，故地址是二维的。<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8732.png">  </p>
<h3 id="4-6-2-分段系统的基本原理"><a href="#4-6-2-分段系统的基本原理" class="headerlink" title="4.6.2 分段系统的基本原理"></a>4.6.2 分段系统的基本原理</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 分段</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;分段系统的逻辑地址结构<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8733.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 段表</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在分段存储管理中，系统为每个分段分配一个连续的分区，进程的各个段可以离散地移入内存的不同分区中。  </p>
<p>&ensp;&ensp;&ensp;&ensp;每个进程建立一个段表，用来记录每段在内存的起始地址及相关信息。  </p>
<p>&ensp;&ensp;&ensp;&ensp;其中每个表项描述一个分段的信息，至少包含：<br>&ensp;&ensp;&ensp;&ensp;段号，段长，段在内存的起始地址，其他信息<br>&ensp;&ensp;&ensp;&ensp;段表一般存放在内存。<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8734.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 地址变换机构</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;为了实现从逻辑地址到物理地址的变换功能，系统中设置了段表寄存器，用于存放段表始址和段表长度。在进行地址变换时，系统将逻辑地址中的段号S与段表长度TL进行比较。  </p>
<ul>
<li>若 S≥TL，表示段号太大，访问越界，于是产生越界中断信号；  </li>
<li>若未越界，则根据段表的始址和该段的段号，计算出该段对应段表项的位置，从中读出该段在内存中的起始址。  </li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;然后再检查段内地址d是否超过该段的段长SL。  </p>
<ul>
<li>若超过，即 d≥SL，同样发出越界中断信号；</li>
<li>若未越界，则将该段的基址与段内地址d相加，得要访问的内存物理地址。<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8735.png">  </li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;和分页系统一样，当段表放在内存时，每访问一个数据，需要访问两次内存，从而降低了计算机的速率。解决的方法和分页类似，也增设一个联想存储器，用于保存最近的分段表项。一般，由于段比页大，因而段表项数据比页表项数目少，所需联想存储器相当较小，所以可以显著减少存取数据的时间。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4. 分页和分段的主要区别</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）页是信息的物理单位，段是信息的逻辑单位。<br>&ensp;&ensp;&ensp;&ensp;2）页大小是系统固定的，而段大小则通常不固定。<br>&ensp;&ensp;&ensp;&ensp;3）逻辑地址表示：<br>&ensp;&ensp;&ensp;&ensp;分页的程序地址空间是一维的，各个模块在链接时必须组织成同一个地址空间；<br>&ensp;&ensp;&ensp;&ensp;分段的程序地址空间是二维的，各个模块在链接时可以每个段组织成一个地址空间。  </p>
<h3 id="4-6-3-信息共享"><a href="#4-6-3-信息共享" class="headerlink" title="4.6.3 信息共享"></a>4.6.3 信息共享</h3><p>&ensp;&ensp;&ensp;&ensp;段是信息的逻辑单位,因此分段系统的一个突出的优点是易于实现段的共享。即允许若干个进程共享一个或多个段，而且对段的保护也十分简单。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 分页系统中对程序和数据的共享</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;在分页系统中，虽然也能实现对程序和数据的共享，但远不如分段系统来得方便。  </p>
<p>&ensp;&ensp;&ensp;&ensp;可重入代码：又称为“纯代码”(Pure Code),在实现共享时，需要用到可重入代码(Reentrant Code) 。它是一种允许多个进程同时访问的代码，是一种不允许任何进程对其进行修改的代码。<br>&ensp;&ensp;&ensp;&ensp;在每个进程中，配以局部数据区，将在执行中可能改变的部分，拷贝到该数据区，这样，程序在执行时，只对该数据区(属于该进程私有)中的内容进行修改，而不去改变共享的代码，这时的可共享代码即成为可重入代码。   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 分段系统中对程序和数据的共享</strong>  </p>
<p><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8736.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;在分页存储管理系统中，信息的共享是通过使多个进程页表项指向同一个物理块来实现的。<br>&ensp;&ensp;&ensp;&ensp;分段是信息的逻辑单位，因而实现共享比分页系统方便。  </p>
<p>&ensp;&ensp;&ensp;&ensp;分段保护方法有：  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>地址越界保护</strong>：段号与段表长度的比较，段内位移与段长的比较,利用界限寄存器。<br>&ensp;&ensp;&ensp;&ensp;<strong>存取控制保护</strong>：设置存取权限，访问段时判断访问类型与存取权限是否相符  </p>
<h3 id="4-6-4-段页式存储方式"><a href="#4-6-4-段页式存储方式" class="headerlink" title="4.6.4 段页式存储方式"></a>4.6.4 段页式存储方式</h3><p>&ensp;&ensp;&ensp;&ensp;分页优点：提高内存利用率<br>&ensp;&ensp;&ensp;&ensp;分段优点：方便用户，易共享保护，动态链接  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 段页式存储管理的引入</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;分页式存储管理对存储空间（内存）的利用率较高，但需要静态链接。<br>&ensp;&ensp;&ensp;&ensp;分段存储管理的分段须占用主存的连续区域，内存空间利用率不高，易产生碎片（外零头）。<br>&ensp;&ensp;&ensp;&ensp;段页式存储管理将分页管理和分段管理结合起来，发挥各自优点。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 基本原理</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;作业的地址空间首先被分成若干个逻辑分段，然后再将每一段分成若干个大小固定的页面，并为每个段赋予一个段名。<br>&ensp;&ensp;&ensp;&ensp;将主存空间分成若干个和页面大小相同的物理块，对主存的分配以物理块为单位。<br>&ensp;&ensp;&ensp;&ensp;逻辑地址结构：<br>&ensp;&ensp;&ensp;&ensp;V=(s,p,d)=(段号，页号，页内地址)  </p>
<p>&ensp;&ensp;&ensp;&ensp;作业的逻辑地址结构:<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8737.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;1、在段页式存储管理系统中，页表不再属于进程而是属于某个段，因此段表中应有专项指出该段对应页表的页表始地址和页表长度。  </p>
<p>&ensp;&ensp;&ensp;&ensp;2、段页式管理中、段表、页表及内存的关系如下图所示：为了实现地址变换，系统中需要设立段表及页表。<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8738.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;3、段表：每个作业一个段表，段表项为页表地址。<br>&ensp;&ensp;&ensp;&ensp;页表：每段一张页表，页表项为块号。<br>&ensp;&ensp;&ensp;&ensp;段表控制寄存器：存放正运行的作业的段表始址及大小。<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8739.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 地址变换过程</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;先将段号S与段表寄存器中的段表长度进行比较，若小于段表长度则表示未越界；<br>&ensp;&ensp;&ensp;&ensp;利用段表始址和段号求出该段对应段表项的位置，从中得到该段的页表始址；<br>&ensp;&ensp;&ensp;&ensp;再利用逻辑地址中的段内页号P获得对应页表项的位置，从中读出该页所在的物理块号，再与页内地址拼接成物理地址。<br><img src="/2021/05/11/os-4/%E5%9B%BE%E7%89%8740.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;在段页式系统中，为了获得一条指令或数据，需三次访问内存<br>&ensp;&ensp;&ensp;&ensp;第一次访问内存中的段表，从中取得页表始址；  </p>
<p>&ensp;&ensp;&ensp;&ensp;第二次访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理  地址；  </p>
<p>&ensp;&ensp;&ensp;&ensp;第三次访问是真正根据所得的物理地址取出指令或数据。  </p>
<p>&ensp;&ensp;&ensp;&ensp;显然，这使访问内存的次数增加了近两倍。为了提高执行的速度，在地址变换机构中增设一高速缓冲寄存器。每次访问它时，都同时利用段号和页号去检索高速缓存。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensor性质和用法</title>
    <url>/2021/07/17/pytorch/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录pytorch的一些函数用法——tensor</p>
<span id="more"></span> 

<h2 id="1-张量Tensor"><a href="#1-张量Tensor" class="headerlink" title="1. 张量Tensor"></a>1. 张量Tensor</h2><p>张量是一个统称，其中包含很多类型：</p>
<ol>
<li>0阶张量：标量、常数，0-D Tensor</li>
<li>1阶张量：向量，1-D Tensor</li>
<li>2阶张量：矩阵，2-D Tensor</li>
<li>3阶张量</li>
<li>…</li>
<li>N阶张量</li>
</ol>
<h2 id="2-Pytorch中创建张量"><a href="#2-Pytorch中创建张量" class="headerlink" title="2. Pytorch中创建张量"></a>2. Pytorch中创建张量</h2><ol>
<li><p>使用python中的列表或者序列创建tensor</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.tensor([[<span class="number">1.</span>, -<span class="number">1.</span>], [<span class="number">1.</span>, -<span class="number">1.</span>]])</span><br><span class="line">tensor([[ <span class="number">1.0000</span>, -<span class="number">1.0000</span>],</span><br><span class="line">        [ <span class="number">1.0000</span>, -<span class="number">1.0000</span>]])</span><br></pre></td></tr></table></figure></li>
<li><p>使用numpy中的数组创建tensor</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.tensor(np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]))</span><br><span class="line">tensor([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>]])</span><br></pre></td></tr></table></figure></li>
<li><p>使用torch的api创建tensor</p>
<ol>
<li><p><code>torch.empty(3,4)</code>创建3行4列的空的tensor，会用无用数据进行填充</p>
</li>
<li><p><code>torch.ones([3,4])</code> 创建3行4列的<strong>全为1</strong>的tensor</p>
</li>
<li><p><code>torch.zeros([3,4])</code>创建3行4列的<strong>全为0</strong>的tensor</p>
</li>
<li><p><code>torch.rand([3,4])</code> 创建3行4列的<strong>随机值</strong>的tensor，随机值的区间是<code>[0, 1)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.rand(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">tensor([[ <span class="number">0.8237</span>,  <span class="number">0.5781</span>,  <span class="number">0.6879</span>],</span><br><span class="line">[ <span class="number">0.3816</span>,  <span class="number">0.7249</span>,  <span class="number">0.0998</span>]])</span><br></pre></td></tr></table></figure></li>
<li><p><code>torch.randint(low=0,high=10,size=[3,4])</code> 创建3行4列的<strong>随机整数</strong>的tensor，随机值的区间是<code>[low, high)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.randint(<span class="number">3</span>, <span class="number">10</span>, (<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">tensor([[<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">	[<span class="number">6</span>, <span class="number">7</span>]])</span><br></pre></td></tr></table></figure></li>
<li><p><code>torch.randn([3,4])</code> 创建3行4列的<strong>随机数</strong>的tensor，随机值的分布式均值为0，方差为1</p>
</li>
</ol>
</li>
</ol>
<h2 id="3-Pytorch中tensor的常用方法"><a href="#3-Pytorch中tensor的常用方法" class="headerlink" title="3. Pytorch中tensor的常用方法"></a>3. Pytorch中tensor的常用方法</h2><ol>
<li><p>获取tensor中的数据(当tensor中只有一个元素可用)：<code>tensor.item()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">10</span>]: a = torch.tensor(np.arange(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: a</span><br><span class="line">Out[<span class="number">11</span>]: tensor([<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: a.item()</span><br><span class="line">Out[<span class="number">12</span>]: <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li><p>转化为numpy数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">55</span>]: z.numpy()</span><br><span class="line">Out[<span class="number">55</span>]:</span><br><span class="line">array([[-<span class="number">2.5871205</span>],</span><br><span class="line">       [ <span class="number">7.3690367</span>],</span><br><span class="line">       [-<span class="number">2.4918075</span>]], dtype=float32)</span><br></pre></td></tr></table></figure></li>
<li><p>获取形状：<code>tensor.size()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">72</span>]: x</span><br><span class="line">Out[<span class="number">72</span>]:</span><br><span class="line">tensor([[    <span class="number">1</span>,     <span class="number">2</span>],</span><br><span class="line">        [    <span class="number">3</span>,     <span class="number">4</span>],</span><br><span class="line">        [    <span class="number">5</span>,    <span class="number">10</span>]], dtype=torch.int32)</span><br><span class="line"></span><br><span class="line">In [<span class="number">73</span>]: x.size()</span><br><span class="line">Out[<span class="number">73</span>]: torch.Size([<span class="number">3</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure></li>
<li><p>形状改变：<code>tensor.view((3,4))</code>。类似numpy中的reshape，是一种浅拷贝，仅仅是形状发生改变</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: x.view(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">Out[<span class="number">76</span>]:</span><br><span class="line">tensor([[    <span class="number">1</span>,     <span class="number">2</span>,     <span class="number">3</span>],</span><br><span class="line">        [    <span class="number">4</span>,     <span class="number">5</span>,    <span class="number">10</span>]], dtype=torch.int32)</span><br></pre></td></tr></table></figure></li>
<li><p>获取阶数：<code>tensor.dim()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">77</span>]: x.dim()</span><br><span class="line">Out[<span class="number">77</span>]: <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取最大值：<code>tensor.max()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">78</span>]: x.<span class="built_in">max</span>()</span><br><span class="line">Out[<span class="number">78</span>]: tensor(<span class="number">10</span>, dtype=torch.int32)</span><br></pre></td></tr></table></figure></li>
<li><p>转置：<code>tensor.t()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">79</span>]: x.t()</span><br><span class="line">Out[<span class="number">79</span>]:</span><br><span class="line">tensor([[    <span class="number">1</span>,     <span class="number">3</span>,     <span class="number">5</span>],</span><br><span class="line">        [    <span class="number">2</span>,     <span class="number">4</span>, 	  <span class="number">10</span>]], dtype=torch.int32)</span><br></pre></td></tr></table></figure></li>
<li><p><code>tensor[1,3]</code>  获取tensor中第一行第三列的值</p>
</li>
<li><p><code>tensor[1,3]=100</code> 对tensor中第一行第三列的位置进行赋值100</p>
</li>
<li><p>tensor的切片</p>
</li>
</ol>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">101</span>]: x</span><br><span class="line">Out[<span class="number">101</span>]:</span><br><span class="line">tensor([[<span class="number">1.6437</span>, <span class="number">1.9439</span>, <span class="number">1.5393</span>],</span><br><span class="line">        [<span class="number">1.3491</span>, <span class="number">1.9575</span>, <span class="number">1.0552</span>],</span><br><span class="line">        [<span class="number">1.5106</span>, <span class="number">1.0123</span>, <span class="number">1.0961</span>],</span><br><span class="line">        [<span class="number">1.4382</span>, <span class="number">1.5939</span>, <span class="number">1.5012</span>],</span><br><span class="line">        [<span class="number">1.5267</span>, <span class="number">1.4858</span>, <span class="number">1.4007</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">102</span>]: x[:,<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">102</span>]: tensor([<span class="number">1.9439</span>, <span class="number">1.9575</span>, <span class="number">1.0123</span>, <span class="number">1.5939</span>, <span class="number">1.4858</span>])</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h2 id="4-tensor的数据类型"><a href="#4-tensor的数据类型" class="headerlink" title="4. tensor的数据类型"></a>4. tensor的数据类型</h2><p>tensor中的数据类型非常多，常见类型如下：</p>
<img src="/2021/07/17/pytorch/tensor%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" class>  

<p>上图中的Tensor types表示这种type的tensor是其实例</p>
<ol>
<li><p>获取tensor的数据类型:<code>tensor.dtype</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">80</span>]: x.dtype</span><br><span class="line">Out[<span class="number">80</span>]: torch.int32</span><br></pre></td></tr></table></figure></li>
<li><p>创建数据的时候指定类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">88</span>]: torch.ones([<span class="number">2</span>,<span class="number">3</span>],dtype=torch.float32)</span><br><span class="line">Out[<span class="number">88</span>]:</span><br><span class="line">tensor([[<span class="number">9.1167e+18</span>, <span class="number">0.0000e+00</span>, <span class="number">7.8796e+15</span>],</span><br><span class="line">        [<span class="number">8.3097e-43</span>, <span class="number">0.0000e+00</span>, -<span class="number">0.0000e+00</span>]])</span><br></pre></td></tr></table></figure></li>
<li><p>类型的修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: a</span><br><span class="line">Out[<span class="number">17</span>]: tensor([<span class="number">1</span>, <span class="number">2</span>], dtype=torch.int32)</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: a.<span class="built_in">type</span>(torch.<span class="built_in">float</span>)</span><br><span class="line">Out[<span class="number">18</span>]: tensor([<span class="number">1.</span>, <span class="number">2.</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: a.double()</span><br><span class="line">Out[<span class="number">19</span>]: tensor([<span class="number">1.</span>, <span class="number">2.</span>], dtype=torch.float64)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5-tensor的其他操作"><a href="#5-tensor的其他操作" class="headerlink" title="5. tensor的其他操作"></a>5. tensor的其他操作</h2><ol>
<li><p>tensor和tensor相加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">94</span>]: x = x.new_ones(<span class="number">5</span>, <span class="number">3</span>, dtype=torch.<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">95</span>]: y = torch.rand(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">96</span>]: x+y</span><br><span class="line">Out[<span class="number">96</span>]:</span><br><span class="line">tensor([[<span class="number">1.6437</span>, <span class="number">1.9439</span>, <span class="number">1.5393</span>],</span><br><span class="line">        [<span class="number">1.3491</span>, <span class="number">1.9575</span>, <span class="number">1.0552</span>],</span><br><span class="line">        [<span class="number">1.5106</span>, <span class="number">1.0123</span>, <span class="number">1.0961</span>],</span><br><span class="line">        [<span class="number">1.4382</span>, <span class="number">1.5939</span>, <span class="number">1.5012</span>],</span><br><span class="line">        [<span class="number">1.5267</span>, <span class="number">1.4858</span>, <span class="number">1.4007</span>]])</span><br><span class="line">In [<span class="number">98</span>]: torch.add(x,y)</span><br><span class="line">Out[<span class="number">98</span>]:</span><br><span class="line">tensor([[<span class="number">1.6437</span>, <span class="number">1.9439</span>, <span class="number">1.5393</span>],</span><br><span class="line">        [<span class="number">1.3491</span>, <span class="number">1.9575</span>, <span class="number">1.0552</span>],</span><br><span class="line">        [<span class="number">1.5106</span>, <span class="number">1.0123</span>, <span class="number">1.0961</span>],</span><br><span class="line">        [<span class="number">1.4382</span>, <span class="number">1.5939</span>, <span class="number">1.5012</span>],</span><br><span class="line">        [<span class="number">1.5267</span>, <span class="number">1.4858</span>, <span class="number">1.4007</span>]])</span><br><span class="line">In [<span class="number">99</span>]: x.add(y)</span><br><span class="line">Out[<span class="number">99</span>]:</span><br><span class="line">tensor([[<span class="number">1.6437</span>, <span class="number">1.9439</span>, <span class="number">1.5393</span>],</span><br><span class="line">        [<span class="number">1.3491</span>, <span class="number">1.9575</span>, <span class="number">1.0552</span>],</span><br><span class="line">        [<span class="number">1.5106</span>, <span class="number">1.0123</span>, <span class="number">1.0961</span>],</span><br><span class="line">        [<span class="number">1.4382</span>, <span class="number">1.5939</span>, <span class="number">1.5012</span>],</span><br><span class="line">        [<span class="number">1.5267</span>, <span class="number">1.4858</span>, <span class="number">1.4007</span>]])</span><br><span class="line">In [<span class="number">100</span>]: x.add_(y)  <span class="comment">#带下划线的方法会对x进行就地修改</span></span><br><span class="line">Out[<span class="number">100</span>]:</span><br><span class="line">tensor([[<span class="number">1.6437</span>, <span class="number">1.9439</span>, <span class="number">1.5393</span>],</span><br><span class="line">        [<span class="number">1.3491</span>, <span class="number">1.9575</span>, <span class="number">1.0552</span>],</span><br><span class="line">        [<span class="number">1.5106</span>, <span class="number">1.0123</span>, <span class="number">1.0961</span>],</span><br><span class="line">        [<span class="number">1.4382</span>, <span class="number">1.5939</span>, <span class="number">1.5012</span>],</span><br><span class="line">        [<span class="number">1.5267</span>, <span class="number">1.4858</span>, <span class="number">1.4007</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">101</span>]: x <span class="comment">#x发生改变</span></span><br><span class="line">Out[<span class="number">101</span>]:</span><br><span class="line">tensor([[<span class="number">1.6437</span>, <span class="number">1.9439</span>, <span class="number">1.5393</span>],</span><br><span class="line">        [<span class="number">1.3491</span>, <span class="number">1.9575</span>, <span class="number">1.0552</span>],</span><br><span class="line">        [<span class="number">1.5106</span>, <span class="number">1.0123</span>, <span class="number">1.0961</span>],</span><br><span class="line">        [<span class="number">1.4382</span>, <span class="number">1.5939</span>, <span class="number">1.5012</span>],</span><br><span class="line">        [<span class="number">1.5267</span>, <span class="number">1.4858</span>, <span class="number">1.4007</span>]])</span><br></pre></td></tr></table></figure>

<p>注意：带下划线的方法（比如:<code>add_</code>)会对tensor进行就地修改</p>
</li>
<li><p>tensor和数字操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">97</span>]: x +<span class="number">10</span></span><br><span class="line">Out[<span class="number">97</span>]:</span><br><span class="line">tensor([[<span class="number">11.</span>, <span class="number">11.</span>, <span class="number">11.</span>],</span><br><span class="line">        [<span class="number">11.</span>, <span class="number">11.</span>, <span class="number">11.</span>],</span><br><span class="line">        [<span class="number">11.</span>, <span class="number">11.</span>, <span class="number">11.</span>],</span><br><span class="line">        [<span class="number">11.</span>, <span class="number">11.</span>, <span class="number">11.</span>],</span><br><span class="line">        [<span class="number">11.</span>, <span class="number">11.</span>, <span class="number">11.</span>]])</span><br></pre></td></tr></table></figure></li>
<li><p>CUDA中的tensor</p>
<p>CUDA（Compute Unified Device Architecture），是NVIDIA推出的运算平台。 CUDA™是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。</p>
<p><code>torch.cuda</code>这个模块增加了对CUDA tensor的支持，能够在cpu和gpu上使用相同的方法操作tensor</p>
<p>通过<code>.to</code>方法能够把一个tensor转移到另外一个设备(比如从CPU转到GPU)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#device = torch.device(&quot;cuda:0&quot; if torch.cuda.is_available() else &quot;cpu&quot;)</span></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    device = torch.device(<span class="string">&quot;cuda&quot;</span>)          <span class="comment"># cuda device对象</span></span><br><span class="line">    y = torch.ones_like(x, device=device)  <span class="comment"># 创建一个在cuda上的tensor</span></span><br><span class="line">    x = x.to(device)                       <span class="comment"># 使用方法把x转为cuda 的tensor</span></span><br><span class="line">    z = x + y</span><br><span class="line">    <span class="built_in">print</span>(z)</span><br><span class="line">    <span class="built_in">print</span>(z.to(<span class="string">&quot;cpu&quot;</span>, torch.double))       <span class="comment"># .to方法也能够同时设置类型</span></span><br><span class="line">    </span><br><span class="line">&gt;&gt;tensor([<span class="number">1.9806</span>], device=<span class="string">&#x27;cuda:0&#x27;</span>)</span><br><span class="line">&gt;&gt;tensor([<span class="number">1.9806</span>], dtype=torch.float64)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch线性回归</title>
    <url>/2021/07/17/pytorch2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>手动和api调用线性回归</p>
<span id="more"></span> 

<h1 id="一、手动线性回归"><a href="#一、手动线性回归" class="headerlink" title="一、手动线性回归"></a>一、手动线性回归</h1><h2 id="1-向前计算"><a href="#1-向前计算" class="headerlink" title="1. 向前计算"></a>1. 向前计算</h2><p>对于pytorch中的一个tensor，如果设置它的属性 <code>.requires_grad</code>为<code>True</code>，那么它将会追踪对于该张量的所有操作。或者可以理解为，这个tensor是一个参数，后续会被计算梯度，更新该参数。</p>
<h3 id="1-1-计算过程"><a href="#1-1-计算过程" class="headerlink" title="1.1 计算过程"></a>1.1 计算过程</h3><p>假设有以下条件（1/4表示求均值，xi中有4个数），使用torch完成其向前计算的过程<br>$$<br>\begin{align*}<br>&amp;o = \frac{1}{4}\sum_iz_i \<br>&amp;z_i = 3(x_i+2)^2\<br>其中:&amp;\<br>&amp;z_i|_{x_i=1}=27\<br>\end{align*}<br>$$<br>如果x为参数，需要对其进行梯度的计算和更新</p>
<p>那么，在最开始随机设置x的值的过程中，需要设置他的requires_grad属性为True，其<strong>默认值为False</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">x = torch.ones(<span class="number">2</span>, <span class="number">2</span>, requires_grad=<span class="literal">True</span>)  <span class="comment">#初始化参数x并设置requires_grad=True用来追踪其计算历史</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment">#tensor([[1., 1.],</span></span><br><span class="line"><span class="comment">#        [1., 1.]], requires_grad=True)</span></span><br><span class="line"></span><br><span class="line">y = x+<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="comment">#tensor([[3., 3.],</span></span><br><span class="line"><span class="comment">#        [3., 3.]], grad_fn=&lt;AddBackward0&gt;)</span></span><br><span class="line"></span><br><span class="line">z = y*y*<span class="number">3</span>  <span class="comment">#平方x3</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment">#tensor([[27., 27.],</span></span><br><span class="line"><span class="comment">#        [27., 27.]], grad_fn=&lt;MulBackward0&gt;) </span></span><br><span class="line"></span><br><span class="line">out = z.mean() <span class="comment">#求均值</span></span><br><span class="line"><span class="built_in">print</span>(out)</span><br><span class="line"><span class="comment">#tensor(27., grad_fn=&lt;MeanBackward0&gt;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上述代码可以看出：</p>
<ol>
<li>x的requires_grad属性为True</li>
<li>之后的每次计算都会修改其<code>grad_fn</code>属性，用来记录做过的操作<ol>
<li>通过这个函数和grad_fn能够组成一个和前一小节类似的计算图</li>
</ol>
</li>
</ol>
<h3 id="1-2-requires-grad和grad-fn"><a href="#1-2-requires-grad和grad-fn" class="headerlink" title="1.2 requires_grad和grad_fn"></a>1.2 requires_grad和grad_fn</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.randn(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">a = ((a * <span class="number">3</span>) / (a - <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(a.requires_grad)  <span class="comment">#False</span></span><br><span class="line">a.requires_grad_(<span class="literal">True</span>)  <span class="comment">#就地修改</span></span><br><span class="line"><span class="built_in">print</span>(a.requires_grad)  <span class="comment">#True</span></span><br><span class="line">b = (a * a).<span class="built_in">sum</span>()</span><br><span class="line"><span class="built_in">print</span>(b.grad_fn) <span class="comment"># &lt;SumBackward0 object at 0x4e2b14345d21&gt;</span></span><br><span class="line"><span class="keyword">with</span> torch.no_gard():</span><br><span class="line">    c = (a * a).<span class="built_in">sum</span>()  <span class="comment">#tensor(151.6830),此时c没有gard_fn</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(c.requires_grad) <span class="comment">#False</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>为了防止跟踪历史记录（和使用内存），可以将代码块包装在<code>with torch.no_grad():</code>中。<strong>在评估模型时特别有用</strong>，因为模型可能具有<code>requires_grad = True</code>的可训练的参数，但是我们不需要在此过程中对他们进行梯度计算。</p>
<h2 id="2-梯度计算"><a href="#2-梯度计算" class="headerlink" title="2. 梯度计算"></a>2. 梯度计算</h2><p>对于1.1 中的out而言，我们可以使用<code>backward</code>方法来进行反向传播，计算梯度</p>
<p><code>out.backward()</code>,此时便能够求出导数$\frac{d out}{dx}$,调用<code>x.gard</code>能够获取导数值</p>
<p>得到</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tensor([[<span class="number">4.5000</span>, <span class="number">4.5000</span>],</span><br><span class="line">        [<span class="number">4.5000</span>, <span class="number">4.5000</span>]])</span><br></pre></td></tr></table></figure>

<p> 因为：<br>$$<br>\frac{d(O)}{d(x_i)} = \frac{3}{2}(x_i+2)<br>$$<br>在$x_i$等于1时其值为4.5</p>
<p>注意：在输出为一个标量的情况下，我们可以调用输出<code>tensor</code>的<code>backword()</code> 方法，但是在数据是一个向量的时候，调用<code>backward()</code>的时候还需要传入其他参数。</p>
<p>很多时候我们的损失函数都是一个标量，所以这里就不再介绍损失为向量的情况。</p>
<p><code>loss.backward()</code>就是根据损失函数，对参数（requires_grad=True）的去计算他的梯度，并且把它累加保存到<code>x.gard</code>，此时还并未更新其梯度</p>
<p>注意点：</p>
<ol>
<li><p><code>tensor.data</code>:</p>
<ul>
<li><p>在tensor的require_grad=False，tensor.data和tensor等价</p>
</li>
<li><p>require_grad=True时，tensor.data仅仅是获取tensor中的数据</p>
</li>
</ul>
</li>
<li><p><code>tensor.numpy()</code>:</p>
<ul>
<li><code>require_grad=True</code>不能够直接转换，需要使用<code>tensor.detach().numpy()</code></li>
</ul>
</li>
</ol>
<h2 id="3-线性回归实现"><a href="#3-线性回归实现" class="headerlink" title="3. 线性回归实现"></a>3. 线性回归实现</h2><p>下面，我们使用一个自定义的数据，来使用torch实现一个简单的线性回归</p>
<p>假设我们的基础模型就是<code>y = wx+b</code>，其中w和b均为参数，我们使用<code>y = 3x+0.8</code>来构造数据x、y，所以最后通过模型应该能够得出w和b应该分别接近3和0.8</p>
<ol>
<li>准备数据</li>
<li>计算预测值</li>
<li>计算损失，把参数的梯度置为0，进行反向传播</li>
<li>更新参数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#1. 准备数据 y = 3x+0.8，准备参数</span></span><br><span class="line">x = torch.rand([<span class="number">50</span>])</span><br><span class="line">y = <span class="number">3</span>*x + <span class="number">0.8</span></span><br><span class="line"></span><br><span class="line">w = torch.rand(<span class="number">1</span>,requires_grad=<span class="literal">True</span>)</span><br><span class="line">b = torch.rand(<span class="number">1</span>,requires_grad=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss_fn</span>(<span class="params">y,y_predict</span>):</span></span><br><span class="line">    loss = (y_predict-y).<span class="built_in">pow</span>(<span class="number">2</span>).mean()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [w,b]:</span><br><span class="line">		<span class="comment">#每次反向传播前把梯度置为0</span></span><br><span class="line">        <span class="keyword">if</span> i.grad <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            i.grad.data.zero_()</span><br><span class="line">    <span class="comment"># [i.grad.data.zero_() for i in [w,b] if i.grad is not None]</span></span><br><span class="line">    loss.backward()</span><br><span class="line">    <span class="keyword">return</span> loss.data</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimize</span>(<span class="params">learning_rate</span>):</span></span><br><span class="line">    <span class="comment"># print(w.grad.data,w.data,b.data)</span></span><br><span class="line">    w.data -= learning_rate* w.grad.data</span><br><span class="line">    b.data -= learning_rate* b.grad.data</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3000</span>):</span><br><span class="line">    <span class="comment">#2. 计算预测值</span></span><br><span class="line">    y_predict = x*w + b</span><br><span class="line">	</span><br><span class="line">    <span class="comment">#3.计算损失，把参数的梯度置为0，进行反向传播 </span></span><br><span class="line">    loss = loss_fn(y,y_predict)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(i,loss)</span><br><span class="line">    <span class="comment">#4. 更新参数w和b</span></span><br><span class="line">    optimize(<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制图形，观察训练结束的预测值和真实值</span></span><br><span class="line">predict =  x*w + b  <span class="comment">#使用训练后的w和b计算预测值</span></span><br><span class="line"></span><br><span class="line">plt.scatter(x.data.numpy(), y.data.numpy(),c = <span class="string">&quot;r&quot;</span>)</span><br><span class="line">plt.plot(x.data.numpy(), predict.data.numpy())</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;w&quot;</span>,w)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b&quot;</span>,b)</span><br></pre></td></tr></table></figure>



<p>图形效果如下：</p>
<img src="/2021/07/17/pytorch2/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%921.png" class>  

<p>打印w和b，可有</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w tensor([<span class="number">2.9280</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line">b tensor([<span class="number">0.8372</span>], requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>可知，w和b已经非常接近原来的预设的3和0.8</p>
<h1 id="二、调用API线性回归"><a href="#二、调用API线性回归" class="headerlink" title="二、调用API线性回归"></a>二、调用API线性回归</h1><h2 id="1-Pytorch完成模型常用API"><a href="#1-Pytorch完成模型常用API" class="headerlink" title="1. Pytorch完成模型常用API"></a>1. Pytorch完成模型常用API</h2><p>在前一部分，我们自己实现了通过torch的相关方法完成反向传播和参数更新，在pytorch中预设了一些更加灵活简单的对象，让我们来构造模型、定义损失，优化损失等</p>
<p>那么接下来，我们一起来了解一下其中常用的API</p>
<h3 id="1-1-nn-Module"><a href="#1-1-nn-Module" class="headerlink" title="1.1 nn.Module"></a>1.1 <code>nn.Module</code></h3><p><code>nn.Module</code> 是<code>torch.nn</code>提供的一个类，是pytorch中我们<code>自定义网络</code>的一个基类，在这个类中定义了很多有用的方法，让我们在继承这个类定义网络的时候非常简单</p>
<p>当我们自定义网络的时候，有两个方法需要特别注意：</p>
<ol>
<li><code>__init__</code>需要调用<code>super</code>方法，继承父类的属性和方法</li>
<li><code>farward</code>方法必须实现，用来定义我们的网络的向前计算的过程</li>
</ol>
<p>用前面的<code>y = wx+b</code>的模型举例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lr</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Lr, self).__init__()  <span class="comment">#继承父类init的参数</span></span><br><span class="line">        self.linear = nn.Linear(<span class="number">1</span>, <span class="number">1</span>) </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        out = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><code>nn.Linear</code>为torch预定义好的线性模型，也被称为<strong>全链接层</strong>，传入的参数为输入的数量，输出的数量(in_features, out_features),是不算(batch_size的列数)</li>
<li><code>nn.Module</code>定义了<code>__call__</code>方法，实现的就是调用<code>forward</code>方法，即<code>Lr</code>的实例，能够直接被传入参数调用，实际上调用的是<code>forward</code>方法并传入参数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实例化模型</span></span><br><span class="line">model = Lr()</span><br><span class="line"><span class="comment"># 传入数据，计算结果</span></span><br><span class="line">predict = model(x)</span><br></pre></td></tr></table></figure>

<h3 id="1-2-优化器类"><a href="#1-2-优化器类" class="headerlink" title="1.2 优化器类"></a>1.2 优化器类</h3><p>优化器(<code>optimizer</code>)，可以理解为torch为我们封装的用来进行更新参数的方法，比如常见的随机梯度下降(<code>stochastic gradient descent,SGD</code>)</p>
<p>优化器类都是由<code>torch.optim</code>提供的，例如</p>
<ol>
<li><code>torch.optim.SGD(参数，学习率)</code></li>
<li><code>torch.optim.Adam(参数，学习率)</code></li>
</ol>
<p>注意：</p>
<ol>
<li>参数可以使用<code>model.parameters()</code>来获取，获取模型中所有<code>requires_grad=True</code>的参数</li>
<li>优化类的使用方法<ol>
<li>实例化</li>
<li>所有参数的梯度，将其值置为0</li>
<li>反向传播计算梯度</li>
<li>更新参数值</li>
</ol>
</li>
</ol>
<p>示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">1e-3</span>) <span class="comment">#1. 实例化</span></span><br><span class="line">optimizer.zero_grad() <span class="comment">#2. 梯度置为0</span></span><br><span class="line">loss.backward() <span class="comment">#3. 计算梯度</span></span><br><span class="line">optimizer.step()  <span class="comment">#4. 更新参数的值</span></span><br></pre></td></tr></table></figure>



<h3 id="1-3-损失函数"><a href="#1-3-损失函数" class="headerlink" title="1.3 损失函数"></a>1.3 损失函数</h3><p>前面的例子是一个回归问题，torch中也预测了很多损失函数</p>
<ol>
<li>均方误差:<code>nn.MSELoss()</code>,常用于回归问题</li>
<li>交叉熵损失：<code>nn.CrossEntropyLoss()</code>，常用于分类问题</li>
</ol>
<p>使用方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = Lr() <span class="comment">#1. 实例化模型</span></span><br><span class="line">criterion = nn.MSELoss() <span class="comment">#2. 实例化损失函数</span></span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">1e-3</span>) <span class="comment">#3. 实例化优化器类</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    y_predict = model(x_true) <span class="comment">#4. 向前计算预测值</span></span><br><span class="line">    loss = criterion(y_true,y_predict) <span class="comment">#5. 调用损失函数传入真实值和预测值，得到损失结果</span></span><br><span class="line">    optimizer.zero_grad() <span class="comment">#5. 当前循环参数梯度置为0</span></span><br><span class="line">    loss.backward() <span class="comment">#6. 计算梯度</span></span><br><span class="line">    optimizer.step()  <span class="comment">#7. 更新参数的值</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-把线性回归完整代码"><a href="#1-4-把线性回归完整代码" class="headerlink" title="1.4 把线性回归完整代码"></a>1.4 把线性回归完整代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 定义数据</span></span><br><span class="line">x = torch.rand([<span class="number">50</span>,<span class="number">1</span>])</span><br><span class="line">y = x*<span class="number">3</span> + <span class="number">0.8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2 .定义模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lr</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Lr,self).__init__()</span><br><span class="line">        self.linear = nn.Linear(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">		</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        out = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 实例化模型，loss，和优化器</span></span><br><span class="line">model = Lr()</span><br><span class="line">criterion = nn.MSELoss()</span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">1e-3</span>)</span><br><span class="line"><span class="comment">#3. 训练模型</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30000</span>):</span><br><span class="line">    out = model(x) <span class="comment">#3.1 获取预测值</span></span><br><span class="line">    loss = criterion(y,out) <span class="comment">#3.2 计算损失</span></span><br><span class="line">    optimizer.zero_grad()  <span class="comment">#3.3 梯度归零</span></span><br><span class="line">    loss.backward() <span class="comment">#3.4 计算梯度</span></span><br><span class="line">    optimizer.step()  <span class="comment"># 3.5 更新梯度</span></span><br><span class="line">    <span class="keyword">if</span> (i+<span class="number">1</span>) % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Epoch[&#123;&#125;/&#123;&#125;], loss: &#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(i,<span class="number">30000</span>,loss.data))</span><br><span class="line"></span><br><span class="line"><span class="comment">#4. 模型评估</span></span><br><span class="line">model.<span class="built_in">eval</span>() <span class="comment">#设置模型为评估模式，即预测模式</span></span><br><span class="line">predict = model(x)</span><br><span class="line">predict = predict.data.numpy()</span><br><span class="line">plt.scatter(x.data.numpy(),y.data.numpy(),c=<span class="string">&quot;r&quot;</span>)</span><br><span class="line">plt.plot(x.data.numpy(),predict)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<img src="/2021/07/17/pytorch2/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%922.png" class>  

<p>注意：</p>
<p><code>model.eval()</code>表示设置模型为评估模式，即预测模式</p>
<p><code>model.train(mode=True)</code> 表示设置模型为训练模式</p>
<p>在当前的线性回归中，上述并无区别</p>
<p>但是在其他的一些模型中，<strong>训练的参数和预测的参数会不相同</strong>，到时候就需要具体告诉程序我们是在进行训练还是预测，比如模型中存在<strong>Dropout</strong>，<strong>BatchNorm</strong>的时候</p>
<h2 id="2-在GPU上运行代码"><a href="#2-在GPU上运行代码" class="headerlink" title="2. 在GPU上运行代码"></a>2. 在GPU上运行代码</h2><p>当模型太大，或者参数太多的情况下，为了加快训练速度，经常会使用GPU来进行训练</p>
<p>此时我们的代码需要稍作调整：</p>
<ol>
<li><p>判断GPU是否可用<code>torch.cuda.is_available()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">&gt;&gt;device(<span class="built_in">type</span>=<span class="string">&#x27;cuda&#x27;</span>, index=<span class="number">0</span>)  <span class="comment">#使用gpu</span></span><br><span class="line">&gt;&gt;device(<span class="built_in">type</span>=<span class="string">&#x27;cpu&#x27;</span>) <span class="comment">#使用cpu</span></span><br></pre></td></tr></table></figure></li>
<li><p>把模型参数和input数据转化为cuda的支持类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.to(device)</span><br><span class="line">x_true.to(device)</span><br></pre></td></tr></table></figure></li>
<li><p>在GPU上计算结果也为cuda的数据类型，需要转化为numpy或者torch的cpu的tensor类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">predict = predict.cpu().detach().numpy() </span><br></pre></td></tr></table></figure>

<p><code>detach()</code>的效果和data的相似，但是<code>detach()</code>是深拷贝，data是取值，是浅拷贝</p>
</li>
</ol>
<p>修改之后的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 定义数据</span></span><br><span class="line">x = torch.rand([<span class="number">50</span>,<span class="number">1</span>])</span><br><span class="line">y = x*<span class="number">3</span> + <span class="number">0.8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2 .定义模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lr</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Lr,self).__init__()</span><br><span class="line">        self.linear = nn.Linear(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        out = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 实例化模型，loss，和优化器</span></span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">x,y = x.to(device),y.to(device)</span><br><span class="line"></span><br><span class="line">model = Lr().to(device)</span><br><span class="line">criterion = nn.MSELoss()</span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">1e-3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3. 训练模型</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">300</span>):</span><br><span class="line">    out = model(x)</span><br><span class="line">    loss = criterion(y,out)</span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line">    <span class="keyword">if</span> (i+<span class="number">1</span>) % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Epoch[&#123;&#125;/&#123;&#125;], loss: &#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(i,<span class="number">30000</span>,loss.data))</span><br><span class="line"></span><br><span class="line"><span class="comment">#4. 模型评估</span></span><br><span class="line">model.<span class="built_in">eval</span>() <span class="comment">#</span></span><br><span class="line">predict = model(x)</span><br><span class="line">predict = predict.cpu().detach().numpy() <span class="comment">#转化为numpy数组</span></span><br><span class="line">plt.scatter(x.cpu().data.numpy(),y.cpu().data.numpy(),c=<span class="string">&quot;r&quot;</span>)</span><br><span class="line">plt.plot(x.cpu().data.numpy(),predict,)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-常见的优化算法介绍"><a href="#3-常见的优化算法介绍" class="headerlink" title="3. 常见的优化算法介绍"></a>3. 常见的优化算法介绍</h2><h3 id="3-1-梯度下降算法（batch-gradient-descent-BGD）"><a href="#3-1-梯度下降算法（batch-gradient-descent-BGD）" class="headerlink" title="3.1 梯度下降算法（batch gradient descent BGD）"></a>3.1 梯度下降算法（batch gradient descent BGD）</h3><p>每次迭代都需要把所有样本都送入，这样的好处是每次迭代都顾及了全部的样本，做的是全局最优化,但是有可能达到局部最优。</p>
<h3 id="3-2-随机梯度下降法-Stochastic-gradient-descent-SGD"><a href="#3-2-随机梯度下降法-Stochastic-gradient-descent-SGD" class="headerlink" title="3.2 随机梯度下降法 (Stochastic gradient descent SGD)"></a>3.2 随机梯度下降法 (Stochastic gradient descent SGD)</h3><p>针对梯度下降算法训练速度过慢的缺点，提出了随机梯度下降算法，随机梯度下降算法算法是从样本中随机抽出一组，训练后按梯度更新一次，然后再抽取一组，再更新一次，在样本量及其大的情况下，可能不用训练完所有的样本就可以获得一个损失值在可接受范围之内的模型了。</p>
<p>torch中的api为：<code>torch.optim.SGD()</code></p>
<h3 id="3-3-小批量梯度下降-Mini-batch-gradient-descent-MBGD）"><a href="#3-3-小批量梯度下降-Mini-batch-gradient-descent-MBGD）" class="headerlink" title="3.3 小批量梯度下降 (Mini-batch gradient descent MBGD）"></a>3.3 小批量梯度下降 (Mini-batch gradient descent MBGD）</h3><p>SGD相对来说要快很多，但是也有存在问题，由于单个样本的训练可能会带来很多噪声，使得SGD并不是每次迭代都向着整体最优化方向，因此在刚开始训练时可能收敛得很快，但是训练一段时间后就会变得很慢。在此基础上又提出了小批量梯度下降法，它是每次从样本中随机抽取一小批进行训练，而不是一组，这样即保证了效果又保证的速度。</p>
<h3 id="3-4-动量法"><a href="#3-4-动量法" class="headerlink" title="3.4 动量法"></a>3.4 动量法</h3><p>mini-batch SGD算法虽然这种算法能够带来很好的训练速度，但是在到达最优点的时候并不能够总是真正到达最优点，而是在最优点附近徘徊。</p>
<p>另一个缺点就是mini-batch SGD需要我们挑选一个合适的学习率，当我们采用小的学习率的时候，会导致网络在训练的时候收敛太慢；当我们采用大的学习率的时候，会导致在训练过程中优化的幅度跳过函数的范围，也就是可能跳过最优点。我们所希望的仅仅是网络在优化的时候网络的损失函数有一个很好的收敛速度同时又不至于摆动幅度太大。</p>
<p>所以Momentum优化器刚好可以解决我们所面临的问题，它主要是基于梯度的移动指数加权平均，对网络的梯度进行平滑处理的，让梯度的摆动幅度变得更小。<br>$$<br>\begin{align*}<br>&amp;gradent = 0.8\nabla w + 0.2 history_gradent  &amp;，\nabla w 表示当前一次的梯度\<br>&amp;w = w - \alpha* gradent &amp;，\alpha表示学习率<br>\end{align*}<br>$$</p>
<p>（注：t+1的的histroy_gradent 为第t次的gradent）</p>
<h3 id="3-5-AdaGrad"><a href="#3-5-AdaGrad" class="headerlink" title="3.5 AdaGrad"></a>3.5 AdaGrad</h3><p>AdaGrad算法就是将每一个参数的每一次迭代的梯度取平方累加后在开方，用全局学习率除以这个数，作为学习率的动态更新，从而达到<strong>自适应学习率</strong>的效果<br>$$<br>\begin{align*}<br>&amp;gradent = history_gradent + (\nabla w)^2 \<br>&amp;w = w - \frac{\alpha}{\sqrt{gradent}+\delta} \nabla w &amp;，\delta为小常数，为了数值稳定大约设置为10^{-7}<br>\end{align*}<br>$$</p>
<h3 id="3-6-RMSProp"><a href="#3-6-RMSProp" class="headerlink" title="3.6 RMSProp"></a>3.6 RMSProp</h3><p>Momentum优化算法中，虽然初步解决了优化中摆动幅度大的问题,为了进一步优化损失函数在更新中存在摆动幅度过大的问题，并且进一步加快函数的收敛速度，RMSProp算法对参数的梯度使用了平方加权平均数。<br>$$<br>\begin{align*}<br>&amp; gradent = 0.8<em>history_gradent + 0.2</em>(\nabla w)^2 \<br>&amp; w = w - \frac{\alpha}{\sqrt{gradent}+\delta} \nabla w<br>\end{align*}<br>$$</p>
<h3 id="3-7-Adam"><a href="#3-7-Adam" class="headerlink" title="3.7 Adam"></a>3.7 Adam</h3><p>Adam（Adaptive Moment Estimation）算法是将Momentum算法和RMSProp算法结合起来使用的一种算法,能够达到防止梯度的摆幅多大，同时还能够加开收敛速度<br>$$<br>\begin{align*}<br>&amp; 1. 需要初始化梯度的累积量和平方累积量 \<br>&amp; v_w = 0,s_w = 0 \<br>&amp; 2. 第 t 轮训练中，我们首先可以计算得到Momentum和RMSProp的参数更新：\<br>&amp; v_w = 0.8v  + 0.2 \nabla w \qquad,Momentum计算的梯度\<br>&amp; s_w = 0.8<em>s + 0.2</em>(\nabla w)^2 \qquad,RMSProp计算的梯度\<br>&amp; 3. 对其中的值进行处理后，得到：\<br>&amp; w = w - \frac{\alpha}{\sqrt{s_w}+\delta} v_w<br>\end{align*}<br>$$<br>torch中的api为：<code>torch.optim.Adam()</code></p>
<h3 id="3-8-效果演示："><a href="#3-8-效果演示：" class="headerlink" title="3.8 效果演示："></a>3.8 效果演示：</h3><img src="/2021/07/17/pytorch2/%E4%BC%98%E5%8C%96%E5%99%A8%E6%96%B9%E6%B3%95.gif" class>  

]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实验课作业二——进程调度</title>
    <url>/2021/04/19/processtest/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&ensp;&ensp;&ensp;&ensp;用JAVA模拟进程调度过程。个人实验报告使用，如果想参考，不得保留原文40%以上，谢谢配合。</p>
<span id="more"></span>

<h1 id="一、实验目的及要求"><a href="#一、实验目的及要求" class="headerlink" title="一、实验目的及要求"></a>一、实验目的及要求</h1><p>&ensp;&ensp;&ensp;&ensp;进程调度是处理机管理的核心内容。本实验要求用高级语言编写模拟进程调度程序，以便加深理解有关进程控制块、进程队列等概念，并体会和了解先来先服务（FCFS算法）、短进程优先（SJF算法），优先权（PSA算法）、高响应比优先（HRN算法）等调度算法的具体实现。</p>
<h1 id="二、基本理论介绍"><a href="#二、基本理论介绍" class="headerlink" title="二、基本理论介绍"></a>二、基本理论介绍</h1><h2 id="2-1-处理机调度的基本概念"><a href="#2-1-处理机调度的基本概念" class="headerlink" title="2.1 处理机调度的基本概念"></a>2.1 处理机调度的基本概念</h2><p>&ensp;&ensp;&ensp;&ensp;处理机是计算机系统中的重要资源，处理机调度算法不仅对处理器的利用效率和用户进程的执行有影响，同时还与内存等其他资源的使用密切相关，对整个计算机系统的综合性能指标也有重要影响。</p>
<h2 id="2-2-进程调度方式"><a href="#2-2-进程调度方式" class="headerlink" title="2.2 进程调度方式"></a>2.2 进程调度方式</h2><h3 id="1）抢占式（剥夺式）"><a href="#1）抢占式（剥夺式）" class="headerlink" title="1）抢占式（剥夺式）"></a>1）抢占式（剥夺式）</h3><p>&ensp;&ensp;&ensp;&ensp;当一个进程正在处理器上运行时，系统可以根据规定的原则剥夺分配给它的处理器，而把处理器分配给其它进程使用</p>
<h3 id="2）非抢占式（非剥夺式）"><a href="#2）非抢占式（非剥夺式）" class="headerlink" title="2）非抢占式（非剥夺式）"></a>2）非抢占式（非剥夺式）</h3><p>&ensp;&ensp;&ensp;&ensp;一旦某个进程开始执行后便不再出让处理器，除非该进程运行结束或发生了某个事件不能继续执行。</p>
<h2 id="2-3-本实验所使用的调度算法"><a href="#2-3-本实验所使用的调度算法" class="headerlink" title="2.3 本实验所使用的调度算法"></a>2.3 本实验所使用的调度算法</h2><h3 id="1）先来先服务（FCFS）"><a href="#1）先来先服务（FCFS）" class="headerlink" title="1）先来先服务（FCFS）"></a>1）先来先服务（FCFS）</h3><p>&ensp;&ensp;&ensp;&ensp; 按照进程进入就绪队列的先后顺序调度并分配处理机执行。先来先服务调度算法是一种非抢占式的算法，先进入就绪队列的进程，先分配处理机运行。一旦一个进程占有了处理机，它就一直运行下去，直到该进程完成工作或者因为等待某事件发生而不能运行时才释放处理机。<br>&ensp;&ensp;&ensp;&ensp;（1）系统只有按FIFO规则建立的后备作业队列或就绪进程队列即可，就是一个作业控制快JCB或进程控制块PCB加入队列时加在相应队列末尾。<br>&ensp;&ensp;&ensp;&ensp;（2）调度退出队列时从相应队列首开始顺序扫描，将相关的JCB或PCB调度移出相应队列。<br>&ensp;&ensp;&ensp;&ensp;（3）优缺点：有利于长作业（进程）而不利于短作业（进程）；有利于CPU繁忙型作业（进程），而不利于I/O繁忙型作业（进程）。  </p>
<h3 id="2）非剥夺式的短作业优先算法（SJF）"><a href="#2）非剥夺式的短作业优先算法（SJF）" class="headerlink" title="2）非剥夺式的短作业优先算法（SJF）"></a>2）非剥夺式的短作业优先算法（SJF）</h3><p>&ensp;&ensp;&ensp;&ensp;短进程优先算法是以作业的长短来计算优先级，作业越短，其优先级越高。作业的长短是以作业所要求的运行时间来衡量的。在把短作业优先调度算法用于作业调度时，它将从外存的作业后备队列中选择若干个估计运行时间最短的作业，优先将它们调入内存运行。<br>&ensp;&ensp;&ensp;&ensp;(1)比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；<br>&ensp;&ensp;&ensp;&ensp;(2)对长作业非常不利，可能长时间得不到执行；未能依据作业的紧迫程度来划分执行的优先级；难以准确估计作业（进程）的执行时间，从而影响调度性能。</p>
<h3 id="3）非剥夺式的优先级算法（PSA）"><a href="#3）非剥夺式的优先级算法（PSA）" class="headerlink" title="3）非剥夺式的优先级算法（PSA）"></a>3）非剥夺式的优先级算法（PSA）</h3><p>&ensp;&ensp;&ensp;&ensp;优先级算法是多级队列算法的改进，平衡各进程对响应时间的要求。适用于作业调度和进程调度，可分成抢先式和非抢先式。<br>&ensp;&ensp;&ensp;&ensp;作业调度中的静态优先级大多按以下原则确定：<br>&ensp;&ensp;&ensp;&ensp;（1）由用户自己根据作业的紧急程度输入一个适当的优先级。<br>&ensp;&ensp;&ensp;&ensp;（2）由系统或操作员根据作业类型指定优先级。<br>&ensp;&ensp;&ensp;&ensp;（3）系统根据作业要求资源情况确定优先级。  </p>
<h3 id="4）最高响应比优先法（HRN）"><a href="#4）最高响应比优先法（HRN）" class="headerlink" title="4）最高响应比优先法（HRN）"></a>4）最高响应比优先法（HRN）</h3><p>&ensp;&ensp;&ensp;&ensp;最高响应比优先法(HRN，Highest Response_ratio Next)是对FCFS方式和SJF方式的一种综合平衡。FCFS方式只考虑每个作业的等待时间而未考虑执行时间的长短，而SJF方式只考虑执行时间而未考虑等待时间的长短。因此，这两种调度算法在某些极端情况下会带来某些不便。HRN调度策略同时考虑每个作业的等待时间长短和估计需要的执行时间长短，从中选出响应比最高的作业投入执行。<br>&ensp;&ensp;&ensp;&ensp;响应比R定义如下：<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;R =(W+T)/T = 1+W/T<br>&ensp;&ensp;&ensp;&ensp;其中T为该作业估计需要的执行时间，W为作业在后备状态队列中的等待时间。每当要进行作业调度时，系统计算每个作业的响应比，选择其中R最大者投入执行。这样，即使是长作业，随着它等待时间的增加，W / T也就随着增加，也就有机会获得调度执行。这种算法是介于FCFS和SJF之间的一种折中算法。由于长作业也有机会投入运行，在同一时间内处理的作业数显然要少于SJF法，从而采用HRN方式时其吞吐量将小于采用SJF法时的吞吐量。另外，由于每次调度前要计算响应比，系统开销也要相应增加。</p>
<h1 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h1><p>1.设计进程控制块PCB的结构，通常应包括如下信息：<br>&ensp;&ensp;&ensp;&ensp;进程名、进程优先数、进程的到达时间、服务时间、进程的状态等<br>2.编写四种调度算法程序：<br>&ensp;&ensp;&ensp;&ensp;FCFS&ensp;&ensp;&ensp;&ensp;非抢占SJF&ensp;&ensp;&ensp;&ensp; 非抢占PSA &ensp;&ensp;&ensp;&ensp;HRRN<br>3.输入参数。<br>&ensp;&ensp;&ensp;&ensp;输入进程数目<br>&ensp;&ensp;&ensp;&ensp;各进程的相关数据（进程ID,到达时间，服务时间，优先级等）<br>4.选择调度算法<br>5.按要求输出结果（界面简洁美观）<br>&ensp;&ensp;&ensp;&ensp;1）要求输出调度过程<br>&ensp;&ensp;&ensp;&ensp;2）要求输出各进程在不同的算法下的完成时间，周转时间，带权周转时间，平均周转时间，平均带权周转时间，以及调度顺序。</p>
<h1 id="四、功能实现"><a href="#四、功能实现" class="headerlink" title="四、功能实现"></a>四、功能实现</h1><p>代码部分参考：<a href="https://blog.csdn.net/qq_37373250/article/details/85526518">https://blog.csdn.net/qq_37373250/article/details/85526518</a></p>
<h2 id="4-1-定义JCB（或PCB）"><a href="#4-1-定义JCB（或PCB）" class="headerlink" title="4.1 定义JCB（或PCB）"></a>4.1 定义JCB（或PCB）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JCB</span> </span>&#123;</span><br><span class="line">	String name;<span class="comment">//进程名</span></span><br><span class="line">	<span class="keyword">int</span> arriveTime;<span class="comment">//到达时间</span></span><br><span class="line">	<span class="keyword">int</span> serveTime;<span class="comment">//服务时间</span></span><br><span class="line">	<span class="keyword">int</span> beginTime;<span class="comment">//开始时间</span></span><br><span class="line">	<span class="keyword">int</span> finshTime;<span class="comment">//结束时间</span></span><br><span class="line">	<span class="keyword">int</span> roundTime;<span class="comment">//周转时间</span></span><br><span class="line">	<span class="keyword">double</span> aveRoundTime;<span class="comment">//带权周转时间</span></span><br><span class="line">	<span class="keyword">int</span> waitTime;<span class="comment">//记录每个进程到达后的等待时间，只用于最高响应比优先调度算法中</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">JCB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">JCB</span><span class="params">(String name, <span class="keyword">int</span> arriveTime, <span class="keyword">int</span> serveTime,<span class="keyword">double</span> priority)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.arriveTime = arriveTime;</span><br><span class="line">		<span class="keyword">this</span>.serveTime = serveTime;</span><br><span class="line">		<span class="keyword">this</span>.waitTime = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String info = <span class="keyword">new</span> String(<span class="string">&quot;进程名：&quot;</span>+<span class="keyword">this</span>.name);</span><br><span class="line">		<span class="keyword">return</span> info;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;JCB类的代码如上所示，为方便JCB实例的创建，构造函数使用相关数据作为参数（进程名、到达时间、服务时间、优先级）。</p>
<h2 id="4-2-四种算法的实现"><a href="#4-2-四种算法的实现" class="headerlink" title="4.2 四种算法的实现"></a>4.2 四种算法的实现</h2><p>&ensp;&ensp;&ensp;&ensp;基本思想是通过各种算法来定义不同的排序方式，然后用队列一一加载排好序的进程，之后逐个进行工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">processMenu</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	ArrayList&lt;JCB&gt; jcb;<span class="comment">// 存放所有进程</span></span><br><span class="line">	LinkedList&lt;JCB&gt; link;<span class="comment">// 存放已经进入队列的进程</span></span><br><span class="line">	ArrayList&lt;JCB&gt; new_jcb;<span class="comment">// 存放按指定调度算法排序后的进程</span></span><br><span class="line">	JCB nowProess;<span class="comment">// 当前应执行进程</span></span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">		jcb = <span class="keyword">new</span> ArrayList&lt;JCB&gt;();</span><br><span class="line">		link = <span class="keyword">new</span> LinkedList&lt;JCB&gt;();</span><br><span class="line">		new_jcb = <span class="keyword">new</span> ArrayList&lt;JCB&gt;();</span><br><span class="line">		JCB p1 = <span class="keyword">new</span> JCB(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">		JCB p2 = <span class="keyword">new</span> JCB(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">		JCB p3 = <span class="keyword">new</span> JCB(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">		JCB p4 = <span class="keyword">new</span> JCB(<span class="string">&quot;D&quot;</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">		JCB p5 = <span class="keyword">new</span> JCB(<span class="string">&quot;E&quot;</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">		jcb.add(p1);jcb.add(p2);jcb.add(p3);jcb.add(p4);jcb.add(p5);</span><br><span class="line">		<span class="comment">//先将jcb排序，便于下面的算法实现，就不需要再定义一个标识进程是否已到达的boolean,即无需每次都从头开始扫描jcb容器，</span></span><br><span class="line">		<span class="comment">//而是用一个K记录下当前已经扫描到的位置，一次遍历即可，提高了算法效率。</span></span><br><span class="line">		Collections.sort(jcb, <span class="keyword">new</span> compareAt_St());</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FCFS</span><span class="params">()</span></span>&#123;<span class="comment">//先来先服务算法</span></span><br><span class="line">		ProcessQueue pq=<span class="keyword">new</span> ProcessQueue();<span class="comment">//调用内部类</span></span><br><span class="line">		pq.EnqueueLast();<span class="comment">//让最先到达的进程先入队</span></span><br><span class="line">		System.out.println(<span class="string">&quot;*****************************************************&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span>(!link.isEmpty()) &#123;<span class="comment">//while(new_jcb.size()!=jcb.size())</span></span><br><span class="line">			pq.DisplayQueue();<span class="comment">//打印当前队列中的进程</span></span><br><span class="line">			pq.Dequeue();<span class="comment">//出队，一次一个</span></span><br><span class="line">			pq.EnqueueLast();<span class="comment">//已到达的进程入队</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SJF</span><span class="params">()</span> </span>&#123;<span class="comment">// 短作业优先算法</span></span><br><span class="line">		ProcessQueue pq=<span class="keyword">new</span> ProcessQueue();</span><br><span class="line">		pq.EnqueueLast();</span><br><span class="line">		System.out.println(<span class="string">&quot;*****************************************************&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span>(!link.isEmpty()) &#123;</span><br><span class="line">			pq.DisplayQueue();<span class="comment">//打印当前队列中的进程</span></span><br><span class="line">			pq.Dequeue();<span class="comment">//出队，一次一个</span></span><br><span class="line">			pq.EnqueueLast();<span class="comment">//已到达的进程入队</span></span><br><span class="line">			Collections.sort(link, <span class="keyword">new</span> compareSt());<span class="comment">//队列中的进程还需按服务时间长度进行排序</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RR</span><span class="params">()</span> </span>&#123;<span class="comment">//时间片轮转调度算法</span></span><br><span class="line">		ProcessQueue pq=<span class="keyword">new</span> ProcessQueue();</span><br><span class="line">		pq.EnqueueLast();</span><br><span class="line">		System.out.println(<span class="string">&quot;*****************************************************&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span>(!link.isEmpty()) &#123;</span><br><span class="line">			pq.DisplayQueue();<span class="comment">//打印当前队列中的进程</span></span><br><span class="line">			pq.Dequeue(<span class="number">1</span>);<span class="comment">//出队，一次一个，因为上一轮出的得让刚到达的进程先进队列，所以没办法，进队操作只能也放在这个函数里了</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HRN</span><span class="params">()</span> </span>&#123;<span class="comment">//最高响应比优先调度算法</span></span><br><span class="line">		ProcessQueue pq=<span class="keyword">new</span> ProcessQueue();</span><br><span class="line">		pq.EnqueueLast();</span><br><span class="line">		System.out.println(<span class="string">&quot;*****************************************************&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span>(!link.isEmpty()) &#123;</span><br><span class="line">			pq.DisplayQueue();<span class="comment">//打印当前队列中的进程</span></span><br><span class="line">			pq.Dequeue();<span class="comment">//出队，一次一个</span></span><br><span class="line">			pq.EnqueueLast();<span class="comment">//已到达的进程入队</span></span><br><span class="line">			Collections.sort(link, <span class="keyword">new</span> comparePriority());<span class="comment">//队列中的进程还需按响应比进行排序</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">ProcessQueue</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">// jcb中的进程遍历时的下标</span></span><br><span class="line">		<span class="keyword">int</span> nowTime = <span class="number">0</span>;<span class="comment">// 当前时间</span></span><br><span class="line">		<span class="keyword">double</span> sliceTime;<span class="comment">//轮转调度时间片</span></span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//记录当前出入队列的次数</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EnqueueLast</span><span class="params">()</span> </span>&#123;<span class="comment">//进程首次入队，可一次进多个,从队尾进入</span></span><br><span class="line">			<span class="keyword">while</span> (k &lt; jcb.size()) &#123;<span class="comment">//当遍历完jcb中的所有进程时结束</span></span><br><span class="line">				<span class="keyword">if</span> (jcb.get(k).arriveTime &lt;= nowTime) &#123;<span class="comment">//已经到达的进程按到达时间先后进入队列</span></span><br><span class="line">					link.addLast(jcb.get(k));</span><br><span class="line">					k++;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">break</span>;<span class="comment">//如果该进程还未入队，即先结束遍历，保留当前下标k值，注意：此处不要k--；</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EnqueueFirst</span><span class="params">()</span> </span>&#123;<span class="comment">//进程首次入队，可一次进多个,从队首进入</span></span><br><span class="line">			<span class="keyword">while</span> (k &lt; jcb.size()) &#123;<span class="comment">//当遍历完jcb中的所有进程时结束</span></span><br><span class="line">				<span class="keyword">if</span> (jcb.get(k).arriveTime &lt;= nowTime) &#123;<span class="comment">//已经到达的进程按到达时间先后进入队列</span></span><br><span class="line">					link.addFirst(jcb.get(k));</span><br><span class="line">					k++;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">break</span>;<span class="comment">//如果该进程还未入队，即先结束遍历，保留当前下标k值，注意：此处不要k--；</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dequeue</span><span class="params">()</span> </span>&#123;<span class="comment">//进程出队，一次只出一个</span></span><br><span class="line">			nowProess = link.removeFirst();<span class="comment">//移除队列的队首元素并且返回该对象元素</span></span><br><span class="line">			nowProess.beginTime = nowTime;<span class="comment">//计算开始时间，即为上一个进程的结束时间</span></span><br><span class="line">			nowProess.finshTime = nowProess.beginTime + nowProess.serveTime;<span class="comment">//计算结束时间，该进程开始时间+服务时间</span></span><br><span class="line">			nowProess.roundTime = nowProess.finshTime - nowProess.arriveTime;<span class="comment">//计算周转时间</span></span><br><span class="line">			nowProess.aveRoundTime = (<span class="keyword">double</span>) nowProess.roundTime / nowProess.serveTime;<span class="comment">//计算平均周转时间</span></span><br><span class="line">			nowTime = nowProess.finshTime;<span class="comment">//获得结束时间，即当前时间，方便判断剩下的进程是否已到达</span></span><br><span class="line">			new_jcb.add(nowProess);<span class="comment">//经处理过数据后加入new_jcb容器</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;link.size();++i) &#123;</span><br><span class="line">				link.get(i).waitTime++;<span class="comment">//所有进入等待队列的进程等待时间+1,此处只为最高响应比算法所用</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dequeue</span><span class="params">(<span class="keyword">double</span> sliceTime)</span> </span>&#123;<span class="comment">//重载Dequeue方法，实现轮转调度算法的出队</span></span><br><span class="line">			nowProess = link.removeFirst();<span class="comment">//移除队列的队首元素并且返回该对象元素</span></span><br><span class="line">			<span class="keyword">if</span>(nowProess.firstTimeTag==<span class="keyword">false</span>) &#123;</span><br><span class="line">				<span class="comment">/*轮转调度进程可能会多次反复进出队列，不像FCFS和SJF的进程只会进出一次，所以计算开始时间可以设个标志位，让每个进程在</span></span><br><span class="line"><span class="comment">				 * 第一次执行时记录一遍即可*/</span></span><br><span class="line">				nowProess.beginTime=nowTime;<span class="comment">//进程开始执行的时间</span></span><br><span class="line">				nowProess.firstTimeTag=<span class="keyword">true</span>;<span class="comment">//计算第一次即可，下次无需更新计算</span></span><br><span class="line">			&#125;</span><br><span class="line">			nowTime+=sliceTime;<span class="comment">//每次出队，用时一个时间片，更新当前时间</span></span><br><span class="line">			nowProess.clock+=sliceTime;<span class="comment">//更新当前出队列的进程已服务时间</span></span><br><span class="line">			<span class="keyword">if</span>(nowProess.clock&gt;=nowProess.serveTime) &#123;</span><br><span class="line">				nowProess.finshTime=nowTime;<span class="comment">//计算该进程完成时间</span></span><br><span class="line">				nowProess.roundTime = nowProess.finshTime - nowProess.arriveTime;<span class="comment">//计算周转时间</span></span><br><span class="line">				nowProess.aveRoundTime = (<span class="keyword">double</span>) nowProess.roundTime / nowProess.serveTime;<span class="comment">//计算平均周转时间</span></span><br><span class="line">				new_jcb.add(nowProess);<span class="comment">//经处理过数据后加入new_jcb容器</span></span><br><span class="line">				EnqueueFirst();<span class="comment">//已到达的进程先入队</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				EnqueueFirst();<span class="comment">//已到达的进程先入队</span></span><br><span class="line">				link.addLast(nowProess);<span class="comment">//上一轮出的再紧接着进入队尾</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisplayQueue</span><span class="params">()</span></span>&#123;<span class="comment">//队列中等候的进程</span></span><br><span class="line">			i++;</span><br><span class="line">			System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;次队列中排队的进程：&quot;</span>+link);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;进程名 到达时间  服务时间   开始时间  完成时间  周转时间  带权周转时间&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; new_jcb.size(); ++i) &#123;</span><br><span class="line">			System.out.println(new_jcb.get(i).name + <span class="string">&quot;        &quot;</span> + new_jcb.get(i).arriveTime + <span class="string">&quot;          &quot;</span> +</span><br><span class="line">		new_jcb.get(i).serveTime+ <span class="string">&quot;         &quot;</span> + new_jcb.get(i).beginTime + <span class="string">&quot;         &quot;</span> + new_jcb.get(i).finshTime +</span><br><span class="line">		<span class="string">&quot;         &quot;</span>+ new_jcb.get(i).roundTime + <span class="string">&quot;        &quot;</span> + new_jcb.get(i).aveRoundTime);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">float</span> avg_zhouzhuan,avg_daiquan;</span><br><span class="line">        <span class="keyword">float</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; new_jcb.size(); ++i)&#123;</span><br><span class="line">            sum1 += new_jcb.get(i).roundTime;</span><br><span class="line">            sum2 += new_jcb.get(i).aveRoundTime;</span><br><span class="line">        &#125;</span><br><span class="line">        avg_zhouzhuan = sum1/<span class="number">5</span>;</span><br><span class="line">        avg_daiquan = sum2/<span class="number">5</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;平均周转时间是：&quot;</span>+avg_zhouzhuan);</span><br><span class="line">        System.out.println(<span class="string">&quot;平均带权周转时间是：&quot;</span>+avg_daiquan);</span><br><span class="line">		new_jcb.clear();<span class="comment">//清空new_jcb容器内的内容，方便存储各种算法的结果并展示</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">compareSt</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">JCB</span>&gt; </span>&#123;<span class="comment">// 按服务时间升序</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(JCB arg0, JCB arg1)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> arg0.serveTime - arg1.serveTime;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">compareAt_St</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">JCB</span>&gt; </span>&#123;<span class="comment">// 按到达时间升序，若到达时间相同，按服务时间升序</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(JCB o1, JCB o2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = o1.arriveTime - o2.arriveTime;</span><br><span class="line">		<span class="keyword">if</span> (a &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> o1.serveTime &gt; o2.serveTime ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">comparePriority</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">JCB</span>&gt;</span>&#123;<span class="comment">//按响应比升序排序</span></span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(JCB o1, JCB o2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">double</span> r1=(<span class="keyword">double</span>)o1.waitTime/o1.serveTime;</span><br><span class="line">		<span class="keyword">double</span> r2=(<span class="keyword">double</span>)o2.waitTime/o2.serveTime;</span><br><span class="line">		<span class="keyword">return</span> r1&gt;r2?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProcess</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		processMenu pm=<span class="keyword">new</span> processMenu();</span><br><span class="line">		pm.init();<span class="comment">//初始化容器</span></span><br><span class="line">		pm.FCFS();pm.printProcess();</span><br><span class="line">        System.out.println(<span class="string">&quot;FCFS&quot;</span>);</span><br><span class="line">		pm.SJF();pm.printProcess();</span><br><span class="line">        System.out.println(<span class="string">&quot;SJF&quot;</span>);</span><br><span class="line">		pm.HRN();pm.printProcess();</span><br><span class="line">        System.out.println(<span class="string">&quot;HRN&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="五、结果测试与分析"><a href="#五、结果测试与分析" class="headerlink" title="五、结果测试与分析"></a>五、结果测试与分析</h1><p>以下为运行结果（因为还没搞定上传图片的功能，先复制文字替代了)</p>
<hr>
<p>第1次队列中排队的进程：[进程名：A]<br>第2次队列中排队的进程：[进程名：B, 进程名：C, 进程名：D, 进程名：E]<br>第3次队列中排队的进程：[进程名：C, 进程名：D, 进程名：E]<br>第4次队列中排队的进程：[进程名：D, 进程名：E]<br>第5次队列中排队的进程：[进程名：E]<br>进程名 到达时间  服务时间   开始时间  完成时间  周转时间  带权周转时间<br>A        0          4         0         4         4        1.0<br>B        1          3         4         7         6        2.0<br>C        2          5         7         12         10        2.0<br>D        3          2         12         14         11        5.5<br>E        4          4         14         18         14        3.5<br>平均周转时间是：9.0<br>平均带权周转时间是：2.8<br>FCFS  </p>
<hr>
<p>第1次队列中排队的进程：[进程名：A]<br>第2次队列中排队的进程：[进程名：D, 进程名：B, 进程名：E, 进程名：C]<br>第3次队列中排队的进程：[进程名：B, 进程名：E, 进程名：C]<br>第4次队列中排队的进程：[进程名：E, 进程名：C]<br>第5次队列中排队的进程：[进程名：C]<br>进程名 到达时间  服务时间   开始时间  完成时间  周转时间  带权周转时间<br>A        0          4         0         4         4        1.0<br>D        3          2         4         6         3        1.5<br>B        1          3         6         9         8        2.6666666666666665<br>E        4          4         9         13         9        2.25<br>C        2          5         13         18         16        3.2<br>平均周转时间是：8.0<br>平均带权周转时间是：2.1233335<br>SJF  </p>
<hr>
<p>第1次队列中排队的进程：[进程名：A]<br>第2次队列中排队的进程：[进程名：B, 进程名：C, 进程名：D, 进程名：E]<br>第3次队列中排队的进程：[进程名：C, 进程名：E, 进程名：D]<br>第4次队列中排队的进程：[进程名：E, 进程名：D]<br>第5次队列中排队的进程：[进程名：D]<br>进程名 到达时间  服务时间   开始时间  完成时间  周转时间  带权周转时间<br>A        0          4         0         4         4        1.0<br>B        1          3         4         7         6        2.0<br>C        2          5         7         12         10        2.0<br>E        4          4         12         16         12        3.0<br>D        3          2         16         18         15        7.5<br>平均周转时间是：9.4<br>平均带权周转时间是：3.1<br>HRN  </p>
<h1 id="六、心得体会"><a href="#六、心得体会" class="headerlink" title="六、心得体会"></a>六、心得体会</h1><p>&ensp;&ensp;&ensp;&ensp;以上文字和代码仅供参考，请勿直接复制用于完成作业。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>实验课作业</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记——第七章</title>
    <url>/2021/06/20/os-7/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>个人操作系统笔记整理，欢迎参考，时不时更新。  </p>
<span id="more"></span> 

<h1 id="第七章-文件管理"><a href="#第七章-文件管理" class="headerlink" title="第七章 文件管理"></a>第七章 文件管理</h1><h2 id="7-1-文件和文件系统"><a href="#7-1-文件和文件系统" class="headerlink" title="7.1 文件和文件系统"></a>7.1 文件和文件系统</h2><p>&ensp;&ensp;&ensp;&ensp;文件系统的管理功能是将其管理的程序和数据通过组织为一系列文件的方式实现的。<br>&ensp;&ensp;&ensp;&ensp;文件：具有文件名的若干相关元素的集合。<br>&ensp;&ensp;&ensp;&ensp;元素通常是记录，而记录又是一组有意义的数据项的集合。<br>&ensp;&ensp;&ensp;&ensp;数据项 -&gt; 记录 -&gt; 文件    </p>
<h3 id="7-1-1-数据项、记录和文件"><a href="#7-1-1-数据项、记录和文件" class="headerlink" title="7.1.1 数据项、记录和文件"></a>7.1.1 数据项、记录和文件</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.数据项</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）基本数据项：描述一个对象的某种属性的字符集，是可以命名的最小逻辑数据单位，又称为数据元素或字段。<br>&ensp;&ensp;&ensp;&ensp;2）组合数据项。由若干个基本数据项组成的，简称组项。例如，工资是个组项，它可由基本工资、工龄工资和奖励工资等基本项所组成。<br>&ensp;&ensp;&ensp;&ensp;3）基本数据项的类型和数据<br>&ensp;&ensp;&ensp;&ensp;例如：在描述学生的学号时，应使用整数； 描述学生的姓名则应使用字符串(含汉字)；描述性别时，可用逻辑变量或汉字。<br>&ensp;&ensp;&ensp;&ensp;可见，由数据项的名字和类型两者共同定义了一个数据项的“型”。 而表征一个实体在数据项上的数据则称为“值”。<br>&ensp;&ensp;&ensp;&ensp;例如：学号/30211、姓名/王有年、性别/男等。   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.记录</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;一组相关数据项的集合，用于描述一个<strong>对象</strong>在某方面的属性。一个记录应包含哪些数据项，取决于需要描述对象的哪个方面。<br>&ensp;&ensp;&ensp;&ensp;关键字：能唯一的标识出记录的基本/组合数据项。   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.文件</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;文件是指由创建者所定义的、具有文件名的一组相关元素的集合，可分为有结构文件(记录式文件)和无结构文件(流式文件)两种。在有结构的文件中，文件由若干个相关记录组成；而无结构文件则被看成是一个字符流。<br>&ensp;&ensp;&ensp;&ensp;文件在文件系统中是一个最大的数据单位，它描述了一个对象集。<br>&ensp;&ensp;&ensp;&ensp;例如：可以将一个班的学生记录作为一个文件。一个文件必须要有一个文件名， 它通常是由一串ASCII码或(和)汉字构成，名字的长度因系统不同而异<br>&ensp;&ensp;&ensp;&ensp;文件属性：<br>&ensp;&ensp;&ensp;&ensp;1）文件类型。可以从不同的角度来规定文件的类型，如源文件、目标文件和可执行文件等。<br>&ensp;&ensp;&ensp;&ensp;2）文件长度。指文件的当前长度，单位可以是字节，字或数据块。<br>&ensp;&ensp;&ensp;&ensp;3）文件的物理位置。指示文件所在的设备以及所在设备中地址的指针。<br>&ensp;&ensp;&ensp;&ensp;4）文件的建立时间。指最后一次的修改时间。<br><img src="/2021/06/20/os-7/%E5%9B%BE%E7%89%871.png">  </p>
<h3 id="7-1-2-文件名和类型"><a href="#7-1-2-文件名和类型" class="headerlink" title="7.1.2 文件名和类型"></a>7.1.2 文件名和类型</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.文件名和扩展名</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;文件名：不同的系统，对文件名的规定不同<br>&ensp;&ensp;&ensp;&ensp;MS-DOS、WINDOWS95不区分大小写<br>&ensp;&ensp;&ensp;&ensp;Unix、linux系统区分大小写<br>&ensp;&ensp;&ensp;&ensp;扩展名：添加在文件名后面的若干附加字符，又称为后缀名，用于指示文件的类型，方便系统和用户了解文件的类型。扩展名的长度一般为1～4个字符。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.文件类型</strong>   </p>
<p><img src="/2021/06/20/os-7/%E5%9B%BE%E7%89%872.png"><br><img src="/2021/06/20/os-7/%E5%9B%BE%E7%89%873.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.文件系统的功能</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;文件系统的功能<br>&ensp;&ensp;&ensp;&ensp;(1)统一管理文件的存储空间，实施存储空间的分配与回收<br>&ensp;&ensp;&ensp;&ensp;(2)实现文件的按名存取<br>   &ensp;&ensp;&ensp;&ensp;名字空间映射到存储空间<br>&ensp;&ensp;&ensp;&ensp;(3)实现文件信息的共享，并提供文件的保护和保密措施<br>&ensp;&ensp;&ensp;&ensp;(4)向用户提供一个方便使用的接口（命令接口、程序接口）（提供对文件系统操作命令，以及提供对文件的操作命令：信息存取、加工等）<br>&ensp;&ensp;&ensp;&ensp;(5)系统维护及向用户提供有关信息<br>&ensp;&ensp;&ensp;&ensp;(6)文件系统的执行效率<br>&ensp;&ensp;&ensp;&ensp;文件系统在操作系统接口中占的比例最大,用户使用操作系统的感觉在很大程度上取决于对文件系统的使用效果。<br>&ensp;&ensp;&ensp;&ensp;(7)提供与I/O的统一接口  </p>
<h3 id="7-1-3-文件系统的层次结构"><a href="#7-1-3-文件系统的层次结构" class="headerlink" title="7.1.3 文件系统的层次结构"></a>7.1.3 文件系统的层次结构</h3><p>&ensp;&ensp;&ensp;&ensp;三个层：文件(对象及属性)-&gt;文件操作-&gt;文件访问接口<br><img src="/2021/06/20/os-7/%E5%9B%BE%E7%89%874.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.对象及其属性</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;文件管理系统管理的对象有：<br>&ensp;&ensp;&ensp;&ensp;① 文件：文件管理的直接对象。<br>&ensp;&ensp;&ensp;&ensp;② 目录：为了方便用户对文件的存取和检索，在文件系统中必须配置目录。对目录的组织和管理是方便用户和提高对文件存取速度的关键。<br>&ensp;&ensp;&ensp;&ensp;③ 磁盘(磁带)存储空间：文件和目录必定占用存储空间对这部分空间的有效管理，不仅能提高外存的利用率，而且能提高对文件的存取速度。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.对对象操纵和管理的软件集合</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>这是文件管理系统的核心部分</strong>。文件系统的功能大多是在这一层实现的，其中包括：对文件存储空间的管理、对文件目录的管理、用于将文件的逻辑地址转换为物理地址的机制、对文件<strong>读和写</strong>的管理，以及对文件的共享与保护等功能。    </p>
<p>&ensp;&ensp;&ensp;&ensp;一般的，把与文件系统有关的软件分为四个层次：<br>&ensp;&ensp;&ensp;&ensp;1）I/O 控制层，是文件系统的最底层，主要由磁盘驱动程序等组成，也可称为设备驱动程序层。<br>&ensp;&ensp;&ensp;&ensp;2）基本文件系统层，主要用于处理内存和磁盘之间数据块的交换。<br>&ensp;&ensp;&ensp;&ensp;3）基本I/O管理程序，用于完成与磁盘I/O有关的事务。<br>&ensp;&ensp;&ensp;&ensp;4）逻辑文件系统，用于处理与记录和文件相关的操作。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.文件系统接口</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;为方便用户使用文件系统，文件系统通常向用户提供两种类型的接口：<br>&ensp;&ensp;&ensp;&ensp;(1) 命令接口。这是指作为用户与文件系统交互的接口。 用户可通过键盘终端键入命令，取得文件系统的服务。<br>&ensp;&ensp;&ensp;&ensp;(2) 程序接口。这是指作为用户程序与文件系统的接口。 用户程序可通过系统调用来取得文件系统的服务。   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.文件系统的优点</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）使用方便：用户按名存取文件，不需要考虑具体的物理地址。<br>&ensp;&ensp;&ensp;&ensp;（2）安全性：文件系统对文件提供各种保护措施。<br>&ensp;&ensp;&ensp;&ensp;（3）统一性：用户可以用统一的方式存取在不同存储媒体上的文件。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>5.文件系统必须解决的几个问题</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）如何有效的分配文件存储器的存储空间<br>&ensp;&ensp;&ensp;&ensp;（2）提供合适的存取方法<br>&ensp;&ensp;&ensp;&ensp;（3）命名的冲突和文件的共享  </p>
<h3 id="7-1-4-文件操作"><a href="#7-1-4-文件操作" class="headerlink" title="7.1.4 文件操作"></a>7.1.4 文件操作</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.最基本的文件操作</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）创建文件<br>&ensp;&ensp;&ensp;&ensp;在创建一个新文件时，要为新文件分配必要的外存空间，并在文件目录中为之建立一个目录项，目录项中应记录新文件的文件名及其外存地址<br>&ensp;&ensp;&ensp;&ensp;目的：建立系统与文件的联系<br>&ensp;&ensp;&ensp;&ensp;2）删除文件<br>&ensp;&ensp;&ensp;&ensp;删除时，首先从目录中删除目录项，并回收该文件所占的存储空间<br>&ensp;&ensp;&ensp;&ensp;3）读文件<br>&ensp;&ensp;&ensp;&ensp;4）写文件<br>&ensp;&ensp;&ensp;&ensp;5）设置文件的读写位置：通过设置文件读写指针，更改顺序存取为随机存取。    </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.文件的“打开”和“关闭”操作</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;OS对文件的一般操作步骤：1、检索文件目录，找到指定文件的属性及在外存上的位置；2、对文件施加相应的读、写操作。<br>&ensp;&ensp;&ensp;&ensp;打开(Open)：指系统将指定文件的属性从外存拷贝到内存打开文件表的一个表目中，并将表目的编号返回给用户。<br>&ensp;&ensp;&ensp;&ensp;关闭（Close）：将把相应的文件从打开文件表中的表目上删除掉。  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）打开文件<br>&ensp;&ensp;&ensp;&ensp;避免用户在对一个文件实施多次读写操作时，重复执行检索、打开等操作，在OS中引入打开文件(open)系统调用<br>&ensp;&ensp;&ensp;&ensp;将指定文件从外存拷贝到内存打开文件的表的一个表目中，并将该表目的编号返回给用户</p>
<p>&ensp;&ensp;&ensp;&ensp;2）关闭文件<br>&ensp;&ensp;&ensp;&ensp;OS把该文件从打开表中删除该文件对应的表目  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.其他文件操作</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）更改文件属性<br>&ensp;&ensp;&ensp;&ensp;更改文件名、改变文件所有者、改变文件访问权限<br>&ensp;&ensp;&ensp;&ensp;2）有关目录的操作<br>&ensp;&ensp;&ensp;&ensp;创建目录、删除目录、改变当前目录、更改工作目录  </p>
<h2 id="7-2-文件的逻辑结构"><a href="#7-2-文件的逻辑结构" class="headerlink" title="7.2 文件的逻辑结构"></a>7.2 文件的逻辑结构</h2><p><img src="/2021/06/20/os-7/%E5%9B%BE%E7%89%875.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;对于任何一个文件，都存在着以下两种形式的结构<br>&ensp;&ensp;&ensp;&ensp;（1）文件的逻辑结构（文件系统高层设计）<br>&ensp;&ensp;&ensp;&ensp;从用户角度观察到的文件的组织形式，又称为文件组织。<br>&ensp;&ensp;&ensp;&ensp;（2）文件的物理结构（文件系统底层设计）<br>&ensp;&ensp;&ensp;&ensp;又称为文件的存储结构，是指文件在外存上的存储组织形式。   </p>
<h3 id="7-2-1-文件逻辑结构的类型"><a href="#7-2-1-文件逻辑结构的类型" class="headerlink" title="7.2.1 文件逻辑结构的类型"></a>7.2.1 文件逻辑结构的类型</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.系统对文件逻辑结构的基本要求</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）有助于提高对文件检索的速度<br>&ensp;&ensp;&ensp;&ensp;2）方便对文件进行修改，即在便于在文件中增加，删除和修改一个或多个记录<br>&ensp;&ensp;&ensp;&ensp;3）降低文件存放在外存上的存储费用，即尽量减少文件占用的空间，不要求大片的连续存储空间，合理的利用外存，提高外存利用率  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.按文件是否有结构分类</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）有结构文件（记录式文件）<br>&ensp;&ensp;&ensp;&ensp;文件是由若干个记录组成，每个记录有一个键，可按键进行查找。其中的每个记录描述实体集中的一个实体，各记录有着相同或不同数目的数据项。记录的长度可分为：<br>&ensp;&ensp;&ensp;&ensp;定长记录：文件中的所有记录长度都是相同的<br>&ensp;&ensp;&ensp;&ensp;变长记录：文件中各记录的长度不相同<br>&ensp;&ensp;&ensp;&ensp;不论是哪一种，在处理前，每个记录的长度都是可知的。<br>&ensp;&ensp;&ensp;&ensp;2）无结构文件（流式文件）<br>&ensp;&ensp;&ensp;&ensp;大量的源程序、可执行文件、库函数等， 所采用的就是无结构的文件形式，即流式文件。<br>&ensp;&ensp;&ensp;&ensp;其长度以字节为单位。对流式文件的访问，则是采用读写指针来指出下一个要访问的字符。可以把流式文件看作是记录式文件的一个特例：即一个记录仅有一个字节。<br>&ensp;&ensp;&ensp;&ensp;在UNIX系统中，所有的文件都被看作是流式文件；即使是有结构文件，也被视为流式文件；系统不对文件进行格式处理。   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.按文件的组织形式分类</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）顺序文件。由一系列记录按某种顺序进行排列，其中的记录可以是定长也可以是变长的<br>&ensp;&ensp;&ensp;&ensp;2) 索引文件。 为变长记录文件建立一张索引表，并为每个记录建立一个表项，以加速对记录的检索速度<br>&ensp;&ensp;&ensp;&ensp;3) 索引顺序文件。 为文件建立一张索引表时，并不是为每个记录建立一个表项，而是为每组记录中的第一个记录设置一个表项。    </p>
<h3 id="7-2-2-顺序文件"><a href="#7-2-2-顺序文件" class="headerlink" title="7.2.2 顺序文件"></a>7.2.2 顺序文件</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.顺序文件的排列方式</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;顺序文件中的记录，可按不同顺序进行排列：<br>&ensp;&ensp;&ensp;&ensp;（1）串结构: 按记录生成的先后顺序连续排列的逻辑结构。每次检索都要从头开始，效率低<br>&ensp;&ensp;&ensp;&ensp;（2）顺序结构: 把文件中的键（关键字）按规定的顺序排列起来。采用折半查找等提高检索效率    </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.顺序文件的优缺点</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;优点：<br>&ensp;&ensp;&ensp;&ensp;在对文件中的记录进行批量存取时（即每次要读写一大批记录），使用顺序文件的存取效率是最高的对于顺序存储设备（如磁带），只有顺序文件才能被存储并有效工作<br>&ensp;&ensp;&ensp;&ensp;缺点：<br>&ensp;&ensp;&ensp;&ensp;查找或修改单个记录时，顺序文件性能很差<br>&ensp;&ensp;&ensp;&ensp;增加和删除单个记录都比较困难  </p>
<h3 id="7-2-3-记录寻址"><a href="#7-2-3-记录寻址" class="headerlink" title="7.2.3 记录寻址"></a>7.2.3 记录寻址</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.隐式寻址方式</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;对于定长顺序文件，如果已知当前记录的逻辑地址，很容易能确定下一个记录的逻辑地址。<br>&ensp;&ensp;&ensp;&ensp;读一个文件的时候,设置一个读指针Rptr，令其指向下一个记录的首地址，读完一个记录执行一次后移Rptr=Rptr+L;<br>&ensp;&ensp;&ensp;&ensp;写文件操作同上，只是需要设置一个写指针Wptr，令其指向所写记录的首地址，写完一个记录执行一次Wptr=Wptr+L。<br><img src="/2021/06/20/os-7/%E5%9B%BE%E7%89%876.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;对于变长顺序文件，与顺序读或写时的情况相似，只是每次从记录中读出该记录的长度。同样需要设置读写指针，但在每次读或写完一个记录后，须将读或写指针加上Li, 它是刚读或刚写完记录的长度。<br>&ensp;&ensp;&ensp;&ensp;问题：访问一个指定记录i, 必须扫描或读取前面第0~i-1个记录，访问速度是比较慢的。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.显式寻址方式</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）通过文件中记录的位置<br>&ensp;&ensp;&ensp;&ensp;该方式用于对定长顺序文件实现直接或随机访问。<br>&ensp;&ensp;&ensp;&ensp;对于定长记录文件，如果要查找第i个记录，可直接根据下式计算来获得第i个记录相对于第一个记录首址的地址：<br>&ensp;&ensp;&ensp;&ensp;Ai=i×L<br>&ensp;&ensp;&ensp;&ensp;对于可变长度记录的文件，要查找其第i个记录时，须首先计算出该记录的首地址。为此，须顺序地查找每个记录，从中获得相应记录的长度Li，然后才能按下式计算出第i个记录的首址。假定在每个记录前用一个字节指明该记录的长度，则<br> <img src="/2021/06/20/os-7/%E5%9B%BE%E7%89%877.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;2）利用关键字<br>&ensp;&ensp;&ensp;&ensp;此时用户需要指定一个字段作为关键字，通过指定的关键字来查找该记录。当用户给出要查找记录的关键字时，系统将利用该关键字顺序的从第一个记录开始，与每一个记录的关键字进行比较，直到找到匹配的记录。  </p>
<h3 id="7-2-4-索引文件"><a href="#7-2-4-索引文件" class="headerlink" title="7.2.4 索引文件"></a>7.2.4 索引文件</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.按关键字建立索引</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;由变长记录组成的顺序文件不容易直接存取，因此，为其建立一有序的索引表。<br>&ensp;&ensp;&ensp;&ensp;索引文件：为文件中所有记录建立一张索引表，每个记录对应一索引表项，用于记录该记录的长度及指向该记录的指针（指向该记录在逻辑地址空间的首址）<br> <img src="/2021/06/20/os-7/%E5%9B%BE%E7%89%878.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;优点：实现了随机访问、能够随意修改、增加、删除<br>&ensp;&ensp;&ensp;&ensp;缺点：需要存储空间来存储索引表  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.具有多个索引表的索引文件</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;索引文件与顺序文件一样，都只能按关键字进行检索。<br>&ensp;&ensp;&ensp;&ensp;实际中：不同的用户，为了不同的目的，希望能按不同的属性（关键字）来检索一条记录。为此，需要为顺序文件建立多个索引表。<br>&ensp;&ensp;&ensp;&ensp;每个索引表中，按相应的一种属性或关键字进行排序。<br>&ensp;&ensp;&ensp;&ensp;优点：将需要顺序查找的文件改造成一个可随机查找的文件，提高文件的查找速度。同时利用索引文件进行记录的插入和删除也非常方便。  </p>
<h3 id="7-2-5-索引顺序文件"><a href="#7-2-5-索引顺序文件" class="headerlink" title="7.2.5 索引顺序文件"></a>7.2.5 索引顺序文件</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.索引顺序文件的特征</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）引入了文件索引表，通过该表可以实现对索引顺序文件的随机访问。<br>&ensp;&ensp;&ensp;&ensp;2）增加了溢出文件，用它来记录新增加的，删除的和修改的记录。<br>&ensp;&ensp;&ensp;&ensp;可见，索引顺序文件是顺序文件和索引文件的结合，能有效克服变长记录文件的缺点，而且所付出的代价也不算太大。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.一级索引顺序文件</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;建立方法：首先将变长记录顺序文件中的所有记录分成若干组。然后为顺序文件建立一张索引表，并为每组中的第一个记录在索引表中建立一个索引项，其中含有该记录的关键字和指向该记录的指针。<br>&ensp;&ensp;&ensp;&ensp;检索过程：利用用户程序提供的关键字以及某种查找算法去检索索引表，找到该记录所在记录组中第一个记录的表项，从中得到该记录组第一个记录在主文件中的位置，再顺序查找主文件，从中找到所要求的记录。<br> <img src="/2021/06/20/os-7/%E5%9B%BE%E7%89%879.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;查找效率：如果一个顺序文件包含的记录数为N，则为检索到具有指定关键字的记录，平均须要查找N/2次。但对于索引顺序文件，平均只要查找N1/2.<br>&ensp;&ensp;&ensp;&ensp;示例：10000个记录<br>&ensp;&ensp;&ensp;&ensp;顺序文件：平均需要查5000个记录才能查找到。<br>&ensp;&ensp;&ensp;&ensp;索引顺序文件：设100个记录一组，索引表的找法设为顺序法的情况下，则查找次数为50+50=100。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.两级索引顺序文件</strong>     </p>
<p>&ensp;&ensp;&ensp;&ensp;对于一个非常大的文件，为找到一个记录而须查找的记录数目仍然很多，为了进一步提高检索效率，可以为顺序文件建立多级索引，即为索引文件再建立一张索引表，从而形成两级索引表。<br>&ensp;&ensp;&ensp;&ensp;示例：106个记录。先建立一张低级索引表，每100个记录一组，低级索引表含有104个表项。然后为低级索引表建立一张高级索引表，同样是100个索引表项一组，故有102个表项。则查找次数为50+50+50=150。  </p>
<h3 id="7-2-6-直接文件和哈希文件"><a href="#7-2-6-直接文件和哈希文件" class="headerlink" title="7.2.6 直接文件和哈希文件"></a>7.2.6 直接文件和哈希文件</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.直接文件</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;对于直接文件，则可根据给定的记录键值，直接获得指定记录的物理地址。<br>&ensp;&ensp;&ensp;&ensp;换言之，记录键值本身就决定了记录的物理地址。<br>&ensp;&ensp;&ensp;&ensp;这种由记录键值到记录物理地址的转换被称为键值转换(Key to address transformation)。组织直接文件的关键， 在于用什么方法进行从记录值到物理地址的转换。   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.哈希文件</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;目前最为广泛的一种直接文件，它利用Hash函数将记录键值转换为相应记录的地址。<br> <img src="/2021/06/20/os-7/%E5%9B%BE%E7%89%8710.png">   </p>
<h2 id="7-3-文件目录"><a href="#7-3-文件目录" class="headerlink" title="7.3 文件目录"></a>7.3 文件目录</h2><p>&ensp;&ensp;&ensp;&ensp;系统通过文件目录对文件实现管理，文件目录也是一种数据结构，用户表示系统中的文件及其物理地址，供检索时使用，对目录管理的要求如下：<br>&ensp;&ensp;&ensp;&ensp;1）实现“按名存取”。用户只需要向系统提供所访问文件的名字，便能快速准确的找到指定文件在外存的位置。<br>&ensp;&ensp;&ensp;&ensp;2）提高对目录的检索速度。通过合理组织目录结构加快对目录的检索速度，进而提高对文件的存取速度。<br>&ensp;&ensp;&ensp;&ensp;3）文件共享。应允许多个用户共享一个文件。<br>&ensp;&ensp;&ensp;&ensp;4）允许文件重名。应允许对不同文件采用相同的名字。  </p>
<h3 id="7-3-1-文件控制块和索引节点"><a href="#7-3-1-文件控制块和索引节点" class="headerlink" title="7.3.1 文件控制块和索引节点"></a>7.3.1 文件控制块和索引节点</h3><p>&ensp;&ensp;&ensp;&ensp;1）文件控制块:描述和控制文件的数据结构。<br>&ensp;&ensp;&ensp;&ensp;（1）文件管理程序借助文件控制块的信息对文件操作<br>&ensp;&ensp;&ensp;&ensp;（2）文件与文件控制块一一对应<br>&ensp;&ensp;&ensp;&ensp;2）文件目录:文件控制块的有序集合；一个文件控制块就是一个文件目录项<br>&ensp;&ensp;&ensp;&ensp;3）目录文件:一个文件目录也被看做一个文件，称为目录文件  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.文件控制块FCB</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;文件控制块含有以下三类信息：<br>&ensp;&ensp;&ensp;&ensp; 1）基本信息类<br>&ensp;&ensp;&ensp;&ensp;①文件名：文件的唯一名字，实现“按名存取”<br>&ensp;&ensp;&ensp;&ensp;②文件物理位置：文件在外存上的存储位置，设备名、起始盘块号、盘块数、文件长度<br>&ensp;&ensp;&ensp;&ensp;③文件逻辑结构：流式文件或记录式文件<br>&ensp;&ensp;&ensp;&ensp;④文件物理结构：文件是顺序文件、链式文件、还是索引文件<br>&ensp;&ensp;&ensp;&ensp;2）存储控制信息类<br>&ensp;&ensp;&ensp;&ensp;①文件主的存取权限<br>&ensp;&ensp;&ensp;&ensp;②核准用户的存取权限<br>&ensp;&ensp;&ensp;&ensp;③一般用户的存取<br>&ensp;&ensp;&ensp;&ensp;3）使用信息类<br>&ensp;&ensp;&ensp;&ensp;①文件的建立日期和时间<br>&ensp;&ensp;&ensp;&ensp;②文件上一次修改的日期和时间<br>&ensp;&ensp;&ensp;&ensp;③当前使用信息<br> <img src="/2021/06/20/os-7/%E5%9B%BE%E7%89%8711.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.索引节点</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）索引结点的引入<br>&ensp;&ensp;&ensp;&ensp;FCB中含:文件名、描述信息，它们较占空间。<br>&ensp;&ensp;&ensp;&ensp;例：一个FCB为64B，一个盘块为1KB，则每个盘块只能放16个FCB。若一个文件目录中共有640个FCB，则需要40个盘块。故平均查找一个文件须启动磁盘20次。<br>&ensp;&ensp;&ensp;&ensp;解决方法：将FCB分为文件名和描述性信息结点，即i结点、目录项中内容为文件名和i结点指针，查询时只调入文件名部分，找到后才调入相应结点。<br>&ensp;&ensp;&ensp;&ensp;2)磁盘索引结点<br>&ensp;&ensp;&ensp;&ensp;存放在磁盘上的索引结点，每个文件有唯一的一个磁盘索引结点，主要内容：<br>&ensp;&ensp;&ensp;&ensp;文件主标志符、文件类型、文件存取权限、文件物理地址、文件长度、文件连接计数、文件存取时间<br>&ensp;&ensp;&ensp;&ensp;3)内存索引结点<br>&ensp;&ensp;&ensp;&ensp;存放在内存上的索引结点，当文件被打开时，将磁盘索引结点拷贝到内存索引结点<br>&ensp;&ensp;&ensp;&ensp;索引结点编号、状态、访问计数、文件逻辑设备号、链接指针</p>
<h3 id="7-3-2-简单的文件目录"><a href="#7-3-2-简单的文件目录" class="headerlink" title="7.3.2 简单的文件目录"></a>7.3.2 简单的文件目录</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.单级文件目录</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;整个文件系统只建立一张目录表，每个文件占一个目录项<br>&ensp;&ensp;&ensp;&ensp;目录项包括文件名、扩展名、文件长度、文件类型、物理地址、其他文件属性<br>&ensp;&ensp;&ensp;&ensp;优点：简单，实现“按名存取”<br>&ensp;&ensp;&ensp;&ensp;缺点：<br>&ensp;&ensp;&ensp;&ensp;(1) 查找速度慢<br>&ensp;&ensp;&ensp;&ensp;(2) 不允许重命名<br>&ensp;&ensp;&ensp;&ensp;(3) 不便于实现文件共享：每个用户使用不同的名字访问同一文件。<br><img src="/2021/06/20/os-7/%E5%9B%BE%E7%89%8712.png">      </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.两级文件目录</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;为每个用户建立一个单独的用户文件目录UFD，系统中建立一个主文件目录MFD，在主文件目录中，每个用户文件目录占一个目录项<br>&ensp;&ensp;&ensp;&ensp;优点：解决了文件的重名问题和文件共享问题<br>&ensp;&ensp;&ensp;&ensp;用户名|文件名<br>&ensp;&ensp;&ensp;&ensp;提高检索速度<br>&ensp;&ensp;&ensp;&ensp;缺点：增加了系统开销<br><img src="/2021/06/20/os-7/%E5%9B%BE%E7%89%8713.png">       </p>
<p>&ensp;&ensp;&ensp;&ensp;两级文件目录已经基本上能够满足对文件目录的四方面要求，具体说明：<br>&ensp;&ensp;&ensp;&ensp;1）提高了检索的速度。如果主目录中有n个子目录，每个用户目录最多用m个目录项，最多只需检索n+m个目录项。<br>&ensp;&ensp;&ensp;&ensp;2）在不同的用户目录中，可以使用相同的文件名。<br>&ensp;&ensp;&ensp;&ensp;3）不同用户还可以使用不同的文件名访问系统中的同一个共享文件。  </p>
<h3 id="7-3-3-树形目录结构"><a href="#7-3-3-树形目录结构" class="headerlink" title="7.3.3 树形目录结构"></a>7.3.3 树形目录结构</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.树形目录</strong>  </p>
<p><img src="/2021/06/20/os-7/%E5%9B%BE%E7%89%8714.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;优点：<br>&ensp;&ensp;&ensp;&ensp;层次结构清晰，便于管理和保护；有利于文件分类；解决重名问题；提高文件检索速度；能进行存取权限的控制<br>&ensp;&ensp;&ensp;&ensp;缺点：<br>&ensp;&ensp;&ensp;&ensp;查找一个文件按路径名逐层检查，由于每个文件都放在外存，多次访盘影响速度  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.路径名和当前目录</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）路径名<br>&ensp;&ensp;&ensp;&ensp;在树形目录结构中， 从根目录到任何数据文件， 都只有一条惟一的通路。 在该路径上从树的根(即主目录)开始， 把全部目录文件名与数据文件名，依次地用“/”连接起来，即构成该数据文件的路径名(path name)。 系统中的每一个文件都有惟一的路径名。<br>&ensp;&ensp;&ensp;&ensp;2）当前目录<br>&ensp;&ensp;&ensp;&ensp;当一个文件系统含有许多级时，每访问一个文件，都要使用从树根开始直到树叶(数据文件)为止的、包括各中间结点(目录)名的全路径名。 这是相当麻烦的事，同时由于一个进程运行时所访问的文件，大多仅局限于某个范围，因而非常不便。 基于这一点，可为每个进程设置一个“当前目录”，又称为“工作目录”。<br>&ensp;&ensp;&ensp;&ensp;从当前目录开始直到数据文件为止所构成的路径名，称为相对路径名(relative path name)；而把从树根开始的路径名称为绝对路径名(absolute path name)。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.目录操作</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）创建目录<br>&ensp;&ensp;&ensp;&ensp;在树形目录结构中，用户可以自己创建UFD，并可继续创建子目录。当用户创建一个新文件时，只需查看自己的UFD及其子目录中有无与新文件相同的文件名，若无，便可在UFD或其某个子目录中增加一个新的目录项。<br>&ensp;&ensp;&ensp;&ensp;2）删除目录<br>&ensp;&ensp;&ensp;&ensp;视情况而定，当该目录不再有任何文件时，直接删除。否则，可采用以下两种方法处理：<br>&ensp;&ensp;&ensp;&ensp;不删除非空目录。当目录(文件)不空时， 不能将其删除，而为了删除一个非空目录，必须先删除目录中的所有文件，使之先成为空目录， 后再予以删除。如果目录中还包含有子目录，还必须采取递归调用方式来将其删除， 在MS-DOS中就是采用这种删除方式。<br>&ensp;&ensp;&ensp;&ensp;可删除非空目录。当要删除一目录时，如果在该目录中还包含有文件，则目录中的所有文件和子目录也同时被删除。<br>&ensp;&ensp;&ensp;&ensp;3）改变目录<br>&ensp;&ensp;&ensp;&ensp;用户可以利用改变目录的命令，通过指定目录的绝对或相对路径名设置当前目录。<br>&ensp;&ensp;&ensp;&ensp;4）移动目录<br>&ensp;&ensp;&ensp;&ensp;到了一个阶段，通常都需要对目录组织进行调整，即将文件或子目录在不同的父目录之间移动。移动后，路径名也随之改变。<br>&ensp;&ensp;&ensp;&ensp;5）链接操作<br>&ensp;&ensp;&ensp;&ensp;对于树形结构目录，每个文件和每个目录只允许一个父目录，这不利于文件共享，可以利用链接操作让指定文件具有多个父目录，从而方便共享。<br>&ensp;&ensp;&ensp;&ensp;6）查找<br>&ensp;&ensp;&ensp;&ensp;文件目录比较庞大时，要查找指定文件是有点困难的。所有OS中都支持以多种方式进行查找。   </p>
<h3 id="7-3-4-目录查询技术"><a href="#7-3-4-目录查询技术" class="headerlink" title="7.3.4 目录查询技术"></a>7.3.4 目录查询技术</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.线性检索法</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;称为顺序检索法。在单级目录中，利用用户提供的文件名，用顺序查找法直接从文件目录中找到指定文件的目录项。在树形目录中，需要对多级目录进行查找。<br>&ensp;&ensp;&ensp;&ensp;假定查找的文件路径名是/usr/ast/mbox,则查找过程如下：<br><img src="/2021/06/20/os-7/%E5%9B%BE%E7%89%8715.png">     </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.hash方法</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;建立一张hash索引文件目录，可以利用hash方法进行查询，系统利用用户提供的文件名并将他变换为文件目录的索引值。<br>&ensp;&ensp;&ensp;&ensp;利用该索引值到目录中去查找，将显著提高索引速度。<br>&ensp;&ensp;&ensp;&ensp;注意:如果使用了通配符，则不能够进行hash方式查找。<br>&ensp;&ensp;&ensp;&ensp;hash处理方法会出现多个不同文件名转换为相同的hash值的情况。<br>&ensp;&ensp;&ensp;&ensp;一种处理此“冲突”的有效规则是：<br>&ensp;&ensp;&ensp;&ensp;(1) 在利用Hash法索引查找目录时，如果目录表中相应的目录项是空的，则表示系统中并无指定文件。<br>&ensp;&ensp;&ensp;&ensp;(2) 如果目录项中的文件名与指定文件名相匹配， 则表示该目录项正是所要寻找的文件所对应的目录项，故而可从中找到该文件所在的物理地址。<br>&ensp;&ensp;&ensp;&ensp;(3) 如果在目录表的相应目录项中的文件名与指定文件名并不匹配，则表示发生了“冲突”，此时须将其Hash值再加上一个常数(该常数应与目录的长度值互质)，形成新的索引值， 再返回到第一步重新开始查找。    </p>
<h2 id="7-4-文件共享"><a href="#7-4-文件共享" class="headerlink" title="7.4 文件共享"></a>7.4 文件共享</h2><h3 id="7-4-1-基于有向无环图实现文件共享"><a href="#7-4-1-基于有向无环图实现文件共享" class="headerlink" title="7.4.1 基于有向无环图实现文件共享"></a>7.4.1 基于有向无环图实现文件共享</h3><p>&ensp;&ensp;&ensp;&ensp;定义：一个文件被多个用户或程序共同使用<br>&ensp;&ensp;&ensp;&ensp;目的：<br>&ensp;&ensp;&ensp;&ensp;1）节省存储空间<br>&ensp;&ensp;&ensp;&ensp;2）减少了用户工作量<br>&ensp;&ensp;&ensp;&ensp;3）进程间通过文件交换信息。<br>&ensp;&ensp;&ensp;&ensp;常用的两种文件共享方法：<br>&ensp;&ensp;&ensp;&ensp;1) 基于有向无环图实现文件共享<br>&ensp;&ensp;&ensp;&ensp;2) 利用符号链接实现文件共享  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.有向无环图</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;严格的树目录结构中，每个文件只允许有一个父目录(被一个用户所拥有)，其他用户访问，需通过父目录。<br>&ensp;&ensp;&ensp;&ensp;改进：允许一个文件有多个父目录，方便文件共享<br><img src="/2021/06/20/os-7/%E5%9B%BE%E7%89%8716.png">     </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.利用索引节点</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;思想：<br>&ensp;&ensp;&ensp;&ensp;1)目录项设置文件名及指向相应索引结点的指针。<br>&ensp;&ensp;&ensp;&ensp;2)文件的物理地址及相关属性存放在索引结点中。<br>&ensp;&ensp;&ensp;&ensp;3)任何用户对文件盘块的增加将会引起索引结点的变化不涉及用户目录的变更。<br><img src="/2021/06/20/os-7/%E5%9B%BE%E7%89%8717.png">     </p>
<p><img src="/2021/06/20/os-7/%E5%9B%BE%E7%89%8718.png">   </p>
<h3 id="7-4-2-利用符号链接实现文件共享"><a href="#7-4-2-利用符号链接实现文件共享" class="headerlink" title="7.4.2 利用符号链接实现文件共享"></a>7.4.2 利用符号链接实现文件共享</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.利用符号链接的基本思想</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;思想：<br>&ensp;&ensp;&ensp;&ensp;1)允许一个文件或目录有多个父目录，但其中只有一个作为主父目录。<br>&ensp;&ensp;&ensp;&ensp;2)其他父目录通过符号链接方式与之相链接。<br><img src="/2021/06/20/os-7/%E5%9B%BE%E7%89%8719.png">     </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.如何利用符号链接实现共享</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;如何将F8共享到D5目录中？<br>&ensp;&ensp;&ensp;&ensp;1)系统创建一个LINK类型的文件，命名也为F8<br>&ensp;&ensp;&ensp;&ensp;2)这个LINK F8文件中只包含被链接文件F8的路径名(符号链接)<br>&ensp;&ensp;&ensp;&ensp;3)将这个LINK F8文件写入D5的目录<br>&ensp;&ensp;&ensp;&ensp;4)用户访问D5中F8时，OS截获路径名去找文件F8  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.利用符号链接实现共享的优点</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）只有文件主才拥有指向索引结点的指针，其它共享用户通过路径名访问（可以解决指针悬空的问题）。<br>&ensp;&ensp;&ensp;&ensp;2）当文件主删除共享文件后，其他用户再次访问该文件，发现文件已经删除，系统会将符号链删除。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.利用符号链共享方式存在的问题</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;访问速度慢；链接文件也要建立索引结点而由于链本身实际上是一个文件，尽管该文件很简单，却仍要为它配置一个索引结点，所以要耗费一定的磁盘空间；同一文件有不同的文件名。  </p>
<h2 id="7-5-文件保护（略）"><a href="#7-5-文件保护（略）" class="headerlink" title="7.5 文件保护（略）"></a>7.5 文件保护（略）</h2>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记——第六章</title>
    <url>/2021/06/17/os-6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>个人操作系统笔记整理，欢迎参考，时不时更新。  </p>
<span id="more"></span> 

<h1 id="第六章-输入输出系统"><a href="#第六章-输入输出系统" class="headerlink" title="第六章 输入输出系统"></a>第六章 输入输出系统</h1><h2 id="6-1-I-O系统的功能、模型和接口"><a href="#6-1-I-O系统的功能、模型和接口" class="headerlink" title="6.1 I/O系统的功能、模型和接口"></a>6.1 I/O系统的功能、模型和接口</h2><h3 id="6-1-1-I-O系统的基本功能"><a href="#6-1-1-I-O系统的基本功能" class="headerlink" title="6.1.1 I/O系统的基本功能"></a>6.1.1 I/O系统的基本功能</h3><p>&ensp;&ensp;&ensp;&ensp;I/O系统管理的主要对象：I/O设备和相应的设备控制器    </p>
<p>&ensp;&ensp;&ensp;&ensp;主要的任务<br>&ensp;&ensp;&ensp;&ensp;①完成用户提出的I/O请求<br>&ensp;&ensp;&ensp;&ensp;②提高I/O速率<br>&ensp;&ensp;&ensp;&ensp;③提高设备的利用率<br>&ensp;&ensp;&ensp;&ensp;④为更高层的进程方便地使用这些设备提供手段。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%871.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.隐藏物理设备的细节</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;原因：I/O设备种类繁多，互有差异<br>&ensp;&ensp;&ensp;&ensp;方法：使用设备控制器控制设备，用户仅使用抽象的I/O命令就可以使用设备。<br>&ensp;&ensp;&ensp;&ensp;设备控制器主要职责是控制一个或多个I/O设备，实现I/O与CPU之间的数据交换。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.与设备的无关性（独立性）</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;目的：隐藏物理设备的细节，方便用户使用特定设备<br>&ensp;&ensp;&ensp;&ensp;方法：使用抽象的逻辑设备名来使用设备  /dev/printer<br>&ensp;&ensp;&ensp;&ensp;设备独立性是指操作系统把所有外部设备统一当作成文件来看待，任何用户都可以象使用文件一样，操纵、使用这些设备，而不必知道它们的具体存在形式。OS不必知道具体的使用哪台打印机，也不必知道打印机的型号。方便用户使用，并且有效地提高OS的可移植性和易适应性，OS允许在不需要重新编译的情况下，增添新的设备驱动，方便新的I/O设备的安装，做到即插即用  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.提高处理机和I/O的利用率</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;原因：<br>&ensp;&ensp;&ensp;&ensp;I/O设备之间能够并行<br>&ensp;&ensp;&ensp;&ensp;CPU与I/O设备也能并行<br>&ensp;&ensp;&ensp;&ensp;方法：<br> &ensp;&ensp;&ensp;&ensp;一方面要求CPU能尽快响应用户请求使I/O设备尽快的运行起来<br>&ensp;&ensp;&ensp;&ensp;另一方面，尽量减少在I/O设备运行时，处理机的干预时间。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.对I/O设备进行控制</strong> </p>
<p>&ensp;&ensp;&ensp;&ensp;方式：<br>&ensp;&ensp;&ensp;&ensp;1）轮询的可编程I/O方式<br>&ensp;&ensp;&ensp;&ensp;利用I/O测试指令测试设备的闲忙，极大地浪费CPU<br>&ensp;&ensp;&ensp;&ensp;2）中断的可编程的I/O方式<br>&ensp;&ensp;&ensp;&ensp;当设备完成I/O操作，便以中断请求方式通知CPU，然后进行相应处理，浪费CPU<br>&ensp;&ensp;&ensp;&ensp;3）直接存储器访问方式<br>&ensp;&ensp;&ensp;&ensp;由DMA控制器送出内存地址和发出内存读、设备写或者设备读、内存写的控制信号完成内存与设备之间的直接数据传送，而不用CPU干预<br>&ensp;&ensp;&ensp;&ensp;4）I/O通道方式<br>&ensp;&ensp;&ensp;&ensp;通道是独立于CPU的、专门负责数据的输入输出传输工作的处理器，它对外部设备实统一管理，代替CPU对I/O操作进行控制，从而使I/O操作可以与CPU并行工作。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>5.确保对设备的正确共享</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;设备分类：<br>&ensp;&ensp;&ensp;&ensp;1）独占设备，互斥访问，打印机<br>&ensp;&ensp;&ensp;&ensp;2）共享设备，一段时间内运行多个进程同时访问的设备，磁盘  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>6.错误处理</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;故障分类：<br>&ensp;&ensp;&ensp;&ensp;1）临时性错误<br>&ensp;&ensp;&ensp;&ensp;2）持久性错误<br>&ensp;&ensp;&ensp;&ensp;对于错误的处理尽可能的在接近硬件的层面上解决，让上层用户感知不到错误的存在。       </p>
<h3 id="6-1-2-I-O系统的层次结构和模型"><a href="#6-1-2-I-O系统的层次结构和模型" class="headerlink" title="6.1.2 I/O系统的层次结构和模型"></a>6.1.2 I/O系统的层次结构和模型</h3><p>&ensp;&ensp;&ensp;&ensp;I/O软件下与硬件关系密切，上与文件系统，虚拟存储器系统和用户直接交互。为使复杂的I/O软件具有清晰的结构，更好的可移植性和易用性，目前普遍采用层次式的I/O系统。<br>&ensp;&ensp;&ensp;&ensp;目前I/O系统普遍采用层次结构，它将系统中的设备管理模块，分为若干个层次，每一层都是利用其下层提供的服务，完成输入输出功能中的某些子功能，并屏蔽这些功能实现的细节，向高层提供服务。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.I/O软件的层次结构</strong>  </p>
<p><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%872.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）用户层软件<br>&ensp;&ensp;&ensp;&ensp;实现与用户交互的接口，用户可直接调用在用户层提供的、与I/O操作有关的库函数，对设备进行操作。<br>&ensp;&ensp;&ensp;&ensp;（2）设备独立软件<br>&ensp;&ensp;&ensp;&ensp;用于实现用户程序与设备驱动器的统一接口、设备命名、设备的保护以及设备的分配与释放等，同时为设备管理和数据传送提供必要的存储空间。<br>&ensp;&ensp;&ensp;&ensp;应用程序独立于具体使用的物理设备（逻辑设备名）<br>&ensp;&ensp;&ensp;&ensp;（3）设备驱动程序<br>&ensp;&ensp;&ensp;&ensp;处于次底层，是进程和控制器之间的通信程序<br>&ensp;&ensp;&ensp;&ensp;功能：与硬件直接相关，用于具体实现系统对设备发出的操作指令，驱动I/O设备工作的驱动程序。<br>&ensp;&ensp;&ensp;&ensp;（4）中断处理程序<br>&ensp;&ensp;&ensp;&ensp;处于I/O系统的底层，直接与硬件进行交互<br>&ensp;&ensp;&ensp;&ensp;用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完后再恢复被中断进程的现场后，返回到被中断进程。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.I/O系统中各种模块之间的层次视图</strong>  </p>
<p><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%873.png">    </p>
<h3 id="6-1-3-I-O系统接口"><a href="#6-1-3-I-O系统接口" class="headerlink" title="6.1.3 I/O系统接口"></a>6.1.3 I/O系统接口</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.块设备接口</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）块设备：数据的存取和传输都是以数据块为单位的设备，如磁盘。基本特征是<strong>传输速率较高、可寻址</strong>。磁盘设备的I/O常采用<strong>DMA</strong>方式。<br>&ensp;&ensp;&ensp;&ensp;2）隐藏了磁盘的二维结构：块设备接口隐藏了磁盘地址是二维结构的情况：每个扇区的地址需要用磁道号和扇区号来表示。<br>&ensp;&ensp;&ensp;&ensp;3）将抽象命令映射为低层操作：块设备接口将上层发来的抽象命令，映射为设备能识别的较低层具体操作。  </p>
<p>&ensp;&ensp;&ensp;虚拟存储器系统也要用到块设备接口  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.流（字符）设备接口</strong>   </p>
<p>&ensp;&ensp;&ensp;1）字符设备：数据的存取和传输是以字符为单位的设备。如键盘、打印机等。基本特征是传<strong>输速率较低、不可寻址</strong>，常采用<strong>中断驱动方式</strong>。<br>&ensp;&ensp;&ensp;2）get和put操作：由于字符设备是不可寻址的，因而对它只能采取<strong>顺序存取</strong>方式。（用户程序）获取或输出字符的方法是采用get和put操作，get操作用于从字符缓冲区取得一个字符到内存，而put操作则用于把一个新字符输出到字符缓冲区。<br>&ensp;&ensp;&ensp;3） in-control指令：因字符设备的类型非常多，且差异甚大，系统以统一的方式提供了一种通用的in-control指令来处理它们（包含了许多参数，每个参数表示一个与具体设备相关的特定功能）。</p>
<p>&ensp;&ensp;&ensp;大多数流设备都属于独占设备，必须采用互斥方式实现贡献。   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.网络通信接口</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在现代OS中，都提供了面向网络的功能。<br>&ensp;&ensp;&ensp;&ensp;还需要通过某种方式，把计算机连接到网络上。<br>&ensp;&ensp;&ensp;&ensp;操作系统也必须提供相应的网络软件和网络通信接口，使计算机能通过网络与网络上的其它计算机进行通信，或上网浏览。  </p>
<h2 id="6-2-I-O设备和设备控制器"><a href="#6-2-I-O设备和设备控制器" class="headerlink" title="6.2 I/O设备和设备控制器"></a>6.2 I/O设备和设备控制器</h2><h3 id="6-2-1-I-O设备"><a href="#6-2-1-I-O设备" class="headerlink" title="6.2.1 I/O设备"></a>6.2.1 I/O设备</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.I/O设备类型</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;1）按使用特性分类<br>&ensp;&ensp;&ensp;&ensp;①存储设备：也称外存、辅存。<br>&ensp;&ensp;&ensp;&ensp;②I/O设备：分为输入设备、输出设备和交互式设备。<br>&ensp;&ensp;&ensp;&ensp;2）按传输速率分类<br>&ensp;&ensp;&ensp;&ensp;①低速设备：其传输速率仅为每秒钟几个字节至数百个字节的一类设备，如键盘、鼠标器。<br>&ensp;&ensp;&ensp;&ensp;②中速设备：传输速率在每秒钟数千个字节至数十万个字节的一类设备，如行式打印机、激光打印机等。<br>&ensp;&ensp;&ensp;&ensp;③高速设备：传输速率在数十万字节至千兆字节的一类设备，如磁带机、磁盘机、光盘机等  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.设备与控制器之间的接口</strong>  </p>
<p>通常，设备并不直接与CPU进行通信，而是与设备控制器进行通信，因此，在I/O设备中应还有与设备控制器之间的接口。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%874.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;1）数据信号线：<br>&ensp;&ensp;&ensp;&ensp;用于在设备和设备控制器之间传送数据信号。<br>&ensp;&ensp;&ensp;&ensp;2）控制信号线：<br>&ensp;&ensp;&ensp;&ensp;①设备控制器向I/O设备发送控制信号时的通路。<br>&ensp;&ensp;&ensp;&ensp;②规定了设备将要执行的操作，比如：读、写、执行磁头移动等。<br>&ensp;&ensp;&ensp;&ensp;3）状态信号线：<br>&ensp;&ensp;&ensp;&ensp;①用于传送指示设备当前状态的信号。<br>&ensp;&ensp;&ensp;&ensp;②设备当前状态有：正在读（或写），设备已读（或写）完成，并准备好新的数据传送。  </p>
<h3 id="6-2-2-设备控制器"><a href="#6-2-2-设备控制器" class="headerlink" title="6.2.2 设备控制器"></a>6.2.2 设备控制器</h3><p>&ensp;&ensp;&ensp;&ensp;设备控制器的主要功能是，控制一个或多个I/O设备,以实现I/O设备和计算机之间的数据交换.它是CPU与I/O设备之间的接口,它接收从CPU发来的命令,并去控制I/O设备工作,以使处理机从繁忙的设备控制事务中解脱出来。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.设备控制器的基本功能</strong> </p>
<p>&ensp;&ensp;&ensp;&ensp;(1) 接收和识别命令<br>&ensp;&ensp;&ensp;&ensp;设备控制器能接收并识别处理机发来的多种命令，并对所接收的命令进行译码。<br>&ensp;&ensp;&ensp;&ensp;例如：磁盘控制器可以接收CPU发来的read、write、format等15条命令，相应地磁盘控制器中有多个寄存器和命令译码器。<br>&ensp;&ensp;&ensp;&ensp;(2) 数据交换<br>&ensp;&ensp;&ensp;&ensp;实现CPU与控制器之间、控制器与设备之间的数据交换。前者通过数据总线，由CPU并行地把数据写入控制器，或从控制器中并行地读出数据，后者则是设备将数据输入到控制器中，或从控制器传送给设备。为此，在控制器中必须设置数据寄存器。<br>&ensp;&ensp;&ensp;&ensp;(3) 标识和报告<br>&ensp;&ensp;&ensp;&ensp;设备的状态控制器应记下设备的状态供CPU了解。<br>&ensp;&ensp;&ensp;&ensp;例如：仅当该设备处于发送就绪状态时，CPU才能启动控制器从设备中读出数据，为此，要在设备控制器中设置一个状态寄存器<br>&ensp;&ensp;&ensp;&ensp;(4) 地址识别<br>&ensp;&ensp;&ensp;&ensp;能够识别其所控制的每个设备的地址。系统中的每一个设备都有一个地址，控制器能识别他所控制的每一个设备的地址设备控制器其中配置地址译码器<br>&ensp;&ensp;&ensp;&ensp;(5) 数据缓冲区<br>&ensp;&ensp;&ensp;&ensp;缓和CPU、内存与I/O设备的速度差异的矛盾故在控制器中必须设置一缓冲区。<br> &ensp;&ensp;&ensp;&ensp;(6) 差错控制<br>&ensp;&ensp;&ensp;&ensp;兼管对由I/O设备传送来的数据，进行差错检测，保证数据输入的正确性。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.设备控制器的组成</strong><br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%875.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;设备控制器由以下三部分组成：</p>
<p>&ensp;&ensp;&ensp;&ensp;1) 设备控制器与处理机的接口<br>&ensp;&ensp;&ensp;&ensp;用于实现CPU与设备控制器之间的通信，接口中共有三类信号线：数据线、地址线和控制线。数据线通常与数据、控制/状态两类寄存器相连接<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%876.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;2) 设备控制器与设备的接口<br>&ensp;&ensp;&ensp;&ensp;控制器中有一个或多个设备接口。在每个接口中都存在数据、控制和状态三种类型的信号。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%877.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;3) I/O逻辑：<br>&ensp;&ensp;&ensp;&ensp;I/O逻辑用于实现对设备的控制，接收CPU命令和地址译码。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%878.png">    </p>
<h3 id="6-2-3-内存映像I-O"><a href="#6-2-3-内存映像I-O" class="headerlink" title="6.2.3 内存映像I/O"></a>6.2.3 内存映像I/O</h3><p>&ensp;&ensp;&ensp;&ensp;驱动程序将抽象I/O命令，转换出的一系列具体的命令、参数等数据，装入设备控制器的相应寄存器，由控制器来执行这些命令，具体实施对I/O设备的控制。<br>&ensp;&ensp;&ensp;&ensp;两种方法：利用特定的I/O指令和内存映像I/O  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.利用特定的I/O指令</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;访问内存和访问设备需要两种不同的指令，也是该方法的主要缺点。<br>&ensp;&ensp;&ensp;&ensp;例如，为了将CPU寄存器中的内容，复制到控制器寄存器中：<br> &ensp;&ensp;&ensp;&ensp;io-store  cpu-reg, dev-no, dev-reg<br>&ensp;&ensp;&ensp;&ensp;如果是将CPU寄存器中的内容，存入内存的某个单元（k）中：<br>&ensp;&ensp;&ensp;&ensp;Store  cpu-reg, k<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%879.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.内存映像I/O</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;该方式统一了对内存和对控制器的访问的方法，简化了I/O的编程。<br>&ensp;&ensp;&ensp;&ensp;在编址上不再区分内存单元地址和设备控制器中的寄存器地址，都采用k。当k值处于0—n-1范围时，被认为是内存地址，若k大于等于n时，被认为是某个控制器的寄存器地址。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8710.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;由图所示，当k=n时，是表示设备控制器0的第1个寄存器opcode的地址。因此，如果要想将CPU寄存器中内容，传送到控制器0的第1个寄存器opcode，只需要用下面的一般的存储指令。<br>&ensp;&ensp;&ensp;&ensp;Store  cpu-reg, n  </p>
<h3 id="6-2-4-I-O通道"><a href="#6-2-4-I-O通道" class="headerlink" title="6.2.4 I/O通道"></a>6.2.4 I/O通道</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.I/O通道的引入</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;引入目的：解脱CPU对I/O的组织、管理。<br>&ensp;&ensp;&ensp;&ensp;CPU只需发送I/O命令给通道，通道通过调用内存中的相应通道程序完成任务。<br>&ensp;&ensp;&ensp;&ensp;通道：一种特殊的执行I/O指令的处理机，但指令类型单一，硬件较简单，与CPU共享内存，可以有自己的总线。<br>&ensp;&ensp;&ensp;&ensp;四级连接方式：主机-通道-设备控制器-I/O设备  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.通道类型</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;根据信息交换方式，分成三类：<br>&ensp;&ensp;&ensp;&ensp;（1）字节多路通道<br>&ensp;&ensp;&ensp;&ensp;按字节交叉方式工作，含有多个非分配型子通道，每个子通道连接一台I/O设备，子通道采用<strong>时间片轮转</strong>的方式共享主通道。<strong>不适于高速设备</strong>。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8711.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）数组选择通道<br>&ensp;&ensp;&ensp;&ensp;可以连接多台<strong>高速设备</strong>，只含有一个分配型子通道，一段时间内执行一道通道程序。<br>&ensp;&ensp;&ensp;&ensp;当某台设备占用通道后，便一直由它独占，直到该设备传输完毕释放通道。通道利用率低。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（3）数组多路通道<br>&ensp;&ensp;&ensp;&ensp;结合数组选择通道的高速和字节多路通道的分时并行结合起来的一种新通道。<br>&ensp;&ensp;&ensp;&ensp;多子通道不是以时间片的方式，而是按需分配，数据成组传输。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.“瓶颈”问题</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;通道价格昂贵，数量较少，多个I/O设备共享一个通道，造成“瓶颈”。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8712.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;解决“瓶颈”方法：增加设备到主机间的通路而不是增加通道  </p>
<h2 id="6-3-中断机构和中断处理程序"><a href="#6-3-中断机构和中断处理程序" class="headerlink" title="6.3 中断机构和中断处理程序"></a>6.3 中断机构和中断处理程序</h2><p>&ensp;&ensp;&ensp;&ensp;中断在操作系统中有着特殊重要的地位，它是多道程序得以实现的基础，因为<strong>进程之间的切换是通过中断来完成的</strong><br>&ensp;&ensp;&ensp;&ensp;另一方面，中断也是设备管理的基础，为了提高处理机的利用率和实现CPU与I/O设备并行执行，也必须有中断的支持。它是整个I/O系统的基础。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.中断和陷入</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;(1) 中断：CPU对I/O设备发来的中断信号的一种响应，中断是由外部设备引起的，又称外中断。<br>&ensp;&ensp;&ensp;&ensp;(2) 陷入：由CPU内部事件所引起的中断，通常把这类中断称为内中断或陷入（trap）。如地址越界、非法指令、电源故障等<br>&ensp;&ensp;&ensp;&ensp;中断和陷入的主要区别：信号的来源不同，CPU外部还是内部  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.中断向量表和中断优先级</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;(1) 中断向量表：为<strong>每种设备配以相应的中断处理程序</strong>，并把该程序的入口地址，放在中断向量表的一个表项中，并为每一个设备的中断请求，规定一个中断号，它直接对应于中断向量表的一个表项中。<br>&ensp;&ensp;&ensp;&ensp;(2) 中断优先级：系统根据不同中断信号源，对服务要求的紧急程度的不同，它们分别规定不同的优先级。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.对多中断源的处理方式</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1) 屏蔽（禁止）中断<br>&ensp;&ensp;&ensp;&ensp;所有中断都将按顺序依次处理。<br>&ensp;&ensp;&ensp;&ensp;当处理机正在处理一个中断时，将屏蔽掉所有新到的中断，让它们等待，直到处理机已完成本次中断的处理后，处理机再去检查并处理。<br>&ensp;&ensp;&ensp;&ensp;优点是简单，但不能用于对实时性要求较高的中断请求。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8713.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;2) 嵌套中断：在设置了中断优先级的系统中，通常按这样的规则来进行优先级控制<br>&ensp;&ensp;&ensp;&ensp;当同时有多个不同优先级的中断请求时，CPU优先响应最高优先级的中断请求；<br>&ensp;&ensp;&ensp;&ensp;高优先级的中断请求，可以抢占正在运行低优先级中断的处理机，该方式类似于基于优先级的抢占式进程调度。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8714.png">  </p>
<h3 id="6-3-2-中断处理程序"><a href="#6-3-2-中断处理程序" class="headerlink" title="6.3.2 中断处理程序"></a>6.3.2 中断处理程序</h3><p>&ensp;&ensp;&ensp;&ensp;中断处理程序的处理过程：<br>&ensp;&ensp;&ensp;&ensp;（1）测定是否有未响应的中断信号<br>&ensp;&ensp;&ensp;&ensp;每当设备完成一个字符（或数据块）的读入（输出），设备控制器便向处理机发送一个中断请求信号。请求处理机将设备已读入的数据传送到内存的缓冲区中，或请求处理机将要输出的数据传送给设备控制器。<br>&ensp;&ensp;&ensp;&ensp;程序每当<strong>执行完当前指令后</strong>，处理机都要测试是否有未响应的中断信号。<br>&ensp;&ensp;&ensp;&ensp;（2）保护被中断进程的CPU环境<br>&ensp;&ensp;&ensp;&ensp;从中断现场恢复到当前进程运行所需要的信息。通常由硬件将处理机状态字（PSW）和保存在程序计数器（PC）中下一条指令的地址保存在中断栈中。<br>&ensp;&ensp;&ensp;&ensp;把中断进程的CPU现场信息，即将包括所有CPU寄存器的内容压入中断栈。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8715.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;（3）转入相应的设备处理程序<br>&ensp;&ensp;&ensp;&ensp;处理机测试中断源，确定引起中断的I/O设备，将相应的设备中断处理程序的入口地址装入到PC中，使处理机转向中断处理程序。<br>&ensp;&ensp;&ensp;&ensp;（4）中断处理<br>&ensp;&ensp;&ensp;&ensp;首先从设备控制器中读出设备状态，以判别本次中断是正常完成或异常中断，视情况处理。<br>&ensp;&ensp;&ensp;&ensp;（5）恢复CPU现场并退出中断<br>&ensp;&ensp;&ensp;&ensp;当中断处理完成以后，需要恢复CPU的现场，退出中断。但是，此刻是否返回到被中断的进程，取决于：<br>&ensp;&ensp;&ensp;&ensp;1）本中断是否采用了屏蔽（禁止）中断方式，若是，则返回被中断的进程。<br>&ensp;&ensp;&ensp;&ensp;2）若采用的是嵌套方式，如果没有更高级的中断请求I/O，则返回中断的进程；反之，系统将处理优先级更高的中断请求。  </p>
<p>&ensp;&ensp;&ensp;&ensp;中断处理流程<br>&ensp;&ensp;&ensp;&ensp;①测定是否有未响应的中断信号<br>&ensp;&ensp;&ensp;&ensp;②保护被中断进程的CPU环境<br>&ensp;&ensp;&ensp;&ensp;③转入相应的设备处理程序<br>&ensp;&ensp;&ensp;&ensp;④中断处理<br>&ensp;&ensp;&ensp;&ensp;⑤恢复CPU的现场<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8716.png">  </p>
<h2 id="6-4-设备驱动程序"><a href="#6-4-设备驱动程序" class="headerlink" title="6.4 设备驱动程序"></a>6.4 设备驱动程序</h2><p>&ensp;&ensp;&ensp;&ensp;设备驱动程序是I/O系统的高层与设备控制器之间的通信程序，其主要任务：<br>&ensp;&ensp;&ensp;&ensp;①接收上层软件发来的抽象I/O要求，如read、write等命令；<br>&ensp;&ensp;&ensp;&ensp;②再把它转化为具体要求，发送给设备控制器，启动设备去执行。<br>&ensp;&ensp;&ensp;&ensp;③反之，它也将由设备控制器发来的信号，传送给上层软件。  </p>
<h3 id="6-4-1-设备驱动程序概述"><a href="#6-4-1-设备驱动程序概述" class="headerlink" title="6.4.1 设备驱动程序概述"></a>6.4.1 设备驱动程序概述</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.设备驱动程序的功能</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）接收由与设备无关的软件发来的命令和参数，并将命令中的抽象要求，转换为与设备相关的低层操作序列；<br>&ensp;&ensp;&ensp;&ensp;（2）检查用户I/O请求的合法性，了解I/O设备的工作状态，传递与I/O设备操作有关的参数，设置设备的工作方式；<br>&ensp;&ensp;&ensp;&ensp;（3）发出I/O命令，如果设备空闲，便立即启动I/O设备，完成指定的I/O操作；如果设备忙碌，则将请求者挂在设备队列上等待；<br>&ensp;&ensp;&ensp;&ensp;（4）及时响应由设备控制器发来的中断请求，并根据其中断类型，调用相应的中断处理程序进行处理。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.设备驱动程序的特点</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;(1)驱动程序是与设备无关的软件和设备控制器之间通信和转换的程序。<br>&ensp;&ensp;&ensp;&ensp;(2)驱动程序，与设备控制器和I/O设备的硬件特性，紧密相关。<br>&ensp;&ensp;&ensp;&ensp;(3)驱动程序与I/O设备所采用的I/O控制方式紧密相关。<br>&ensp;&ensp;&ensp;&ensp;(4)由于驱动程序与硬件紧密相关，因而其中的一部分必须用汇编语言编写。<br>&ensp;&ensp;&ensp;&ensp;(5)驱动程序应允许可重入，一个正在运行的驱动程序常会在一次调用完成前被再次调用。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.设备处理方式</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;(1)为每一类设备设置一个进程，专门用于执行这类设备的I/O操作。这种方式比较适合于较大的系统；<br>&ensp;&ensp;&ensp;&ensp;(2)在整个系统中设置一个I/O进程，专门用于执行系统中所有各类设备的I/O操作。也可以设置一个输入进程和一个输出进程，分别处理系统中的输入或输出操作；<br>&ensp;&ensp;&ensp;&ensp;(3)不设置专门的设备处理进程，而只为各类设备设置相应的设备驱动程序，供用户或系统进程调用。这种方式目前用得较多。  </p>
<h3 id="6-4-2-设备驱动程序的处理过程"><a href="#6-4-2-设备驱动程序的处理过程" class="headerlink" title="6.4.2 设备驱动程序的处理过程"></a>6.4.2 设备驱动程序的处理过程</h3><p>&ensp;&ensp;&ensp;&ensp;(1)将抽象要求转换为具体要求<br>&ensp;&ensp;&ensp;&ensp;如：将抽象要求中的盘块号转换为磁盘的盘面、 磁道号及扇区。<br>&ensp;&ensp;&ensp;&ensp;(2)对服务请求进行校验<br>&ensp;&ensp;&ensp;&ensp;如：用户试图请求从打印机输入数据，系统应予以拒绝。<br>&ensp;&ensp;&ensp;&ensp;(3)检查设备的状态<br>&ensp;&ensp;&ensp;&ensp;如：为了向某设备写入数据，应先检查该设备是否处于接收就绪状态。<br>&ensp;&ensp;&ensp;&ensp;(4)传送必要的参数<br>&ensp;&ensp;&ensp;&ensp;在确定设备处于就绪状态后，还需传送必要的参数。<br>&ensp;&ensp;&ensp;&ensp;(5)启动I/O设备<br>&ensp;&ensp;&ensp;&ensp;完成准备工作之后，驱动程序可以向控制器中的命令寄存器传送相应的控制命令。驱动程序阻塞，在设备控制器的控制下进行I/O操作，直到中断到来时才将它唤醒。    </p>
<h3 id="6-4-3-对I-O设备的控制方式"><a href="#6-4-3-对I-O设备的控制方式" class="headerlink" title="6.4.3 对I/O设备的控制方式"></a>6.4.3 对I/O设备的控制方式</h3><p>&ensp;&ensp;&ensp;&ensp;I/O控制方式的宗旨：尽量减少主机对I/O控制的干预，把主机从繁杂的I/O控制事务中解脱出来，以便更多地去完成数据处理任务。  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）轮询的可编程I/O<br>&ensp;&ensp;&ensp;&ensp;利用I/O测试指令测试设备的闲忙，极大地浪费CPU<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8717.png"><br>&ensp;&ensp;&ensp;&ensp;2）中断的可编程的I/O<br>&ensp;&ensp;&ensp;&ensp;当设备完成I/O操作，便以中断请求方式通知CPU，然后进行相应处理，浪费CPU<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8718.png"><br>&ensp;&ensp;&ensp;&ensp;3）直接存储器访问<br>&ensp;&ensp;&ensp;&ensp;由DMA控制器送出内存地址和发出内存读、设备写或者设备读、内存写的控制信号完成内存与设备之间的直接数据传送，而不用CPU干预。仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的。数据传输的基本单位是数据块。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8719.png"><br>&ensp;&ensp;&ensp;&ensp;4）I/O通道<br>&ensp;&ensp;&ensp;&ensp;通道是独立于CPU的、专门负责数据的输入输出传输工作的处理器，它对外部设备实统一管理，代替CPU对I/O操作进行控制，从而使I/O操作可以与CPU并行工作。  </p>
<h2 id="6-5-与设备无关的I-O软件"><a href="#6-5-与设备无关的I-O软件" class="headerlink" title="6.5 与设备无关的I/O软件"></a>6.5 与设备无关的I/O软件</h2><p>&ensp;&ensp;&ensp;&ensp;设备独立性的基本含义：<br>&ensp;&ensp;&ensp;&ensp;应用程序中所使用的设备，不局限于使用某个具体的物理设备，也称为设备无关性。<br>&ensp;&ensp;&ensp;&ensp;为了实现设备独立性，必须再在设备驱动程序之上设置一层软件，称为与设备无关的I/O软件，或设备独立性软件。 </p>
<h3 id="6-5-1-与设备无关软件的基本概念"><a href="#6-5-1-与设备无关软件的基本概念" class="headerlink" title="6.5.1 与设备无关软件的基本概念"></a>6.5.1 与设备无关软件的基本概念</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.以物理设备名使用设备</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;早期OS中，应用程序用物理设备名使用设备，也即程序与系统中的物理设备直接相关。<br>&ensp;&ensp;&ensp;&ensp;问题：<br>&ensp;&ensp;&ensp;&ensp;当程序请求的物理设备被占用时，即使系统中还用相同设备空闲，也无法将设备分配给该应用程序。<br>&ensp;&ensp;&ensp;&ensp;当程序所需设备在系统中已经被更新时，该应用程序将再也无法在该系统上运行。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.引入了逻辑设备名</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;逻辑设备是抽象的设备名。<br>&ensp;&ensp;&ensp;&ensp;/dev/printer<br>&ensp;&ensp;&ensp;&ensp;(1)是抽象的设备名，易于实现设备的灵活分配，例如，/dev/printer，只是说明使用打印机打印，具体并没有指出使用哪台打印机输出。<br>&ensp;&ensp;&ensp;&ensp;(2)I/O重定向：指用于I/O操作的设备可以更换（重定向），而不必改变应用程序。例如：调试程序时，输出信息到显示器，调试结束后，输出结果到打印机。它具有很大的实用价值。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.逻辑设备名到物理设备名的转换</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;因系统只识别物理设备名，所以在实际执行中，需要实现逻辑设备名到物理设备名的转换。这类似与存储器管理中的逻辑地址和物理地址的概念。<br>&ensp;&ensp;&ensp;&ensp;因此，需要在系统中配置一张逻辑设备表用于转换。  </p>
<h3 id="6-5-2-与设备无关的软件"><a href="#6-5-2-与设备无关的软件" class="headerlink" title="6.5.2 与设备无关的软件"></a>6.5.2 与设备无关的软件</h3><p>&ensp;&ensp;&ensp;&ensp;与设备无关的软件是I/O系统最高层软件，在其下面是设备驱动程序，但它和设备驱动程序之间的界限，将随<strong>操作系统和设备的不同而有所差异</strong>。总的来说，在与设备无关的软件中，包括了执行所有设备公有操作的软件，具体有如下几项。    </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.设备驱动程序的统一接口</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;为使所有驱动程序具有统一接口，一方面要求每个驱动程序与OS之间有相同或相近接口；另一方面，要求将抽象设备名转换为物理设备名并进一步找到相应物理设备的驱动程序入口。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.缓冲管理</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;缓解设备与CPU之间的速度不匹配问题。分为单缓冲区，双缓冲区，循环缓冲区，公用缓冲池等。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.差错控制</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）暂时性错误（2）持久性错误  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.对独占设备的分配和回收</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;由系统统一分配，不允许进程自行使用。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>5.独立于设备的逻辑数据块</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;不同类型设备的数据交换单位是不同的，传输速率也各不相同。即使同一类型设备，其数据交换单位的大小也是由差异的。设备独立性软件能隐藏这些差异。  </p>
<h3 id="6-5-3-设备分配"><a href="#6-5-3-设备分配" class="headerlink" title="6.5.3 设备分配"></a>6.5.3 设备分配</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.设备分配中的数据结构</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）设备控制表DCT<br>&ensp;&ensp;&ensp;&ensp;在用于设备分配的数据结构中，记录了对设备或控制器进行控制所需的信息。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8720.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;2）控制器控制表（COCT），通道控制表(CHCT)和系统设备表(SDT)<br>&ensp;&ensp;&ensp;&ensp;（1）控制器控制表COCT ：<br>&ensp;&ensp;&ensp;&ensp;为每一个控制器都设置一张，记录控制器情况。<br>&ensp;&ensp;&ensp;&ensp;（2）通道控制表（CHCT)：<br>&ensp;&ensp;&ensp;&ensp;为每一个通道都设置一张，记录通道情况。<br>&ensp;&ensp;&ensp;&ensp;（3）系统设备表SDT：<br>&ensp;&ensp;&ensp;&ensp;这是系统范围的数据结构，记录系统中全部设备的情况，每个设备占一个表目。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8721.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.设备分配时应考虑的因素</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）设备的固有属性<br>&ensp;&ensp;&ensp;&ensp;（1）独占设备的分配策略。将该设备分配给进程后，便由进程独占，直至该进程释放。<br>&ensp;&ensp;&ensp;&ensp;（2）共享设备的分配策略。可同时分配给多个进程，注意进程访问次序的合理调度。<br>&ensp;&ensp;&ensp;&ensp;（3）虚拟设备的分配策略。虚拟设备属于可共享的设备。可同时分配给多个进程使用  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）设备分配算法<br>&ensp;&ensp;&ensp;&ensp;（1）FIFO （2）优先级高者优先  </p>
<p>&ensp;&ensp;&ensp;&ensp;3）设备分配中的安全性<br>&ensp;&ensp;&ensp;&ensp;安全分配(同步)：每当进程发出一个I/O请求后，即阻塞，直到其I/O完成。打破了死锁条件。<br>&ensp;&ensp;&ensp;&ensp;缺点：CPU、I/O 是串行工作的，进程进展缓慢。<br>&ensp;&ensp;&ensp;&ensp;不安全分配（异步）：需进行安全性检查，进程执行效率相对较高。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.独占设备的分配程序</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）基本的设备分配程序<br>&ensp;&ensp;&ensp;&ensp;（1）分配设备<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8722.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）分配控制器<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8723.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;（3）分配通道<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8724.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;只有在设备、控制器和通道三者都分配成功时，这次的I/O请求才算成功，便可启动I/O设备进行数据传输  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）设备分配程序的改进  </p>
<p>&ensp;&ensp;&ensp;&ensp;基本分配的缺点：<br>&ensp;&ensp;&ensp;&ensp;进程是以物理设备名提出I/O请求的。如果所指定的设备已分配给其它进程，则分配失败。或者说上面的设备分配程序，不具有与设备无关性。<br>&ensp;&ensp;&ensp;&ensp;改进：为获得设备的独立性，进程应使用逻辑设备名请求I/O。系统首先从SDT中，找出第一个该类设备的DCT。若该设备忙，又查找第二个该类设备的DCT，仅当所有该类设备都忙时，才把进程，挂在该类设备的等待队列上。而只要有一个该类设备可用，系统便进一步计算分配该设备的安全性。如安全，便可把设备分配给它。  </p>
<h3 id="6-5-4-逻辑设备名到物理设备名映射的实现"><a href="#6-5-4-逻辑设备名到物理设备名映射的实现" class="headerlink" title="6.5.4 逻辑设备名到物理设备名映射的实现"></a>6.5.4 逻辑设备名到物理设备名映射的实现</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.逻辑设备表（LUT：Logical Unit Table）</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在逻辑设备表的每个表目中包含了三项：逻辑设备名、物理设备名和设备驱动程序的入口地址。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8725.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.逻辑设备表的设置问题</strong>    </p>
<p>⑴ 在整个系统中只设置一张LUT，这种方式主要用于单用户系统中。不允许用户使用相同的逻辑设备名<br>⑵ 为每个用户设置一张LUT，当用户登入系统时，为其建立一个进程，同时也建立一张LUT，并将该表放入进程的PCB中。在多用户系统中配置了一张<strong>系统设备表</strong>。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8726.png">   </p>
<h2 id="6-6-用户层的I-O软件"><a href="#6-6-用户层的I-O软件" class="headerlink" title="6.6 用户层的I/O软件"></a>6.6 用户层的I/O软件</h2><p>一般而言，大部分的I/O软件都放在操作系统内部，但仍有一小部分在用户层，其中包括与用户程序链接在一起的库函数，以及完全运行于内核之外的假脱机系统等。  </p>
<h3 id="6-6-1-系统调用与库函数"><a href="#6-6-1-系统调用与库函数" class="headerlink" title="6.6.1 系统调用与库函数"></a>6.6.1 系统调用与库函数</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.系统调用</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;为使诸进程能有条不紊地使用I/O设备，且能保护设备的安全性，不允许运行在用户态的应用进程，去直接调用运行在核心态（系统态）的OS过程。<br>&ensp;&ensp;&ensp;&ensp;应用进程在运行时，又必须取得OS所提供的服务。<br>&ensp;&ensp;&ensp;&ensp;OS在用户层中引入了系统调用，应用程序可以通过它，间接调用OS中的I/O过程，对I/O设备进行操作。  </p>
<p>&ensp;&ensp;&ensp;&ensp;当应用程序需要执行某种I/O操作时，在该程序中必须使用系统调用。OS捕获到应用程序中的系统调用后，便将CPU的状态从用户态转换到核心态，然后转向操作系统中相应过程，由该过程完成所需的I/O操作。执行完成后，系统又将CPU状态从核心态转换到用户态，返回到应用程序继续执行。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8727.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.库函数</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在C语言以及UNIX系统中，系统调用与各系统调用所使用的库函数之间几乎是一一对应的。C语言中，首先提供了与系统调用相对应的库函数。<br>&ensp;&ensp;&ensp;&ensp;标准C库函数提供的I/O操作函数如fopen, fread, fwrite, fclose, fflush, fseek等，需包含头文件stdio.h。<br>&ensp;&ensp;&ensp;&ensp;内核和库函数之间的关系：内核提供了操作系统的基本功能，而库函数扩展了OS内核，使用户能方便取得操作系统的服务。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.系统调用库函数</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）系统调用是为了方便应用使用操作系统的接口，而库函数是为了方便人们编写应用程序而引出的，比如你自己编写一个函数其实也可以说就是一个库函数。<br>&ensp;&ensp;&ensp;&ensp;2）系统调用可以理解为内核提供给我们在用户态用的接口函数，可以认为是某种内核的库函数。<br>&ensp;&ensp;&ensp;&ensp;3）read就是系统调用,而fread就是C标准库函数。<br>&ensp;&ensp;&ensp;&ensp;4）写程序直接使用的是库函数，而库函数内部可能就是调用的同名系统调用。  </p>
<h3 id="6-6-2-假脱机-Spooling-系统"><a href="#6-6-2-假脱机-Spooling-系统" class="headerlink" title="6.6.2 假脱机(Spooling)系统"></a>6.6.2 假脱机(Spooling)系统</h3><p>&ensp;&ensp;&ensp;&ensp;在20世纪50年代，为了缓和CPU的高速性与I/O设备低速性间的矛盾，而引入了脱机输入、脱机输出技术。该技术是利用专门的外围控制机，先将低速I/O设备上的数据，传送到高速磁盘上，或者相反。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.假脱机技术</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;用两道程序模拟外围控制机功能。<br>&ensp;&ensp;&ensp;&ensp;一道模拟脱机输入时的外围控制机功能，把低速I/O设备上的数据传送到高速磁盘。另一道模拟脱机输出时外围机的控制机功能，把数据从磁盘传送到低速输出设备上。<br>&ensp;&ensp;&ensp;&ensp;我们把这种在联机情况下实现的同时外围操作的技术，称为SPOOLing(Simultaneaus Periphernal Operating OnLine)技术，或称为假脱机技术。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8728.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.SPOOLing的组成</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;SPOOLing系统主要由以下四部分组成<br>&ensp;&ensp;&ensp;&ensp;1）输入井和输出井。这是磁盘上开辟出来的两个区域。输入井和输出井中的数据一般以文件形式组织，称为井文件。<br>&ensp;&ensp;&ensp;&ensp;2）输入缓冲区和输出缓冲区。这是内存中开辟出来的两个区域，用于缓和CPU和磁盘之间速度不匹配的矛盾。<br>&ensp;&ensp;&ensp;&ensp;3）输入进程和输出进程。输入进程用于模拟脱机输入时的外围机而输出进程用于模拟脱机输出时的外围机。<br>&ensp;&ensp;&ensp;&ensp;4）井管理程序。用于控制作业与井之间的信息交换。当作业执行过程中向某台设备发出I/O请求时，由OS调用井管理程序，由其控制从输入井读取信息或将信息输出至输出井。  </p>
<p><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8729.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.SPOOLing系统的特点</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）提高了I/O速度<br>&ensp;&ensp;&ensp;&ensp;2）将独占设备改造为共享设备<br>&ensp;&ensp;&ensp;&ensp;3）实现了虚拟设备功能    </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.假脱机打印机系统</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;打印机属于独占设备。利用假脱机技术，可将它改造为一台可供多个用户共享的打印设备，从而提高设备的利用率，也方便了用户。<br>&ensp;&ensp;&ensp;&ensp;假脱机打印系统的构成：<br>&ensp;&ensp;&ensp;&ensp;1）磁盘缓冲区<br>&ensp;&ensp;&ensp;&ensp;2）打印缓冲区<br>&ensp;&ensp;&ensp;&ensp;3）假脱机管理进程和假脱机打印进程<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8730.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;当用户进程请求打印输出时,SPOOLing系统同意为它打印输出,但并不真正立即把打印机分配给用户进程,而由假脱机管理进程为它做两件事:<br>&ensp;&ensp;&ensp;&ensp;①在输出井中为之请求一个空闲磁盘块区,并将要打印的数据送入其中。<br>&ensp;&ensp;&ensp;&ensp;②再为用户进程申请一张空白的用户请求打印表,并将用户的打印要求填入其中,再将该表挂在请求打印队列上。<br>&ensp;&ensp;&ensp;&ensp;①假脱机打印进程真正完成打印输出过程:<br>&ensp;&ensp;&ensp;&ensp;如果打印机空闲,该进程将从请求打印队列的队首取出一张请求打印表,根据表中的要求将要打印的数据,从输出井传送到输出缓冲区,再由打印机进行打印。<br>&ensp;&ensp;&ensp;&ensp;②打印完毕后,该进程再查看请求打印队列中是否还有等待打印的请求表,如此下去,直至请求打印队列为空,假脱机打印进程才将自己阻塞起来。仅当下次再由打印请求时,假脱机打印进程才被唤醒。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>5.守护进程</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;守护进程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。守护进程是一种很有用的进程。<br>利用守护进程实现打印机：<br>&ensp;&ensp;&ensp;&ensp;①为打印机建立一个守护进程，由它执行一部分原来由假脱机管理进程功能的功能。<br>&ensp;&ensp;&ensp;&ensp;②由请求进程生成一份要求打印的文件，并将用户请求打印文件放入假脱机文件队列（目录）中。<br>&ensp;&ensp;&ensp;&ensp;把一台独占设备改造为可为多个进程共享的设备：<br>&ensp;&ensp;&ensp;&ensp;凡是需要将独占设备改造为可供多个进程共享的设备时，都要为该设备配置一个守护进程和一个假脱机文件队列（目录）。<br>&ensp;&ensp;&ensp;&ensp;守护进程是允许使用该独占设备的唯一进程，所有其它进程都不能直接使用该设备，只能将对该设备的使用要求写入一份文件中，放在假脱机目录中。由守护进程按照目录中的文件，依次来完成诸进程对该设备的请求。  </p>
<h2 id="6-7-缓冲区管理"><a href="#6-7-缓冲区管理" class="headerlink" title="6.7 缓冲区管理"></a>6.7 缓冲区管理</h2><p>&ensp;&ensp;&ensp;&ensp;现代OS中，几乎所有I/O设备与处理机交换设备时都用到了缓冲区。缓冲区是一个存储区域，它可以由专门的硬件寄存器组成，但成本较高。一般只在对速度要求很高的场合使用。一般情况下，都是利用内存作为缓冲区。   </p>
<h3 id="6-7-1-缓冲的引入"><a href="#6-7-1-缓冲的引入" class="headerlink" title="6.7.1 缓冲的引入"></a>6.7.1 缓冲的引入</h3><p>&ensp;&ensp;&ensp;&ensp;1）缓和CPU与I/O设备间速度不匹配的矛盾<br>&ensp;&ensp;&ensp;&ensp;2）减少对CPU的中断频率，放宽对CPU中断响应时间的限制<br>&ensp;&ensp;&ensp;&ensp;3）解决数据粒度不匹配的问题<br>&ensp;&ensp;&ensp;&ensp;4）提高CPU和I/O设备之间的并行性<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8731.png">   </p>
<h3 id="6-7-2-单缓冲区和双缓冲区"><a href="#6-7-2-单缓冲区和双缓冲区" class="headerlink" title="6.7.2 单缓冲区和双缓冲区"></a>6.7.2 单缓冲区和双缓冲区</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.单缓冲区</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在单缓冲情况下，每当用户进程发出一I/O请求时，操作系统便在主存中为之分配一缓冲区，如下图所示。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8732.png"><br>&ensp;&ensp;&ensp;&ensp;系统对每一块数据的处理时间表示为Max(C，T)+M。<br>&ensp;&ensp;&ensp;&ensp;T:从磁盘把一块数据送至缓冲区的时间<br>&ensp;&ensp;&ensp;&ensp;M:OS将缓冲区中的数据传送到用户区的时间<br>&ensp;&ensp;&ensp;&ensp;C:CPU对这一块数据的处理时间  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.双缓冲区</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;也称为缓冲对换(Buffer Swapping)。<br>&ensp;&ensp;&ensp;&ensp;在设备输入时，先将数据送入第一缓冲区，装满后便转向第二缓冲区。此时操作系统可以从第一缓冲区中移出数据，并送入用户进程。接着由CPU对数据进行计算。在双缓冲时，系统处理一块数据的时间可以粗略地认为是Max(C，T) 。实际上是MAX(C+M,T) 内存的移动时间M忽略不计<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8733.png">   </p>
<p>如果在实现两台机器之间通信时仅配置了单缓冲区，则任一时刻只能实现单向数据传输。为了实现双向数据传输，必须在两台机器中都设置双缓冲区。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8734.png">  </p>
<h3 id="6-7-3-环形缓冲区"><a href="#6-7-3-环形缓冲区" class="headerlink" title="6.7.3 环形缓冲区"></a>6.7.3 环形缓冲区</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.环形缓冲区的组成</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）多个缓冲区：在环形缓冲中包括多个缓冲区，其每个缓冲区的大小相同。<br>&ensp;&ensp;&ensp;&ensp;作为输入的多缓冲区可分为三种类型:<br>&ensp;&ensp;&ensp;&ensp;①用于装输入数据的空缓冲区R<br>&ensp;&ensp;&ensp;&ensp;②已装满数据的缓冲区G<br>&ensp;&ensp;&ensp;&ensp;③计算进程正在使用的现行工作缓冲区C  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）多个指针：用于指示计算进程下一个可用缓冲区G的指针Nextg、 指示输入进程下次可用的空缓冲区R的指针Nexti，用于指示计算进程正在使用的缓冲区C的指针Current。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8735.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.环形缓冲区的使用</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;(1)Getbuf过程：<br>&ensp;&ensp;&ensp;&ensp;计算进程调用Getbuf过程使用缓冲区中的数据。<br>&ensp;&ensp;&ensp;&ensp;该过程将由指针Nextg所指示的缓冲区提供给进程使用，相应地，须把它改为现行工作缓冲区，并令Current指针指向该缓冲区的第一个单元，同时将Nextg移向下一个G缓冲区。<br>&ensp;&ensp;&ensp;&ensp;(2)Releasebuf过程：<br>&ensp;&ensp;&ensp;&ensp;当计算进程把C缓冲区中的数据提取完毕时，便调用Releasebuf过程，将缓冲区C释放。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.进程之间的同步问题</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;(1) Nexti指针追赶上Nextg指针：<br>&ensp;&ensp;&ensp;&ensp;这意味着输入进程输入数据的速度大于计算进程处理数据的速度，已把全部可用的空缓冲区装满，再无缓冲区可用。这种情况被称为<strong>系统受计算限制</strong>。<br>&ensp;&ensp;&ensp;&ensp;(2) Nextg指针追赶上Nexti指针：<br>&ensp;&ensp;&ensp;&ensp;这意味着输入数据的速度低于计算进程处理数据的速度，使全部装有输入数据的缓冲区都被抽空，再无装有数据的缓冲区供计算进程提取数据。这种情况被称为<strong>系统受I/O限制</strong>。  </p>
<h3 id="6-7-4-缓冲池"><a href="#6-7-4-缓冲池" class="headerlink" title="6.7.4 缓冲池"></a>6.7.4 缓冲池</h3><p>&ensp;&ensp;&ensp;&ensp;上述的缓冲区是专门为特定的生产者和消费者设置的，它们属于专用缓冲。<br>&ensp;&ensp;&ensp;&ensp;当系统较大时，应该有许多这样的循环缓冲，这不仅要消耗大量的内存空间，而且其利用率不高。<br>&ensp;&ensp;&ensp;&ensp;为了提高缓冲区的利用率，目前广泛流行既可用于输入又可用于输出的公用缓冲池，在池中设置了多个可供若干个进程共享的缓冲区。<br>&ensp;&ensp;&ensp;&ensp;缓冲池与缓冲区的区别：缓冲区仅仅是一组内存块的链表，而缓冲池则包含了一个管理的数据结构和一组操作函数的管理机制，用于管理多个缓冲区。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.缓冲池的组成</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;三个队列：<br>&ensp;&ensp;&ensp;&ensp;1）空缓冲队列emq<br>&ensp;&ensp;&ensp;&ensp;2）输入队列inq<br>&ensp;&ensp;&ensp;&ensp;3）输出队列outq<br>&ensp;&ensp;&ensp;&ensp;四种工作缓冲区：<br>&ensp;&ensp;&ensp;&ensp;1）用于收容输入数据的工作缓冲区<br>&ensp;&ensp;&ensp;&ensp;2）用于提取输入数据的工作缓冲区<br>&ensp;&ensp;&ensp;&ensp;3）用于收容输出数据的工作缓冲区<br>&ensp;&ensp;&ensp;&ensp;4）用于提取输出数据的工作缓冲区  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.Getbuf过程和Putbuf过程</strong>   </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Getbuf</span><span class="params">(<span class="keyword">unsigned</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Wait (RS(type));</span><br><span class="line">   Wait(MS(type));   B(number)=Takebuf(type);</span><br><span class="line">   Signal(MS(type));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Putbuf</span><span class="params">(type, number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Wait(MS(type));</span><br><span class="line">   Addbuf(type, number) ;</span><br><span class="line">   Signal(MS(type));</span><br><span class="line">    Signal(RS(type));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;缓冲池中的队列本身是临界资源，过关进程在访问一个队列时需互斥同步。为了实现互斥访问队列，可为每个队列设置一个互斥信号量MS(type)。实现同步信号量RS(type)  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.缓冲区的工作方式</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1)收容输入:输入进程调用Getbuf(emq)，从空缓冲区队首摘下一个缓冲区，把它作为收容输入工作缓冲区hin，再调用PutBuf(inq,hin)过程，将它挂在输入队列inq队列上。<br>&ensp;&ensp;&ensp;&ensp;2)提取输入：计算进程调用Getbuf(inq)，从输入缓冲区队首摘下一个缓冲区，把它作为提取输入工作缓冲区sin，输入提取完毕后，再调用PutBuf(emq,sin)过程，将sin挂在空队列emq队列上。<br>&ensp;&ensp;&ensp;&ensp;3)收容输出:计算进程调用Getbuf(emq)，从空缓冲区队首摘下一个缓冲区，把它作为收容输出工作缓冲区hout，再调用PutBuf(outq,hout)过程，将它挂在输出队列hout队列上。<br>&ensp;&ensp;&ensp;&ensp;4)提取输出:输出进程调用Getbuf(outq)，从输出缓冲区队首摘下一个缓冲区，把它作为提取输出工作缓冲区sout，输出提取完毕后，再调用PutBuf(emq,sout)过程，将sout挂在空队列emq队列上。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8736.png">    </p>
<h2 id="6-8-磁盘存储器的性能和调度"><a href="#6-8-磁盘存储器的性能和调度" class="headerlink" title="6.8 磁盘存储器的性能和调度"></a>6.8 磁盘存储器的性能和调度</h2><p>&ensp;&ensp;&ensp;&ensp;磁盘存储器是计算机系统中最为重要的存储设备。<br>&ensp;&ensp;&ensp;&ensp;磁盘I/O速度的高低和磁盘系统的可靠性，将直接影响到系统的性能。可以通过多种途径改善磁盘系统的性能。具体包括：<br>&ensp;&ensp;&ensp;&ensp;①选择好的磁盘调度算法，以减少磁盘寻道时间<br>&ensp;&ensp;&ensp;&ensp;②提高磁盘I/O速度<br>&ensp;&ensp;&ensp;&ensp;③采取冗余技术，提高磁盘可靠性  </p>
<h3 id="6-6-1-磁盘性能简述"><a href="#6-6-1-磁盘性能简述" class="headerlink" title="6.6.1 磁盘性能简述"></a>6.6.1 磁盘性能简述</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.数据的组织和格式</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;磁盘设备中，可包含一个或多个盘片，每片分两面，每面又可分成若干条磁道(典型值为500<del>2000条磁道)，磁道之间有必要的空隙。<br>&ensp;&ensp;&ensp;&ensp;每条磁道上可存储相同数目的二进制位。这样磁盘密度即每英寸中所存储的位数，显然是内层磁道的密度较外层磁道的密度高。<br>&ensp;&ensp;&ensp;&ensp;每条磁道又分成若干个扇区，其典型值为10</del>100个扇区。每个扇区的大小相当于一个盘块。各扇区之间同样要保留一定的间隙。<br>&ensp;&ensp;&ensp;&ensp;一个物理记录存储在一个扇区上，磁盘上能存储的物理块数目是由扇区数，磁道数以及磁盘面数所决定的。<br>&ensp;&ensp;&ensp;&ensp;例如：一个10GB的磁盘，有8个双面可存储盘片，共16个存储面，每面有16383个磁道，63个扇区。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8737.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;为在磁盘上存储数据，必须将磁盘格式化。<br>&ensp;&ensp;&ensp;&ensp;温盘(温彻斯特)的一条磁道含有30个固定大小的扇区，每个扇区容量为600个字节。其中，512字节用于存放数据，其余用于存放控制信息。每个扇区包括两个字段：<br>&ensp;&ensp;&ensp;&ensp;①标识符字段<br>&ensp;&ensp;&ensp;&ensp;其中一个字节的SYNCH具有特定的位图像，作为该字段的定界符。利用磁道号、磁头号及扇区号三者来标识一个扇区; CRC字段用于段校验。<br>&ensp;&ensp;&ensp;&ensp;②数据字段<br>&ensp;&ensp;&ensp;&ensp;存放512个字节的数据。<br>&ensp;&ensp;&ensp;&ensp;每个磁道的不同扇区，每个扇区的不同字段之间，为了方便辨识，都设置了间距。<br>&ensp;&ensp;&ensp;&ensp;在磁盘格式化后，一般要对磁盘进行分区。在逻辑上，每个分区就是一个独立的逻辑磁盘。每个分区的起始扇区和大小都记录在磁盘0扇区的主引导记录分区表中。在这个分区表中必须有一个分区被标记成活动的（即引导块），以保证能够从硬盘引导系统。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8738.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.磁盘的类型</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）固定头磁盘：<br>&ensp;&ensp;&ensp;&ensp;这种磁盘在每条磁道上都有一读/写磁头，所有的磁头都被装在一刚性磁臂中。通过这些磁头可访问所有各磁道，并进行并行读/写，有效地提高了磁盘的I/O速度。这种结构的磁盘主要用于大容量磁盘上。<br>&ensp;&ensp;&ensp;&ensp;（2）移动头磁盘：<br>&ensp;&ensp;&ensp;&ensp;每一个盘面仅配有一个磁头，也被装入磁臂中。为能访问该盘面上的所有磁道，该磁头必须能移动以进行寻道。可见，移动磁头仅能以串行方式读/写，致使其I/O速度较慢；但由于其结构简单，故仍广泛应用于中小型磁盘设备中。在微型机上配置的温盘和软盘，都采用移动磁头结构。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.磁盘访问时间</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;磁盘在工作时，以恒定速率旋转。为了读或写，磁头必须能移动到所要求的磁道上，并等待所要求的扇区的开始位置旋转到磁头下，然后再开始读或写数据。对磁盘的访问时间，包括以下三部分：<br>&ensp;&ensp;&ensp;&ensp;1）寻道时间Ts<br>&ensp;&ensp;&ensp;&ensp;把磁臂(磁头)从当前位置移动到指定磁道上所经历的时间。该时间是启动磁臂的时间s与磁头移动n条磁道所花费的时间之和，即：<br>&ensp;&ensp;&ensp;&ensp;Ts =m*n+s<br>&ensp;&ensp;&ensp;&ensp;m是一常数，它与磁盘驱动器的速度有关。对一般磁盘，m=0.2；对高速磁盘，m≤0.1,磁臂启动时间约为2ms。对一般的温盘，其寻道时间将随寻道距离的增大而增大，大体上是5-30ms<br>&ensp;&ensp;&ensp;&ensp;2）旋转时间Tτ<br>&ensp;&ensp;&ensp;&ensp;Tτ是指定扇区移动到磁头下面所经历的时间。对于硬盘，一般的旋转速度为15000r/min,每转需时4ms. 平均旋转延迟时间Tτ为2ms. 对于软盘，其旋转速度为300或600r/min，这样，平均Tτ为50~100ms。<br>&ensp;&ensp;&ensp;&ensp;3）传输时间Tt<br>&ensp;&ensp;&ensp;&ensp;是指把数据从磁盘读出，或向磁盘写入数据所经历的时间。 Tt的大小与每次所读/写的字节数b及旋转速度有关：<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8739.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;r为磁盘以秒计的旋转速度；N为一条磁道上的字节数。当一次读/写的字节数相当于半条磁道上的字节数时， Tt与Tτ相同。<br>&ensp;&ensp;&ensp;&ensp;因此，可将访问时间Ta表示为:<br>&ensp;&ensp;&ensp;&ensp;Ta = Ts +1/2r+b/rN<br>&ensp;&ensp;&ensp;&ensp;由上式可以看出，在访问时间中，寻道 时间和旋转延迟时间，基本上都与所读/写数据的多少无关，而且它通常是占据了访问时间的大头。<br>&ensp;&ensp;&ensp;&ensp;例如:我们假定寻道时间和旋转延迟时间平均为20ms，而磁道的传输速率为10MB/s，如果传输10KB字节，此时总的访问时间为21ms，传输时间所占比例是相当的小。  </p>
<h3 id="6-6-2-早期的磁盘调度算法"><a href="#6-6-2-早期的磁盘调度算法" class="headerlink" title="6.6.2 早期的磁盘调度算法"></a>6.6.2 早期的磁盘调度算法</h3><p>当有多个进程都请求访问磁盘时，采用一种适当的磁盘调度算法，使各进程对磁盘的平均访问(主要是寻道)时间最小。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.先来先服务（FCFS）</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;最简单的磁盘调度算法。根据进程请求访问磁盘的先后次序进行调度。<br>&ensp;&ensp;&ensp;&ensp;优点: 公平、简单。每个进程的请求都能依次得到处理，不会出现某一进程的请求长期得不到满足的情况。但由于未对寻道进行优化，致使平均寻道时间可能较长。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8740.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.最短寻道时间优先（SSTF）</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;首先选择要求访问的磁道与当前磁头所在的磁道，距离最近的进程，以使每次的寻道时间最短。但这种算法不能保证平均寻道时间最短。<br>&ensp;&ensp;&ensp;&ensp;首先选择要求访问的磁道与当前磁头所在的磁道，距离最近的进程，以使每次的寻道时间最短。但这种算法不能保证平均寻道时间最短。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8741.png">    </p>
<h3 id="6-8-3-基于扫描的磁盘调度算法"><a href="#6-8-3-基于扫描的磁盘调度算法" class="headerlink" title="6.8.3 基于扫描的磁盘调度算法"></a>6.8.3 基于扫描的磁盘调度算法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.扫描算法</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;SSTF算法虽然获得较好的寻道性能，但它可能导致某些进程发生“饥饿”(Starvation)。<br>&ensp;&ensp;&ensp;&ensp;对SSTF算法略加修改后所形成的SCAN算法，即可防止老进程出现饥饿现象。<br>&ensp;&ensp;&ensp;&ensp;该算法不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向。<br>&ensp;&ensp;&ensp;&ensp;例如：当磁头正在自里向外移动时，SCAN算法所选择的下一个访问对象应既在当前磁道之外，又是距离最近的磁道。 这样自里向外地访问，直至再无更外的磁道需要访问时，才将磁臂换向，自外向里移动。<br>&ensp;&ensp;&ensp;&ensp;这种算法中磁头移动的规律颇似电梯的运行，故又常称为电梯调度算法。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8742.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.循环扫描算法（CSCAN）</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;SCAN算法既能获得较好的性能，又能访止进程饥饿，广泛用于大、中、小型机和网络中的磁盘调度。　<br>&ensp;&ensp;&ensp;&ensp;问题：当磁头刚从里向外移动过某一磁道时，恰有一进程请求访问此磁道，这时该进程必须等待，待磁头从里向外，然后再从外向里扫描完所有要访问的磁道后，才处理该进程的请求，致使该进程的请求被严重地推迟。<br>&ensp;&ensp;&ensp;&ensp;CSCAN算法规定磁头单向移动。例如，只自里向外移动，当磁头移到最外的磁道时，磁头立即返回到最里的欲访磁道，即将最小磁道号紧接着最大磁道号构成循环，进行扫描。采用循环扫描方式后，上述请求进程的请求延迟，将从原来的2T减T+Smax<br>&ensp;&ensp;&ensp;&ensp;T为由里向外或由外向里扫描完所有要访问的磁道所需的寻道时间，而Smax是将磁头从最外面被访问的磁道直接移到最里边欲访问的磁道所需的寻道时间(或相反)。<br><img src="/2021/06/17/os-6/%E5%9B%BE%E7%89%8743.png">     </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.NStepSCAN 和 FSCAN</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）NStepSCAN算法<br>&ensp;&ensp;&ensp;&ensp;在SSTF、SCAN及CSCAN几种调度算法中，都可能出现磁臂停留在某处不动的情况。这一现象称为磁臂粘着  (Armstickiness)。<br>&ensp;&ensp;&ensp;&ensp;N步SCAN算法是将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法依次处理这些子队列<br>&ensp;&ensp;&ensp;&ensp;每处理一个队列时，又是按SCAN算法，对一个队列处理完后又处理其它队列。当处理某子队列时，如果又出现新的磁盘I/O请求，便将新请求进程放入其他队列，这样就可避免出现粘着现象。<br>&ensp;&ensp;&ensp;&ensp;当N值取得很大时，会使N步扫描算法的性能，接近于SCAN算法的性能，当N=1时，N步SCAN算法退化为FCFS算法。</p>
<p>&ensp;&ensp;&ensp;&ensp;2）FSCAN算法<br>&ensp;&ensp;&ensp;&ensp;FSCAN算法实质上是N步SCAN算法的简化。它只将磁盘请求访问队列分成两个子队列。一是当前所有请求磁盘I/O的进程形成的队列，由磁盘调度按SCAN算法进行处理。另一个队列则是在扫描期间，新出现的所有请求磁盘I/O进程的队列，放入另一等待处理的请求队列。这样，所有的新请求都将被推迟到下一次扫描时处理。  </p>
<p>练习ppt 第六章 168-176</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>记录下没有训练出成果的情感识别模型</title>
    <url>/2021/08/05/rnn/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>弃之可惜orz</p>
<span id="more"></span> 


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader, Dataset</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> _pickle <span class="keyword">as</span> pickle</span><br><span class="line">max_len = <span class="number">200</span></span><br><span class="line">batch_size = <span class="number">128</span></span><br><span class="line">hidden_size = <span class="number">512</span></span><br><span class="line">num_layer = <span class="number">2</span></span><br><span class="line">bidriectional = <span class="literal">True</span></span><br><span class="line">dropout = <span class="number">0.4</span></span><br><span class="line">test_batch_size = <span class="number">2000</span></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">data_base_path = <span class="string">r&quot;C:\Users\74077\Desktop\aclImdb&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Word2Sequence</span>:</span></span><br><span class="line">    UNK_TAG = <span class="string">&quot;UNK&quot;</span></span><br><span class="line">    PAD_TAG = <span class="string">&quot;PAD&quot;</span></span><br><span class="line"></span><br><span class="line">    UNK = <span class="number">0</span></span><br><span class="line">    PAD = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.<span class="built_in">dict</span> = &#123;</span><br><span class="line">            self.UNK_TAG: self.UNK,</span><br><span class="line">            self.PAD_TAG: self.PAD</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        self.count = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span>(<span class="params">self, sentence</span>):</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> sentence:</span><br><span class="line">            self.count[word] = self.count.get(word, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_vocab</span>(<span class="params">self, <span class="built_in">min</span>=<span class="number">2</span>, <span class="built_in">max</span>=<span class="literal">None</span>, max_feature=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :param min:最小次数</span></span><br><span class="line"><span class="string">        :param max:最大次数</span></span><br><span class="line"><span class="string">        :param max_feature:一共保留多少个词语</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 删除词频小于min的word</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">min</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.count = &#123;word: value <span class="keyword">for</span> word, value <span class="keyword">in</span> self.count.items() <span class="keyword">if</span> value &gt; <span class="built_in">min</span>&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">max</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.count = &#123;word: value <span class="keyword">for</span> word, value <span class="keyword">in</span> self.count.items() <span class="keyword">if</span> value &lt; <span class="built_in">max</span>&#125;</span><br><span class="line">        <span class="keyword">if</span> max_feature <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            temp = <span class="built_in">sorted</span>(self.count.items(), key=<span class="keyword">lambda</span> x: x[-<span class="number">1</span>], reverse=<span class="literal">True</span>)[:max_feature]</span><br><span class="line">            self.count = <span class="built_in">dict</span>(temp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> self.count:</span><br><span class="line">            self.<span class="built_in">dict</span>[word] = <span class="built_in">len</span>(self.<span class="built_in">dict</span>)</span><br><span class="line"></span><br><span class="line">        self.inverse_dict = <span class="built_in">dict</span>(<span class="built_in">zip</span>(self.<span class="built_in">dict</span>.values(), self.<span class="built_in">dict</span>.keys()))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform</span>(<span class="params">self, sentence, max_len=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        把句子转换为序列</span></span><br><span class="line"><span class="string">        :param sentence:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> max_len <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> max_len &gt; <span class="built_in">len</span>(sentence):</span><br><span class="line">                sentence = sentence + [self.PAD_TAG] * (max_len - <span class="built_in">len</span>(sentence))</span><br><span class="line">            <span class="keyword">if</span> max_len &lt; <span class="built_in">len</span>(sentence):</span><br><span class="line">                sentence = sentence[:max_len]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [self.<span class="built_in">dict</span>.get(word, self.UNK) <span class="keyword">for</span> word <span class="keyword">in</span> sentence]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inverse_transform</span>(<span class="params">self, indices</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        把序列转换为句子</span></span><br><span class="line"><span class="string">        :param indices:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span>[self.inverse_dict.get(idx) <span class="keyword">for</span> idx <span class="keyword">in</span> indices]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.<span class="built_in">dict</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ws = Word2Sequence()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># def collate_fn(batch):</span></span><br><span class="line"><span class="comment">#     content, label = list(zip(*batch))</span></span><br><span class="line"><span class="comment">#     content = [ws.transform(i, max_len=max_len) for i in content]</span></span><br><span class="line"><span class="comment">#     content = torch.LongTensor(content)</span></span><br><span class="line"><span class="comment">#     label = torch.LongTensor(label)</span></span><br><span class="line"><span class="comment">#     return content, label</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collate_fn</span>(<span class="params">batch</span>):</span></span><br><span class="line">    <span class="comment"># MAX_LEN = 500</span></span><br><span class="line">    MAX_LEN = <span class="built_in">max</span>([<span class="built_in">len</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> texts]) <span class="comment">#取当前batch的最大值作为batch的最大长度</span></span><br><span class="line"></span><br><span class="line">    batch = <span class="built_in">list</span>(<span class="built_in">zip</span>(*batch))</span><br><span class="line">    labes = torch.tensor(batch[<span class="number">0</span>],dtype=torch.<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">    texts = batch[<span class="number">1</span>]</span><br><span class="line">    <span class="comment">#获取每个文本的长度</span></span><br><span class="line">    lengths = [<span class="built_in">len</span>(i) <span class="keyword">if</span> <span class="built_in">len</span>(i)&lt;MAX_LEN <span class="keyword">else</span> MAX_LEN <span class="keyword">for</span> i <span class="keyword">in</span> texts]</span><br><span class="line">    texts = torch.tensor([ws.transform(i, MAX_LEN) <span class="keyword">for</span> i <span class="keyword">in</span> texts])</span><br><span class="line">    <span class="keyword">del</span> batch</span><br><span class="line">    <span class="keyword">return</span> labes,texts,lengths</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tokenlize</span>(<span class="params">content</span>):</span></span><br><span class="line">    content = re.sub(<span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot; &quot;</span>, content)</span><br><span class="line">    fileters = [<span class="string">&#x27;!&#x27;</span>, <span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;&amp;&#x27;</span>, <span class="string">&#x27;\(&#x27;</span>, <span class="string">&#x27;\)&#x27;</span>, <span class="string">&#x27;\*&#x27;</span>, <span class="string">&#x27;\+&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;\.&#x27;</span>,<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;;&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;=&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;\?&#x27;</span>,<span class="string">&#x27;@&#x27;</span></span><br><span class="line">        ,<span class="string">&#x27;\[&#x27;</span>,<span class="string">&#x27;\\&#x27;</span>,<span class="string">&#x27;\]&#x27;</span>,<span class="string">&#x27;^&#x27;</span>,<span class="string">&#x27;_&#x27;</span>,<span class="string">&#x27;`&#x27;</span>,<span class="string">&#x27;\&#123;&#x27;</span>,<span class="string">&#x27;\|&#x27;</span>,<span class="string">&#x27;\&#125;&#x27;</span>,<span class="string">&#x27;~&#x27;</span>,<span class="string">&#x27;\t&#x27;</span>,<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;\x97&#x27;</span>,<span class="string">&#x27;\x96&#x27;</span>,<span class="string">&#x27;”&#x27;</span>,<span class="string">&#x27;“&#x27;</span>,]</span><br><span class="line">    content = re.sub(<span class="string">&quot;|&quot;</span>.join(fileters), <span class="string">&quot; &quot;</span>, content)</span><br><span class="line">    tokens = [i.strip().lower() <span class="keyword">for</span> i <span class="keyword">in</span> content.split()]</span><br><span class="line">    <span class="keyword">return</span> tokens</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImdbDataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, train=<span class="literal">True</span></span>):</span></span><br><span class="line">        self.train_data_path = <span class="string">r&quot;C:\Users\74077\Desktop\aclImdb\train&quot;</span></span><br><span class="line">        self.test_data_path = <span class="string">r&quot;C:\Users\74077\Desktop\aclImdb\test&quot;</span></span><br><span class="line">        data_path = self.train_data_path <span class="keyword">if</span> train <span class="keyword">else</span> self.test_data_path</span><br><span class="line">        temp_data_path = [os.path.join(data_path, <span class="string">&quot;pos&quot;</span>), os.path.join(data_path, <span class="string">&quot;neg&quot;</span>)]</span><br><span class="line">        self.total_file_path = []</span><br><span class="line">        <span class="keyword">for</span> path <span class="keyword">in</span> temp_data_path:</span><br><span class="line">            file_name_list = os.listdir(path)</span><br><span class="line">            file_path_list = [os.path.join(path, i) <span class="keyword">for</span> i <span class="keyword">in</span> file_name_list <span class="keyword">if</span> i.endswith(<span class="string">&quot;.txt&quot;</span>)]</span><br><span class="line">            self.total_file_path.extend(file_path_list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        file_path = self.total_file_path[index]</span><br><span class="line">        label_str = file_path.split(<span class="string">&quot;\\&quot;</span>)[-<span class="number">2</span>]</span><br><span class="line">        label = <span class="number">0</span> <span class="keyword">if</span> label_str == <span class="string">&quot;neg&quot;</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        tokens = tokenlize(<span class="built_in">open</span>(file_path, encoding=<span class="string">&#x27;utf-8&#x27;</span>).read())</span><br><span class="line">        <span class="keyword">return</span> tokens, label</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.total_file_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dataloader</span>(<span class="params">train=<span class="literal">True</span>, Batch_size=batch_size</span>):</span></span><br><span class="line">    imdb_dataset = ImdbDataset(train=train)</span><br><span class="line">    data_loader = DataLoader(imdb_dataset, batch_size=Batch_size, shuffle=<span class="literal">True</span>, collate_fn=collate_fn)</span><br><span class="line">    <span class="keyword">return</span> data_loader</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mymodel</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Mymodel, self).__init__()</span><br><span class="line">        self.embedding = nn.Embedding(<span class="built_in">len</span>(ws), <span class="number">100</span>)</span><br><span class="line">        self.lstm = nn.LSTM(input_size=<span class="number">100</span>, hidden_size=hidden_size, num_layers=num_layer, batch_first=<span class="literal">True</span>, bidirectional=bidriectional, dropout=dropout)</span><br><span class="line">        self.fc = nn.Linear(hidden_size * <span class="number">2</span>, <span class="number">20</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">20</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        x = self.embedding(<span class="built_in">input</span>)</span><br><span class="line">        x, (h_n, c_n) = self.lstm(x)</span><br><span class="line">        output_fw = h_n[-<span class="number">2</span>, :, :]</span><br><span class="line">        output_bw = h_n[-<span class="number">1</span>, :, :]</span><br><span class="line">        output = torch.cat([output_fw, output_bw], dim=-<span class="number">1</span>)</span><br><span class="line">        out = self.fc(output)</span><br><span class="line">        out = F.relu(out)</span><br><span class="line">        out = self.fc2(out)</span><br><span class="line">        <span class="keyword">return</span> F.log_softmax(out, dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = Mymodel().to(device)</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">1e-3</span>)</span><br><span class="line"><span class="comment"># if os.path.exists(&quot;./model/rnn.hh&quot;):</span></span><br><span class="line">    <span class="comment"># model.load_state_dict(torch.load(&quot;./model/rnn.hh&quot;))</span></span><br><span class="line">    <span class="comment"># optimizer.load_state_dict(torch.load(&quot;./model/rhhopt.hh&quot;))</span></span><br><span class="line">data_loader = get_dataloader()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">epoch</span>):</span></span><br><span class="line">    <span class="keyword">for</span> idx, (<span class="built_in">input</span>, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(get_dataloader()):</span><br><span class="line">        <span class="built_in">input</span> = <span class="built_in">input</span>.to(device)</span><br><span class="line">        target = target.to(device)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = model(<span class="built_in">input</span>)</span><br><span class="line">        loss = F.nll_loss(output, target)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="built_in">print</span>(epoch, idx, loss.item())</span><br><span class="line">        <span class="comment"># if idx % 100 == 0:</span></span><br><span class="line"><span class="comment"># torch.save(model.state_dict(), &quot;./model/rnn.hh&quot;)</span></span><br><span class="line"><span class="comment"># torch.save(optimizer.state_dict(), &quot;./model/rhhopt.hh&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span>():</span></span><br><span class="line">    loss_list = []</span><br><span class="line">    acc_list = []</span><br><span class="line">    <span class="keyword">for</span> idx, (<span class="built_in">input</span>, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(get_dataloader(train=<span class="literal">False</span>, Batch_size=test_batch_size)):</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            <span class="comment"># input = input.to(device)</span></span><br><span class="line">            <span class="comment"># target = target.to(device)</span></span><br><span class="line">            output = model(<span class="built_in">input</span>)</span><br><span class="line">            cur_loss = F.nll_loss(output, target)</span><br><span class="line">            loss_list.append(cur_loss)</span><br><span class="line">            pred = output.<span class="built_in">max</span>(dim=-<span class="number">1</span>)[-<span class="number">1</span>]</span><br><span class="line">            cur_acc = pred.eq(target).<span class="built_in">float</span>().mean()</span><br><span class="line">            acc_list.append(cur_acc)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;平均准确率，平均损失：&quot;</span>, np.mean(acc_list), np.mean(loss_list))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit_save_word_sequence</span>():</span></span><br><span class="line">    ws = Word2Sequence()</span><br><span class="line">    train_path = [os.path.join(data_base_path,i)  <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="string">&quot;train/neg&quot;</span>,<span class="string">&quot;train/pos&quot;</span>]]</span><br><span class="line">    total_file_path_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> train_path:</span><br><span class="line">        total_file_path_list.extend([os.path.join(i, j) <span class="keyword">for</span> j <span class="keyword">in</span> os.listdir(i)])</span><br><span class="line">    <span class="keyword">for</span> cur_path <span class="keyword">in</span> tqdm(total_file_path_list,<span class="built_in">ascii</span>=<span class="literal">True</span>,desc=<span class="string">&quot;fitting&quot;</span>):</span><br><span class="line">        ws.fit(tokenlize(<span class="built_in">open</span>(cur_path).read().strip()))</span><br><span class="line">    ws.build_vocab()</span><br><span class="line">    <span class="comment"># 对wordSequesnce进行保存</span></span><br><span class="line">    pickle.dump(ws,<span class="built_in">open</span>(<span class="string">&quot;./model/ws.pkl&quot;</span>,<span class="string">&quot;wb&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#2. 在dataset中使用wordsequence</span></span><br><span class="line"><span class="comment"># ws = pickle.load(open(&quot;./model/ws.pkl&quot;,&quot;rb&quot;))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        train(i)</span><br><span class="line">    <span class="built_in">eval</span>()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Minist手写数字识别</title>
    <url>/2021/07/19/pytorch4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用pytorch实现minist手写数字识别</p>
<span id="more"></span> 

<h1 id="Pytorch实现手写数字识别"><a href="#Pytorch实现手写数字识别" class="headerlink" title="Pytorch实现手写数字识别"></a>Pytorch实现手写数字识别</h1><h2 id="1-思路和流程分析"><a href="#1-思路和流程分析" class="headerlink" title="1. 思路和流程分析"></a>1. 思路和流程分析</h2><p>流程：</p>
<ol>
<li>准备数据，这些需要准备DataLoader</li>
<li>构建模型，这里可以使用torch构造一个深层的神经网络</li>
<li>模型的训练</li>
<li>模型的保存，保存模型，后续持续使用</li>
<li>模型的评估，使用测试集，观察模型的好坏</li>
</ol>
<h2 id="2-准备训练集和测试集"><a href="#2-准备训练集和测试集" class="headerlink" title="2. 准备训练集和测试集"></a>2. 准备训练集和测试集</h2><p>准备数据集的方法前面已经讲过，但是通过前面的内容可知，调用MNIST返回的结果中图形数据是一个Image对象,需要对其进行处理</p>
<p>为了进行数据的处理，接下来学习<code>torchvision.transfroms</code>的方法</p>
<h3 id="2-1-torchvision-transforms的图形数据处理方法"><a href="#2-1-torchvision-transforms的图形数据处理方法" class="headerlink" title="2.1 torchvision.transforms的图形数据处理方法"></a>2.1 <code>torchvision.transforms</code>的图形数据处理方法</h3><h4 id="2-1-1-torchvision-transforms-ToTensor"><a href="#2-1-1-torchvision-transforms-ToTensor" class="headerlink" title="2.1.1 torchvision.transforms.ToTensor"></a>2.1.1 <code>torchvision.transforms.ToTensor</code></h4><p>把一个取值范围是<code>[0,255]</code>的<code>PIL.Image</code>或者<code>shape</code>为<code>(H,W,C)</code>的<code>numpy.ndarray</code>，转换成形状为<code>[C,H,W]</code></p>
<p>其中<code>(H,W,C)</code>意思为<code>(高，宽，通道数)</code>，黑白图片的通道数只有1，其中每个像素点的取值为[0,255],彩色图片的通道数为(R,G,B),每个通道的每个像素点的取值为[0,255]，三个通道的颜色相互叠加，形成了各种颜色</p>
<p>示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = np.random.randint(<span class="number">0</span>, <span class="number">255</span>, size=<span class="number">12</span>)</span><br><span class="line">img = data.reshape(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(img.shape)</span><br><span class="line">img_tensor = transforms.ToTensor()(img) <span class="comment"># 转换成tensor</span></span><br><span class="line"><span class="built_in">print</span>(img_tensor)</span><br><span class="line"><span class="built_in">print</span>(img_tensor.shape)</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shape:(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">img_tensor:tensor([[[<span class="number">215</span>, <span class="number">171</span>],</span><br><span class="line">                 [ <span class="number">34</span>,  <span class="number">12</span>]],</span><br><span class="line"></span><br><span class="line">                [[<span class="number">229</span>,  <span class="number">87</span>],</span><br><span class="line">                 [ <span class="number">15</span>, <span class="number">237</span>]],</span><br><span class="line"></span><br><span class="line">                [[ <span class="number">10</span>,  <span class="number">55</span>],</span><br><span class="line">                 [ <span class="number">72</span>, <span class="number">204</span>]]], dtype=torch.int32)</span><br><span class="line">new shape:torch.Size([<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p><code>transforms.ToTensor</code>对象中有<code>__call__</code>方法，所以可以对其示例能够传入数据获取结果</p>
<h4 id="2-1-2-torchvision-transforms-Normalize-mean-std"><a href="#2-1-2-torchvision-transforms-Normalize-mean-std" class="headerlink" title="2.1.2 torchvision.transforms.Normalize(mean, std)"></a>2.1.2 <code>torchvision.transforms.Normalize(mean, std)</code></h4><p>给定均值：mean，shape和图片的通道数相同(指的是每个通道的均值)，方差：std，和图片的通道数相同(指的是每个通道的方差)，将会把<code>Tensor</code>规范化处理。</p>
<p>即：<code>Normalized_image=(image-mean)/std</code>。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line">data = np.random.randint(<span class="number">0</span>, <span class="number">255</span>, size=<span class="number">12</span>)</span><br><span class="line">img = data.reshape(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">img = transforms.ToTensor()(img) <span class="comment"># 转换成tensor</span></span><br><span class="line"><span class="built_in">print</span>(img)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">norm_img = transforms.Normalize((<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>), (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>))(img) <span class="comment">#进行规范化处理</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(norm_img)</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tensor([[[177, 223],</span><br><span class="line">         [ 71, 182]],</span><br><span class="line"></span><br><span class="line">        [[153, 120],</span><br><span class="line">         [173,  33]],</span><br><span class="line"></span><br><span class="line">        [[162, 233],</span><br><span class="line">         [194,  73]]], dtype&#x3D;torch.int32)</span><br><span class="line">***************************************************************************************</span><br><span class="line">tensor([[[167, 213],</span><br><span class="line">         [ 61, 172]],</span><br><span class="line"></span><br><span class="line">        [[143, 110],</span><br><span class="line">         [163,  23]],</span><br><span class="line"></span><br><span class="line">        [[152, 223],</span><br><span class="line">         [184,  63]]], dtype&#x3D;torch.int32)</span><br></pre></td></tr></table></figure>

<p>注意：在sklearn中，默认上式中的std和mean为数据每列的std和mean，sklearn会在标准化之前算出每一列的std和mean。</p>
<p>但是在api：Normalize中并没有帮我们计算，所以我们需要手动计算</p>
<ol>
<li><p>当mean为全部数据的均值，std为全部数据的std的时候，才是进行了标准化。</p>
</li>
<li><p>如果mean(x)不是全部数据的mean的时候，std(y)也不是的时候，Normalize后的数据分布满足下面的关系<br>$$<br>\begin{align*}<br>&amp;new_mean = \frac{mean-x}{y}&amp;， mean为原数据的均值，x为传入的均值x \<br>&amp;new_std = \frac{std}{y} &amp;，y为传入的标准差y\<br>\end{align*}<br>$$</p>
</li>
</ol>
<h4 id="2-1-3-torchvision-transforms-Compose-transforms"><a href="#2-1-3-torchvision-transforms-Compose-transforms" class="headerlink" title="2.1.3 torchvision.transforms.Compose(transforms)"></a>2.1.3 <code>torchvision.transforms.Compose(transforms)</code></h4><p>将多个<code>transform</code>组合起来使用。</p>
<p>例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transforms.Compose([</span><br><span class="line">     torchvision.transforms.ToTensor(), <span class="comment">#先转化为Tensor</span></span><br><span class="line">     torchvision.transforms.Normalize(mean,std) <span class="comment">#在进行正则化</span></span><br><span class="line"> ])</span><br></pre></td></tr></table></figure>



<h3 id="2-2-准备MNIST数据集的Dataset和DataLoader"><a href="#2-2-准备MNIST数据集的Dataset和DataLoader" class="headerlink" title="2.2 准备MNIST数据集的Dataset和DataLoader"></a>2.2 准备MNIST数据集的Dataset和DataLoader</h3><p>准备训练集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line"><span class="comment">#准备数据集，其中0.1307，0.3081为MNIST数据的均值和标准差，这样操作能够对其进行标准化</span></span><br><span class="line"><span class="comment">#因为MNIST只有一个通道（黑白图片）,所以元组中只有一个值</span></span><br><span class="line">dataset = torchvision.datasets.MNIST(<span class="string">&#x27;/data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>,</span><br><span class="line">                             transform=torchvision.transforms.Compose([</span><br><span class="line">                               torchvision.transforms.ToTensor(),</span><br><span class="line">                               torchvision.transforms.Normalize(</span><br><span class="line">                                 (<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">                             ]))</span><br><span class="line"><span class="comment">#准备数据迭代器                          </span></span><br><span class="line">train_dataloader = torch.utils.data.DataLoader(dataset,batch_size=<span class="number">64</span>,shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>准备测试集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line"><span class="comment">#准备数据集，其中0.1307，0.3081为MNIST数据的均值和标准差，这样操作能够对其进行标准化</span></span><br><span class="line"><span class="comment">#因为MNIST只有一个通道（黑白图片）,所以元组中只有一个值</span></span><br><span class="line">dataset = torchvision.datasets.MNIST(<span class="string">&#x27;/data&#x27;</span>, train=<span class="literal">False</span>, download=<span class="literal">True</span>,</span><br><span class="line">                             transform=torchvision.transforms.Compose([</span><br><span class="line">                               torchvision.transforms.ToTensor(),</span><br><span class="line">                               torchvision.transforms.Normalize(</span><br><span class="line">                                 (<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">                             ]))</span><br><span class="line"><span class="comment">#准备数据迭代器                          </span></span><br><span class="line">train_dataloader = torch.utils.data.DataLoader(dataset,batch_size=<span class="number">64</span>,shuffle=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-构建模型"><a href="#3-构建模型" class="headerlink" title="3. 构建模型"></a>3. 构建模型</h2><p>补充：<strong>全连接层</strong>：当前一层的神经元和前一层的神经元相互链接，其核心操作就是$y = wx​$，即矩阵的乘法，实现对前一层的数据的变换</p>
<p>模型的构建使用了一个三层的神经网络，其中包括两个全连接层和一个输出层，第一个全连接层会经过激活函数的处理，将处理后的结果交给下一个全连接层，进行变换后输出结果</p>
<p>那么在这个模型中有两个地方需要注意：</p>
<ol>
<li>激活函数如何使用</li>
<li>每一层数据的形状</li>
<li>模型的损失函数</li>
</ol>
<h3 id="3-1-激活函数的使用"><a href="#3-1-激活函数的使用" class="headerlink" title="3.1 激活函数的使用"></a>3.1 激活函数的使用</h3><p>前面介绍了激活函数的作用，常用的激活函数为Relu激活函数，他的使用非常简单</p>
<p>Relu激活函数由<code>import torch.nn.functional as F</code>提供，<code>F.relu(x)</code>即可对x进行处理</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">30</span>]: b</span><br><span class="line">Out[<span class="number">30</span>]: tensor([-<span class="number">2</span>, -<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: <span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: F.relu(b)</span><br><span class="line">Out[<span class="number">32</span>]: tensor([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>



<h3 id="3-2-模型中数据的形状（【添加形状变化图形】）"><a href="#3-2-模型中数据的形状（【添加形状变化图形】）" class="headerlink" title="3.2  模型中数据的形状（【添加形状变化图形】）"></a>3.2  模型中数据的形状（【添加形状变化图形】）</h3><ol>
<li>原始输入数据为的形状:<code>[batch_size,1,28,28]</code></li>
<li>进行形状的修改：<code>[batch_size,28*28]</code> ,(全连接层是在进行矩阵的乘法操作)</li>
<li>第一个全连接层的输出形状：<code>[batch_size,28]</code>，这里的28是个人设定的，你也可以设置为别的</li>
<li>激活函数不会修改数据的形状</li>
<li>第二个全连接层的输出形状：<code>[batch_size,10]</code>,因为手写数字有10个类别</li>
</ol>
<p>构建模型的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MnistNet</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MnistNet,self).__init__()</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">28</span>*<span class="number">28</span>*<span class="number">1</span>,<span class="number">28</span>)  <span class="comment">#定义Linear的输入和输出的形状</span></span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">28</span>,<span class="number">10</span>)  <span class="comment">#定义Linear的输入和输出的形状</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        x = x.view(-<span class="number">1</span>,<span class="number">28</span>*<span class="number">28</span>*<span class="number">1</span>)  <span class="comment">#对数据形状变形，-1表示该位置根据后面的形状自动调整</span></span><br><span class="line">        x = self.fc1(x) <span class="comment">#[batch_size,28]</span></span><br><span class="line">        x = F.relu(x)  <span class="comment">#[batch_size,28]</span></span><br><span class="line">        x = self.fc2(x) <span class="comment">#[batch_size,10]</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>可以发现：pytorch在构建模型的时候<code>形状上</code>并不会考虑<code>batch_size</code></p>
<h3 id="3-3-模型的损失函数"><a href="#3-3-模型的损失函数" class="headerlink" title="3.3 模型的损失函数"></a>3.3 模型的损失函数</h3><p>首先，我们需要明确，当前我们手写字体识别的问题是一个多分类的问题，所谓多分类对比的是之前学习的2分类</p>
<p>在逻辑回归中，我们使用sigmoid进行计算对数似然损失，来定义我们的2分类的损失。</p>
<ul>
<li><p>在2分类中我们有正类和负类，正类的概率为$P(x) =  \frac{1}{1+e^{-x}} = \frac{e^x}{1+e^x}$,那么负类的概率为$1-P(x)​$</p>
</li>
<li><p>将这个结果进行计算对数似然损失$-\sum y log(P(x))​$就可以得到最终的损失</p>
</li>
</ul>
<p>那么在多分类的过程中我们应该怎么做呢？</p>
<ul>
<li><p>多分类和2分类中唯一的区别是我们不能够再使用sigmoid函数来计算当前样本属于某个类别的概率，而应该使用softmax函数。</p>
</li>
<li><p>softmax和sigmoid的区别在于我们需要去计算样本属于每个类别的概率，需要计算多次，而sigmoid只需要计算一次</p>
</li>
</ul>
<p>例如下图：</p>
<p><img src="/2021/07/19/pytorch4/softmax.png"></p>
<p>假如softmax之前的输出结果是<code>2.3, 4.1, 5.6</code>,那么经过softmax之后的结果是多少呢？<br>$$<br>Y1 = \frac{e^{2.3}}{e^{2.3}+e^{4.1}+e^{5.6}} \<br>Y2 = \frac{e^{4.1}}{e^{2.3}+e^{4.1}+e^{5.6}} \<br>Y3 = \frac{e^{5.6}}{e^{2.3}+e^{4.1}+e^{5.6}} \<br>$$</p>
<p>对于这个softmax输出的结果，是在[0,1]区间，我们可以把它当做概率</p>
<p>和前面2分类的损失一样，多分类的损失只需要再把这个结果进行对数似然损失的计算即可</p>
<p>即：<br>$$<br>\begin{align*}<br>&amp; J = -\sum Y log(P) &amp;, 其中 P = \frac{e^{z_j}}{\sum^K_{k=1}e^{z_K}} ,Y表示真实值<br>\end{align*}<br>$$<br>最后，会计算每个样本的损失，即上式的平均值</p>
<p>我们把softmax概率传入对数似然损失得到的损失函数称为<strong>交叉熵损失</strong></p>
<p>在pytorch中有两种方法实现交叉熵损失</p>
<p>1.<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">criterion &#x3D; nn.CrossEntropyLoss()</span><br><span class="line">loss &#x3D; criterion(input,target)</span><br></pre></td></tr></table></figure></p>
<p>2.<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1. 对输出值计算softmax和取对数</span><br><span class="line">output &#x3D; F.log_softmax(x,dim&#x3D;-1)</span><br><span class="line">#2. 使用torch中带权损失</span><br><span class="line">loss &#x3D; F.nll_loss(output,target)</span><br></pre></td></tr></table></figure></p>
<p>带权损失定义为：$l_n = -\sum w_{i} x_{i}$，其实就是把$log(P)$作为$x_i$,把真实值Y作为权重</p>
<h2 id="4-模型的训练"><a href="#4-模型的训练" class="headerlink" title="4. 模型的训练"></a>4. 模型的训练</h2><p>训练的流程：</p>
<ol>
<li>实例化模型，设置模型为训练模式</li>
<li>实例化优化器类，实例化损失函数</li>
<li>获取，遍历dataloader</li>
<li>梯度置为0</li>
<li>进行向前计算</li>
<li>计算损失</li>
<li>反向传播</li>
<li>更新参数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mnist_net = MnistNet()</span><br><span class="line">optimizer = optim.Adam(mnist_net.parameters(),lr= <span class="number">0.001</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">epoch</span>):</span></span><br><span class="line">    mode = <span class="literal">True</span></span><br><span class="line">    mnist_net.train(mode=mode) <span class="comment">#模型设置为训练模型</span></span><br><span class="line">    </span><br><span class="line">    train_dataloader = get_dataloader(train=mode) <span class="comment">#获取训练数据集</span></span><br><span class="line">    <span class="keyword">for</span> idx,(data,target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_dataloader):</span><br><span class="line">        optimizer.zero_grad() <span class="comment">#梯度置为0</span></span><br><span class="line">        output = mnist_net(data) <span class="comment">#进行向前计算</span></span><br><span class="line">        loss = F.nll_loss(output,target) <span class="comment">#带权损失</span></span><br><span class="line">        loss.backward()  <span class="comment">#进行反向传播，计算梯度</span></span><br><span class="line">        optimizer.step() <span class="comment">#参数更新</span></span><br><span class="line">        <span class="keyword">if</span> idx % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\tLoss: &#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                epoch, idx * <span class="built_in">len</span>(data), <span class="built_in">len</span>(train_dataloader.dataset),</span><br><span class="line">                       <span class="number">100.</span> * idx / <span class="built_in">len</span>(train_dataloader), loss.item()))</span><br></pre></td></tr></table></figure>



<h2 id="5-模型的保存和加载"><a href="#5-模型的保存和加载" class="headerlink" title="5. 模型的保存和加载"></a>5. 模型的保存和加载</h2><h3 id="5-1-模型的保存"><a href="#5-1-模型的保存" class="headerlink" title="5.1 模型的保存"></a>5.1 模型的保存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.save(mnist_net.state_dict(),<span class="string">&quot;model/mnist_net.pt&quot;</span>) <span class="comment">#保存模型参数</span></span><br><span class="line">torch.save(optimizer.state_dict(), <span class="string">&#x27;results/mnist_optimizer.pt&#x27;</span>) <span class="comment">#保存优化器参数</span></span><br></pre></td></tr></table></figure>



<h3 id="5-2-模型的加载"><a href="#5-2-模型的加载" class="headerlink" title="5.2 模型的加载"></a>5.2 模型的加载</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mnist_net.load_state_dict(torch.load(<span class="string">&quot;model/mnist_net.pt&quot;</span>))</span><br><span class="line">optimizer.load_state_dict(torch.load(<span class="string">&quot;results/mnist_optimizer.pt&quot;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="6-模型的评估"><a href="#6-模型的评估" class="headerlink" title="6. 模型的评估"></a>6. 模型的评估</h2><p>评估的过程和训练的过程相似，但是：</p>
<ol>
<li>不需要计算梯度</li>
<li>需要收集损失和准确率，用来计算平均损失和平均准确率</li>
<li>损失的计算和训练时候损失的计算方法相同</li>
<li>准确率的计算：<ul>
<li>模型的输出为[batch_size,10]的形状</li>
<li>其中最大值的位置就是其预测的目标值（预测值进行过sotfmax后为概率，sotfmax中分母都是相同的，分子越大，概率越大）</li>
<li>最大值的位置获取的方法可以使用<code>torch.max</code>,返回最大值和最大值的位置</li>
<li>返回最大值的位置后，和真实值（<code>[batch_size]</code>）进行对比，相同表示预测成功</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    test_loss = <span class="number">0</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    mnist_net.<span class="built_in">eval</span>()  <span class="comment">#设置模型为评估模式</span></span><br><span class="line">    test_dataloader = get_dataloader(train=<span class="literal">False</span>) <span class="comment">#获取评估数据集</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad(): <span class="comment">#不计算其梯度</span></span><br><span class="line">        <span class="keyword">for</span> data, target <span class="keyword">in</span> test_dataloader:</span><br><span class="line">            output = mnist_net(data)</span><br><span class="line">            test_loss += F.nll_loss(output, target, reduction=<span class="string">&#x27;sum&#x27;</span>).item()</span><br><span class="line">            pred = output.data.<span class="built_in">max</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)[<span class="number">1</span>] <span class="comment">#获取最大值的位置,[batch_size,1]</span></span><br><span class="line">            correct += pred.eq(target.data.view_as(pred)).<span class="built_in">sum</span>()  <span class="comment">#预测准备样本数累加</span></span><br><span class="line">    test_loss /= <span class="built_in">len</span>(test_dataloader.dataset) <span class="comment">#计算平均损失</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nTest set: Avg. loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.2f&#125;%)\n&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">        test_loss, correct, <span class="built_in">len</span>(test_dataloader.dataset),</span><br><span class="line">        <span class="number">100.</span> * correct / <span class="built_in">len</span>(test_dataloader.dataset)))</span><br></pre></td></tr></table></figure>



<h2 id="7-完整的代码如下："><a href="#7-完整的代码如下：" class="headerlink" title="7. 完整的代码如下："></a>7. 完整的代码如下：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line">train_batch_size = <span class="number">64</span></span><br><span class="line">test_batch_size = <span class="number">1000</span></span><br><span class="line">img_size = <span class="number">28</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dataloader</span>(<span class="params">train=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(train,<span class="built_in">bool</span>),<span class="string">&quot;train 必须是bool类型&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#准备数据集，其中0.1307，0.3081为MNIST数据的均值和标准差，这样操作能够对其进行标准化</span></span><br><span class="line">    <span class="comment">#因为MNIST只有一个通道（黑白图片）,所以元组中只有一个值</span></span><br><span class="line">    dataset = torchvision.datasets.MNIST(<span class="string">&#x27;/data&#x27;</span>, train=train, download=<span class="literal">True</span>,</span><br><span class="line">                                         transform=torchvision.transforms.Compose([</span><br><span class="line">                                         torchvision.transforms.ToTensor(),</span><br><span class="line">                                         torchvision.transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,)),]))</span><br><span class="line">    <span class="comment">#准备数据迭代器</span></span><br><span class="line">    batch_size = train_batch_size <span class="keyword">if</span> train <span class="keyword">else</span> test_batch_size</span><br><span class="line">    dataloader = torch.utils.data.DataLoader(dataset,batch_size=batch_size,shuffle=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> dataloader</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MnistNet</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MnistNet,self).__init__()</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">28</span>*<span class="number">28</span>*<span class="number">1</span>,<span class="number">28</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">28</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        x = x.view(-<span class="number">1</span>,<span class="number">28</span>*<span class="number">28</span>*<span class="number">1</span>)</span><br><span class="line">        x = self.fc1(x) <span class="comment">#[batch_size,28]</span></span><br><span class="line">        x = F.relu(x)  <span class="comment">#[batch_size,28]</span></span><br><span class="line">        x = self.fc2(x) <span class="comment">#[batch_size,10]</span></span><br><span class="line">        <span class="comment"># return x</span></span><br><span class="line">        <span class="keyword">return</span> F.log_softmax(x,dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">mnist_net = MnistNet()</span><br><span class="line">optimizer = optim.Adam(mnist_net.parameters(),lr= <span class="number">0.001</span>)</span><br><span class="line"><span class="comment"># criterion = nn.NLLLoss()</span></span><br><span class="line"><span class="comment"># criterion = nn.CrossEntropyLoss()</span></span><br><span class="line">train_loss_list = []</span><br><span class="line">train_count_list = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">epoch</span>):</span></span><br><span class="line">    mode = <span class="literal">True</span></span><br><span class="line">    mnist_net.train(mode=mode)</span><br><span class="line">    train_dataloader = get_dataloader(train=mode)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(train_dataloader.dataset))</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(train_dataloader))</span><br><span class="line">    <span class="keyword">for</span> idx,(data,target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_dataloader):</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = mnist_net(data)</span><br><span class="line">        loss = F.nll_loss(output,target) <span class="comment">#对数似然损失</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span> idx % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\tLoss: &#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                epoch, idx * <span class="built_in">len</span>(data), <span class="built_in">len</span>(train_dataloader.dataset),</span><br><span class="line">                       <span class="number">100.</span> * idx / <span class="built_in">len</span>(train_dataloader), loss.item()))</span><br><span class="line"></span><br><span class="line">            train_loss_list.append(loss.item())</span><br><span class="line">            train_count_list.append(idx*train_batch_size+(epoch-<span class="number">1</span>)*<span class="built_in">len</span>(train_dataloader))</span><br><span class="line">            torch.save(mnist_net.state_dict(),<span class="string">&quot;model/mnist_net.pkl&quot;</span>)</span><br><span class="line">            torch.save(optimizer.state_dict(), <span class="string">&#x27;results/mnist_optimizer.pkl&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    test_loss = <span class="number">0</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    mnist_net.<span class="built_in">eval</span>()</span><br><span class="line">    test_dataloader = get_dataloader(train=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data, target <span class="keyword">in</span> test_dataloader:</span><br><span class="line">            output = mnist_net(data)</span><br><span class="line">            test_loss += F.nll_loss(output, target, reduction=<span class="string">&#x27;sum&#x27;</span>).item()</span><br><span class="line">            pred = output.data.<span class="built_in">max</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)[<span class="number">1</span>] <span class="comment">#获取最大值的位置,[batch_size,1]</span></span><br><span class="line">            correct += pred.eq(target.data.view_as(pred)).<span class="built_in">sum</span>()</span><br><span class="line">    test_loss /= <span class="built_in">len</span>(test_dataloader.dataset)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nTest set: Avg. loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.2f&#125;%)\n&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">        test_loss, correct, <span class="built_in">len</span>(test_dataloader.dataset),</span><br><span class="line">        <span class="number">100.</span> * correct / <span class="built_in">len</span>(test_dataloader.dataset)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    test()  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>): <span class="comment">#模型训练5轮</span></span><br><span class="line">        train(i)</span><br><span class="line">        test()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>循环神经网络（RNN）原理和简单应用</title>
    <url>/2021/07/21/pytorch5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>循环神经网络原理学习应用</p>
<span id="more"></span> 

<h1 id="循环神经网络原理"><a href="#循环神经网络原理" class="headerlink" title="循环神经网络原理"></a>循环神经网络原理</h1><h2 id="1-循环神经网络的介绍"><a href="#1-循环神经网络的介绍" class="headerlink" title="1. 循环神经网络的介绍"></a>1. 循环神经网络的介绍</h2><p>在普通的神经网络中，信息的传递是单向的，这种限制虽然使得网络变得更容易学习，但在一定程度上也减弱了神经网络模型的能力。特别是在很多现实任务中，网络的输出不仅和当前时刻的输入相关，也和其过去一段时间的输出相关。此外，普通网络难以处理时序数据，比如视频、语音、文本等，时序数据的长度一般是不固定的，而前馈神经网络要求输入和输出的维数都是固定的，不能任意改变。因此，当处理这一类和时序相关的问题时，就需要一种能力更强的模型。</p>
<p>循环神经网络（Recurrent Neural Network，RNN）是一类具有短期记忆能力的神经网络。在循环神经网络中，神经元不但可以接受其它神经元的信息，也可以接受自身的信息，形成具有环路的网络结构。换句话说：神经元的输出可以在下一个时间步直接作用到自身</p>
<img src="/2021/07/21/pytorch5/RNN%E5%9B%BE.png" class>

<p>通过简化图，我们看到RNN比传统的神经网络多了一个循环圈，这个循环表示的就是在下一个时间步（<strong>Time Step</strong>）上会返回作为输入的一部分，我们把RNN在时间点上展开，得到的图形如下：</p>
<img src="/2021/07/21/pytorch5/RNN%E5%B1%95%E5%BC%80.png" class>

<p>或者是：</p>
<img src="/2021/07/21/pytorch5/%E5%9F%BA%E7%A1%80%E7%9A%84RNN%E5%B1%95%E5%BC%80%E5%9B%BE.png" class>

<p>在不同的时间步，RNN的输入都将与之前的时间状态有关，$t_n$时刻网络的输出结果是该时刻的输入和所有历史共同作用的结果，这就达到了对时间序列建模的目的。</p>
<p>RNN的不同表示和功能可以通过下图看出：</p>
<img src="/2021/07/21/pytorch5/RNN%E5%8A%9F%E8%83%BD.png" class>

<ul>
<li>图1：固定长度的输入和输出 (e.g. 图像分类)</li>
<li>图2：序列输出 (e.g.图像转文字)</li>
<li>图3：数列输入 (e.g. 文本分类)</li>
<li>图4：异步的序列输入和输出(e.g.文本翻译).</li>
<li>图5：同步的序列输入和输出 (e.g. 根据视频的每一帧来对视频进行分类)</li>
</ul>
<h2 id="2-LSTM和GRU"><a href="#2-LSTM和GRU" class="headerlink" title="2. LSTM和GRU"></a>2. LSTM和GRU</h2><h3 id="2-1-LSTM的基础介绍"><a href="#2-1-LSTM的基础介绍" class="headerlink" title="2.1 LSTM的基础介绍"></a>2.1 LSTM的基础介绍</h3><p>假如现在有这样一个需求，根据现有文本预测下一个词语，比如<code>天上的云朵漂浮在__</code>，通过间隔不远的位置就可以预测出来词语是<code>天上</code>，但是对于其他一些句子，可能需要被预测的词语在前100个词语之前，那么此时由于间隔非常大，随着间隔的增加可能会导致真实的预测值对结果的影响变的非常小，而无法非常好的进行预测（RNN中的长期依赖问题（long-Term Dependencies））</p>
<p>那么为了解决这个问题需要<strong>LSTM</strong>（<strong>Long Short-Term Memory网络</strong>）</p>
<p>LSTM是一种RNN特殊的类型，可以学习长期依赖信息。在很多问题上，LSTM都取得相当巨大的成功，并得到了广泛的应用。</p>
<p>一个LSMT的单元就是下图中的一个绿色方框中的内容：</p>




<p>其中$\sigma$表示sigmod函数，其他符号的含义：</p>




<h3 id="2-2-LSTM的核心"><a href="#2-2-LSTM的核心" class="headerlink" title="2.2 LSTM的核心"></a>2.2 LSTM的核心</h3><img src="/2021/07/21/pytorch5/LSTM3.png" class>

<p>LSTM的核心在于单元（细胞）中的状态，也就是上图中最上面的那根线。</p>
<p>但是如果只有上面那一条线，那么没有办法实现信息的增加或者删除，所以在LSTM是通过一个叫做<code>门</code>的结构实现，门可以选择让信息通过或者不通过。</p>
<p>这个门主要是通过sigmoid和点乘（<code>pointwise multiplication</code>）实现的</p>
<img src="/2021/07/21/pytorch5/LSTM4.png" class>



<p>$sigmoid$的取值范围是在(0,1)之间，如果接近0表示不让任何信息通过，如果接近1表示所有的信息都会通过</p>
<h3 id="2-3-逐步理解LSTM"><a href="#2-3-逐步理解LSTM" class="headerlink" title="2.3 逐步理解LSTM"></a>2.3 逐步理解LSTM</h3><h4 id="2-3-1-遗忘门"><a href="#2-3-1-遗忘门" class="headerlink" title="2.3.1 遗忘门"></a>2.3.1 遗忘门</h4><p>遗忘门通过sigmoid函数来决定哪些信息会被遗忘</p>
<p>在下图就是$h_{t-1}和x_t$进行合并（concat）之后乘上权重和偏置，通过sigmoid函数，输出0-1之间的一个值，这个值会和前一次的细胞状态($C_{t-1}​$)进行点乘，从而决定遗忘或者保留</p>
<img src="/2021/07/21/pytorch5/%E6%98%93%E7%8E%8B%E9%97%A8.png" class>



<h4 id="2-3-2-输入门"><a href="#2-3-2-输入门" class="headerlink" title="2.3.2 输入门"></a>2.3.2 输入门</h4><img src="/2021/07/21/pytorch5/%E8%BE%93%E5%85%A5%E9%97%A8.png" class>

<p>下一步就是决定哪些新的信息会被保留，这个过程有两步：</p>
<ol>
<li>一个被称为<code>输入门</code>的sigmoid 层决定哪些信息会被更新</li>
<li><code>tanh</code>会创造一个新的候选向量$\widetilde{C}_{t}$，后续可能会被添加到细胞状态中</li>
</ol>
<p>例如：</p>
<p><code>我昨天吃了苹果，今天我想吃菠萝</code>，在这个句子中，通过遗忘门可以遗忘<code>苹果</code>,同时更新新的主语为<code>菠萝</code></p>
<p>现在就可以更新旧的细胞状态$C_{t-1}$为新的$C_{ t }​$ 了。</p>
<p>更新的构成很简单就是：</p>
<ol>
<li>旧的细胞状态和遗忘门的结果相乘</li>
<li>然后加上 输入门和tanh相乘的结果</li>
</ol>
<img src="/2021/07/21/pytorch5/LSTM-update.png" class>



<h4 id="2-3-3-输出门"><a href="#2-3-3-输出门" class="headerlink" title="2.3.3 输出门"></a>2.3.3 输出门</h4><p>最后，我们需要决定什么信息会被输出，也是一样这个输出经过变换之后会通过sigmoid函数的结果来决定那些细胞状态会被输出。</p>
<img src="/2021/07/21/pytorch5/%E8%BE%93%E5%87%BA%E9%97%A8.png" class>

<p>步骤如下：</p>
<ol>
<li>前一次的输出和当前时间步的输入的组合结果通过sigmoid函数进行处理得到$O_t$</li>
<li>更新后的细胞状态$C_t$会经过tanh层的处理，把数据转化到(-1,1)的区间</li>
<li>tanh处理后的结果和$O_t$进行相乘，把结果输出同时传到下一个LSTM的单元</li>
</ol>
<h3 id="2-4-GRU，LSTM的变形"><a href="#2-4-GRU，LSTM的变形" class="headerlink" title="2.4 GRU，LSTM的变形"></a>2.4 GRU，LSTM的变形</h3><p>GRU(Gated Recurrent Unit),是一种LSTM的变形版本， 它将遗忘和输入门组合成一个“更新门”。它还合并了单元状态和隐藏状态，并进行了一些其他更改，由于他的模型比标准LSTM模型简单，所以越来越受欢迎。</p>
<img src="/2021/07/21/pytorch5/GRU.png" class>



<p>LSTM内容参考地址：<a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">https://colah.github.io/posts/2015-08-Understanding-LSTMs/</a></p>
<h2 id="3-双向LSTM"><a href="#3-双向LSTM" class="headerlink" title="3. 双向LSTM"></a>3. 双向LSTM</h2><p>单向的 RNN，是根据前面的信息推出后面的，但有时候只看前面的词是不够的， 可能需要预测的词语和后面的内容也相关，那么此时需要一种机制，能够让模型不仅能够从前往后的具有记忆，还需要从后往前需要记忆。此时双向LSTM就可以帮助我们解决这个问题</p>
<img src="/2021/07/21/pytorch5/bidir_lstm.png" class>

<p>由于是双向LSTM，所以每个方向的LSTM都会有一个输出，最终的输出会有2部分，所以往往需要concat的操作</p>
<h1 id="循环神经网络在pytorch中的应用"><a href="#循环神经网络在pytorch中的应用" class="headerlink" title="循环神经网络在pytorch中的应用"></a>循环神经网络在pytorch中的应用</h1><h2 id="1-Pytorch中LSTM和GRU模块使用"><a href="#1-Pytorch中LSTM和GRU模块使用" class="headerlink" title="1. Pytorch中LSTM和GRU模块使用"></a>1. Pytorch中LSTM和GRU模块使用</h2><h3 id="1-1-LSTM介绍"><a href="#1-1-LSTM介绍" class="headerlink" title="1.1 LSTM介绍"></a>1.1 LSTM介绍</h3><p>LSTM和GRU都是由<code>torch.nn</code>提供</p>
<p>通过观察文档，可知LSMT的参数，</p>
<p><code>torch.nn.LSTM(input_size,hidden_size,num_layers,batch_first,dropout,bidirectional)</code></p>
<ol>
<li><code>input_size </code>：输入数据的形状，即embedding_dim</li>
<li><code>hidden_size</code>：隐藏层神经元的数量，即每一层有多少个LSTM单元</li>
<li><code>num_layer</code> ：即RNN的中LSTM单元的层数</li>
<li><code>batch_first</code>：默认值为False，输入的数据需要<code>[seq_len,batch,feature]</code>,如果为True，则为<code>[batch,seq_len,feature]</code></li>
<li><code>dropout</code>:dropout的比例，默认值为0。dropout是一种训练过程中让部分参数随机失活的一种方式，能够提高训练速度，同时能够解决过拟合的问题。这里是在LSTM的最后一层，对每个输出进行dropout</li>
<li><code>bidirectional</code>：是否使用双向LSTM,默认是False</li>
</ol>
<p>实例化LSTM对象之后,<strong>不仅需要传入数据，还需要前一次的h_0(前一次的隐藏状态)和c_0（前一次memory）</strong></p>
<p>即：<code>lstm(input,(h_0,c_0))</code></p>
<p>LSTM的默认输出为<code>output, (h_n, c_n)</code></p>
<ol>
<li><code>output</code>：<code>(seq_len, batch, num_directions * hidden_size)</code>—&gt;batch_first=False</li>
<li><code>h_n</code>:<code>(num_layers * num_directions, batch, hidden_size)</code></li>
<li><code>c_n</code>: <code>(num_layers * num_directions, batch, hidden_size)</code></li>
</ol>
<h2 id="1-2-LSTM使用示例"><a href="#1-2-LSTM使用示例" class="headerlink" title="1.2 LSTM使用示例"></a>1.2 LSTM使用示例</h2><p>假设数据输入为 input ,形状是<code>[10,20]</code>，假设embedding的形状是<code>[100,30]</code></p>
<p>则LSTM使用示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">batch_size =<span class="number">10</span></span><br><span class="line">seq_len = <span class="number">20</span></span><br><span class="line">embedding_dim = <span class="number">30</span></span><br><span class="line">word_vocab = <span class="number">100</span></span><br><span class="line">hidden_size = <span class="number">18</span></span><br><span class="line">num_layer = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#准备输入数据</span></span><br><span class="line"><span class="built_in">input</span> = torch.randint(low=<span class="number">0</span>,high=<span class="number">100</span>,size=(batch_size,seq_len))</span><br><span class="line"><span class="comment">#准备embedding</span></span><br><span class="line">embedding  = torch.nn.Embedding(word_vocab,embedding_dim)</span><br><span class="line">lstm = torch.nn.LSTM(embedding_dim,hidden_size,num_layer)</span><br><span class="line"></span><br><span class="line"><span class="comment">#进行mebed操作</span></span><br><span class="line">embed = embedding(<span class="built_in">input</span>) <span class="comment">#[10,20,30]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#转化数据为batch_first=False</span></span><br><span class="line">embed = embed.permute(<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>) <span class="comment">#[20,10,30]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化状态， 如果不初始化，torch默认初始值为全0</span></span><br><span class="line">h_0 = torch.rand(num_layer,batch_size,hidden_size)</span><br><span class="line">c_0 = torch.rand(num_layer,batch_size,hidden_size)</span><br><span class="line">output,(h_1,c_1) = lstm(embed,(h_0,c_0))</span><br><span class="line"><span class="comment">#output [20,10,1*18]</span></span><br><span class="line"><span class="comment">#h_1 [2,10,18]</span></span><br><span class="line"><span class="comment">#c_1 [2,10,18]</span></span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">122</span>]: output.size()</span><br><span class="line">Out[<span class="number">122</span>]: torch.Size([<span class="number">20</span>, <span class="number">10</span>, <span class="number">18</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: h_1.size()</span><br><span class="line">Out[<span class="number">123</span>]: torch.Size([<span class="number">2</span>, <span class="number">10</span>, <span class="number">18</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">124</span>]: c_1.size()</span><br><span class="line">Out[<span class="number">124</span>]: torch.Size([<span class="number">2</span>, <span class="number">10</span>, <span class="number">18</span>])</span><br></pre></td></tr></table></figure>

<p>通过前面的学习，我们知道，最后一次的h_1应该和output的最后一个time step的输出是一样的</p>
<p>通过下面的代码，我们来验证一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">179</span>]: a = output[-<span class="number">1</span>,:,:]</span><br><span class="line"></span><br><span class="line">In [<span class="number">180</span>]: a.size()</span><br><span class="line">Out[<span class="number">180</span>]: torch.Size([<span class="number">10</span>, <span class="number">18</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">183</span>]: b.size()</span><br><span class="line">Out[<span class="number">183</span>]: torch.Size([<span class="number">10</span>, <span class="number">18</span>])</span><br><span class="line">In [<span class="number">184</span>]: a == b</span><br><span class="line">Out[<span class="number">184</span>]:</span><br><span class="line">tensor([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">       dtype=torch.uint8)</span><br></pre></td></tr></table></figure>

<h3 id="1-3-GRU的使用示例"><a href="#1-3-GRU的使用示例" class="headerlink" title="1.3 GRU的使用示例"></a>1.3 GRU的使用示例</h3><p>GRU模块<code>torch.nn.GRU</code>，和LSTM的参数相同，含义相同，具体可参考文档</p>
<p>但是输入只剩下<code>gru(input,h_0)</code>，输出为<code>output, h_n</code></p>
<p>其形状为：</p>
<ol>
<li><code>output</code>:<code>(seq_len, batch, num_directions * hidden_size)</code></li>
<li><code>h_n</code>:<code>(num_layers * num_directions, batch, hidden_size)</code></li>
</ol>
<p>大家可以使用上述代码，观察GRU的输出形式</p>
<h3 id="1-4-双向LSTM"><a href="#1-4-双向LSTM" class="headerlink" title="1.4 双向LSTM"></a>1.4 双向LSTM</h3><p>如果需要使用双向LSTM，则在实例化LSTM的过程中，需要把LSTM中的bidriectional设置为True，同时h_0和c_0使用num_layer*2</p>
<p>观察效果，输出为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">batch_size =<span class="number">10</span> <span class="comment">#句子的数量</span></span><br><span class="line">seq_len = <span class="number">20</span>  <span class="comment">#每个句子的长度</span></span><br><span class="line">embedding_dim = <span class="number">30</span>  <span class="comment">#每个词语使用多长的向量表示</span></span><br><span class="line">word_vocab = <span class="number">100</span>  <span class="comment">#词典中词语的总数</span></span><br><span class="line">hidden_size = <span class="number">18</span>  <span class="comment">#隐层中lstm的个数</span></span><br><span class="line">num_layer = <span class="number">2</span>  <span class="comment">#多少个隐藏层</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = torch.randint(low=<span class="number">0</span>,high=<span class="number">100</span>,size=(batch_size,seq_len))</span><br><span class="line">embedding  = torch.nn.Embedding(word_vocab,embedding_dim)</span><br><span class="line">lstm = torch.nn.LSTM(embedding_dim,hidden_size,num_layer,bidirectional=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">embed = embedding(<span class="built_in">input</span>) <span class="comment">#[10,20,30]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#转化数据为batch_first=False</span></span><br><span class="line">embed = embed.permute(<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>) <span class="comment">#[20,10,30]</span></span><br><span class="line">h_0 = torch.rand(num_layer*<span class="number">2</span>,batch_size,hidden_size)</span><br><span class="line">c_0 = torch.rand(num_layer*<span class="number">2</span>,batch_size,hidden_size)</span><br><span class="line">output,(h_1,c_1) = lstm(embed,(h_0,c_0))</span><br><span class="line"></span><br><span class="line">In [<span class="number">135</span>]: output.size()</span><br><span class="line">Out[<span class="number">135</span>]: torch.Size([<span class="number">20</span>, <span class="number">10</span>, <span class="number">36</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: h_1.size()</span><br><span class="line">Out[<span class="number">136</span>]: torch.Size([<span class="number">4</span>, <span class="number">10</span>, <span class="number">18</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">137</span>]: c_1.size()</span><br><span class="line">Out[<span class="number">137</span>]: torch.Size([<span class="number">4</span>, <span class="number">10</span>, <span class="number">18</span>])</span><br></pre></td></tr></table></figure>

<p>在单向LSTM中，最后一个time step的输出的前hidden_size个和最后一层隐藏状态h_1的输出相同，那么双向LSTM呢？</p>
<p>双向LSTM中：</p>
<p><strong>output：按照正反计算的结果顺序在第2个维度进行拼接，正向第一个拼接反向的最后一个输出</strong></p>
<p><strong>hidden state:按照得到的结果在第0个维度进行拼接，正向第一个之后接着是反向第一个</strong></p>
<ol>
<li><p>前向的LSTM中，最后一个time step的输出的前hidden_size个和最后一层向前传播h_1的输出相同</p>
<ul>
<li>示例：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-1是前向LSTM的最后一个，前18是前hidden_size个</span></span><br><span class="line">In [<span class="number">188</span>]: a = output[-<span class="number">1</span>,:,:<span class="number">18</span>]  <span class="comment">#前项LSTM中最后一个time step的output</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">189</span>]: b = h_1[-<span class="number">2</span>,:,:]  <span class="comment">#倒数第二个为前向</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">190</span>]: a.size()</span><br><span class="line">Out[<span class="number">190</span>]: torch.Size([<span class="number">10</span>, <span class="number">18</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">191</span>]: b.size()</span><br><span class="line">Out[<span class="number">191</span>]: torch.Size([<span class="number">10</span>, <span class="number">18</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">192</span>]: a == b</span><br><span class="line">Out[<span class="number">192</span>]:</span><br><span class="line">tensor([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">       dtype=torch.uint8)</span><br></pre></td></tr></table></figure>

</li>
<li><p>后向LSTM中，最后一个time step的输出的后hidden_size个和最后一层后向传播的h_1的输出相同</p>
<ul>
<li><p>示例</p>
</li>
<li><pre><code class="python">#0 是反向LSTM的最后一个，后18是后hidden_size个
In [196]: c = output[0,:,18:]  #后向LSTM中的最后一个输出

In [197]: d = h_1[-1,:,:] #后向LSTM中的最后一个隐藏层状态

In [198]: c == d
Out[198]:
tensor([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]],
       dtype=torch.uint8)
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="1-5-LSTM和GRU的使用注意点"><a href="#1-5-LSTM和GRU的使用注意点" class="headerlink" title="1.5 LSTM和GRU的使用注意点"></a>1.5 LSTM和GRU的使用注意点</h3><ol>
<li>第一次调用之前，需要初始化隐藏状态，如果不初始化，默认创建全为0的隐藏状态</li>
<li>往往会使用LSTM or GRU 的输出的最后一维的结果，来代表LSTM、GRU对文本处理的结果，其形状为<code>[batch,  num_directions*hidden_size]</code>。<ol>
<li>并不是所有模型都会使用最后一维的结果</li>
<li>如果实例化LSTM的过程中，batch_first=False,则<code>output[-1] or output[-1,:,:]</code>可以获取最后一维</li>
<li>如果实例化LSTM的过程中，batch_first=True,则<code>output[:,-1,:]</code>可以获取最后一维</li>
</ol>
</li>
<li>如果结果是<code>(seq_len, batch_size, num_directions * hidden_size)</code>,需要把它转化为<code>(batch_size,seq_len, num_directions * hidden_size)</code>的形状，不能够不是view等变形的方法，需要使用<code>output.permute(1,0,2)</code>，即交换0和1轴，实现上述效果</li>
<li>使用双向LSTM的时候，往往会分别使用每个方向最后一次的output，作为当前数据经过双向LSTM的结果<ul>
<li>即：<code>torch.cat([h_1[-2,:,:],h_1[-1,:,:]],dim=-1)</code></li>
<li>最后的表示的size是<code>[batch_size,hidden_size*2]</code></li>
</ul>
</li>
<li>上述内容在GRU中同理</li>
</ol>
]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch数据集加载</title>
    <url>/2021/07/18/pytorch3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录下pytorch数据集加载方法  </p>
<span id="more"></span> 

<h1 id="Pytorch中的数据加载"><a href="#Pytorch中的数据加载" class="headerlink" title="Pytorch中的数据加载"></a>Pytorch中的数据加载</h1><h2 id="1-模型中使用数据加载器的目的"><a href="#1-模型中使用数据加载器的目的" class="headerlink" title="1. 模型中使用数据加载器的目的"></a>1. 模型中使用数据加载器的目的</h2><p>在前面的线性回归模型中，我们使用的数据很少，所以直接把全部数据放到模型中去使用。</p>
<p>但是在深度学习中，数据量通常是都非常多，非常大的，如此大量的数据，不可能一次性的在模型中进行向前的计算和反向传播，经常我们会对整个数据进行随机的打乱顺序，把数据处理成一个个的batch，同时还会对数据进行预处理。</p>
<p>所以，接下来我们来学习pytorch中的数据加载的方法</p>
<h2 id="2-数据集类"><a href="#2-数据集类" class="headerlink" title="2. 数据集类"></a>2. 数据集类</h2><h3 id="2-1-Dataset基类介绍"><a href="#2-1-Dataset基类介绍" class="headerlink" title="2.1 Dataset基类介绍"></a>2.1 Dataset基类介绍</h3><p>在torch中提供了数据集的基类<code>torch.utils.data.Dataset</code>，继承这个基类，我们能够非常快速的实现对数据的加载。</p>
<p><code>torch.utils.data.Dataset</code>的源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dataset</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;An abstract class representing a Dataset.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    All other datasets should subclass it. All subclasses should override</span></span><br><span class="line"><span class="string">    ``__len__``, that provides the size of the dataset, and ``__getitem__``,</span></span><br><span class="line"><span class="string">    supporting integer indexing in range from 0 to len(self) exclusive.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> ConcatDataset([self, other])</span><br></pre></td></tr></table></figure>

<p>可知：我们需要在自定义的数据集类中继承Dataset类，同时还需要实现两个方法：</p>
<ol>
<li><code>__len__</code>方法，能够实现通过全局的<code>len()</code>方法获取其中的元素个数</li>
<li><code>__getitem__</code>方法，能够通过传入索引的方式获取数据，例如通过<code>dataset[i]</code>获取其中的第<code>i</code>条数据</li>
</ol>
<h3 id="2-2-数据加载案例"><a href="#2-2-数据加载案例" class="headerlink" title="2.2 数据加载案例"></a>2.2 数据加载案例</h3><p>下面通过一个例子来看看如何使用Dataset来加载数据</p>
<p>数据来源：<code>http://archive.ics.uci.edu/ml/datasets/SMS+Spam+Collection</code></p>
<p>数据介绍：SMS Spam Collection是用于骚扰短信识别的经典数据集，完全来自真实短信内容，包括4831条正常短信和747条骚扰短信。正常短信和骚扰短信保存在一个文本文件中。 每行完整记录一条短信内容，每行开头通过ham和spam标识正常短信和骚扰短信</p>
<p>数据实例：</p>
<img src="/2021/07/18/pytorch3/dataset%E6%95%B0%E6%8D%AE%E7%A4%BA%E4%BE%8B.png" class>

<p>实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset,DataLoader</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data_path = <span class="string">r&quot;data\SMSSpamCollection&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CifarDataset</span>(<span class="params">Dataset</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        lines = <span class="built_in">open</span>(data_path,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">        <span class="comment">#对数据进行处理，前4个为label，后面的为短信内容</span></span><br><span class="line">        lines = [[i[:<span class="number">4</span>].strip(),i[<span class="number">4</span>:].strip()] <span class="keyword">for</span> i <span class="keyword">in</span> lines]</span><br><span class="line">        <span class="comment">#转化为dataFrame</span></span><br><span class="line">        self.df = pd.DataFrame(lines,columns=[<span class="string">&quot;label&quot;</span>,<span class="string">&quot;sms&quot;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        single_item = self.df.iloc[index,:]</span><br><span class="line">        <span class="keyword">return</span> single_item.values[<span class="number">0</span>],single_item.values[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.df.shape[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>之后对Dataset进行实例化，可以跌倒获取其中的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = CifarDataset()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(d)):</span><br><span class="line">    <span class="built_in">print</span>(i,d[i])</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line"><span class="number">5571</span> (<span class="string">&#x27;ham&#x27;</span>, <span class="string">&#x27;Pity, * was in mood for that. So...any other suggestions?&#x27;</span>)</span><br><span class="line"><span class="number">5572</span> (<span class="string">&#x27;ham&#x27;</span>, <span class="string">&quot;The guy did some bitching but I acted like i&#x27;d be interested in buying something else next week and he gave it to us for free&quot;</span>)</span><br><span class="line"><span class="number">5573</span> (<span class="string">&#x27;ham&#x27;</span>, <span class="string">&#x27;Rofl. Its true to its name&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="3-迭代数据集"><a href="#3-迭代数据集" class="headerlink" title="3. 迭代数据集"></a>3. 迭代数据集</h2><p>使用上述的方法能够进行数据的读取，但是其中还有很多内容没有实现：</p>
<ul>
<li>批处理数据（Batching the data）</li>
<li>打乱数据（Shuffling the data）</li>
<li>使用多线程 <code>multiprocessing</code> 并行加载数据。</li>
</ul>
<p>在pytorch中<code>torch.utils.data.DataLoader</code>提供了上述的所用方法</p>
<p><code>DataLoader</code>的使用方法示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">dataset = CifarDataset()</span><br><span class="line">data_loader = DataLoader(dataset=dataset,batch_size=<span class="number">10</span>,shuffle=<span class="literal">True</span>,num_workers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#遍历，获取其中的每个batch的结果</span></span><br><span class="line"><span class="keyword">for</span> index, (label, context) <span class="keyword">in</span> <span class="built_in">enumerate</span>(data_loader):</span><br><span class="line">    <span class="built_in">print</span>(index,label,context)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>其中参数含义：</p>
<ol>
<li>dataset：提前定义的dataset的实例</li>
<li>batch_size:传入数据的batch的大小，常用128,256等等</li>
<li>shuffle：bool类型，表示是否在每次获取数据的时候提前打乱数据</li>
<li><code>num_workers</code>:加载数据的线程数</li>
</ol>
<p>数据迭代器的返回结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">555 (&#39;spam&#39;, &#39;ham&#39;, &#39;spam&#39;, &#39;ham&#39;, &#39;ham&#39;, &#39;ham&#39;, &#39;ham&#39;, &#39;spam&#39;, &#39;ham&#39;, &#39;ham&#39;) (&#39;URGENT! We are trying to contact U. Todays draw shows that you have won a £800 prize GUARANTEED. Call 09050003091 from....&quot;, &#39;swhrt how u dey,hope ur ok, tot about u 2day.love n miss.take care.&#39;)</span><br><span class="line">***********************************************************************************</span><br><span class="line">556 (&#39;ham&#39;, &#39;ham&#39;, &#39;ham&#39;, &#39;ham&#39;, &#39;ham&#39;, &#39;ham&#39;, &#39;ham&#39;, &#39;ham&#39;, &#39;ham&#39;, &#39;spam&#39;) (&#39;He telling not to tell any one. If so treat for me hi hi hi&#39;, &#39;Did u got that persons story&#39;, &quot;Don kn....1000 cash prize or a prize worth £5000&#39;)</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><code>len(dataset) = 数据集的样本数</code></li>
<li><code>len(dataloader) = math.ceil(样本数/batch_size) 即向上取整</code> </li>
</ol>
<h2 id="4-pytorch自带的数据集"><a href="#4-pytorch自带的数据集" class="headerlink" title="4 pytorch自带的数据集"></a>4 pytorch自带的数据集</h2><p>pytorch中自带的数据集由两个上层api提供，分别是<code>torchvision</code>和<code>torchtext</code></p>
<p>其中：</p>
<ol>
<li><code>torchvision</code>提供了对图片数据处理相关的api和数据<ul>
<li>数据位置：<code>torchvision.datasets</code>，例如：<code>torchvision.datasets.MNIST</code>(手写数字图片数据)</li>
</ul>
</li>
<li><code>torchtext</code>提供了对文本数据处理相关的API和数据<ul>
<li>数据位置：<code>torchtext.datasets</code>,例如：<code>torchtext.datasets.IMDB（电影</code>评论文本数据）</li>
</ul>
</li>
</ol>
<p>下面我们以Mnist手写数字为例，来看看pytorch如何加载其中自带的数据集</p>
<p>使用方法和之前一样：</p>
<ol>
<li>准备好Dataset实例</li>
<li>把dataset交给dataloder 打乱顺序，组成batch</li>
</ol>
<h3 id="4-1-torchversion-datasets"><a href="#4-1-torchversion-datasets" class="headerlink" title="4.1 torchversion.datasets"></a>4.1 torchversion.datasets</h3><p><code>torchversoin.datasets</code>中的数据集类（比如<code>torchvision.datasets.MNIST</code>）,都是继承自<code>Dataset</code></p>
<p>意味着：直接对<code>torchvision.datasets.MNIST</code>进行实例化就可以得到<code>Dataset</code>的实例</p>
<p>但是MNIST API中的参数需要注意一下：</p>
<p><code> torchvision.datasets.MNIST(root=&#39;/files/&#39;, train=True, download=True, transform=)</code></p>
<ol>
<li><code>root</code>参数表示数据存放的位置</li>
<li><code>train：</code>bool类型，表示是使用训练集的数据还是测试集的数据</li>
<li><code>download：</code>bool类型，表示是否需要下载数据到root目录</li>
<li><code>transform:</code>实现的对图片的处理函数</li>
</ol>
<h3 id="4-2-MNIST数据集的介绍"><a href="#4-2-MNIST数据集的介绍" class="headerlink" title="4.2 MNIST数据集的介绍"></a>4.2 MNIST数据集的介绍</h3><p>数据集的原始地址：<code>http://yann.lecun.com/exdb/mnist/</code></p>
<p>MNIST是由<code>Yann LeCun</code>等人提供的免费的图像识别的数据集，其中包括60000个训练样本和10000个测试样本，其中图拍了的尺寸已经进行的标准化的处理，都是黑白的图像，大小为<code>28X28</code></p>
<p>执行代码，下载数据，观察数据类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.MNIST(root=<span class="string">&quot;./data&quot;</span>,train=<span class="literal">True</span>,download=<span class="literal">True</span>,transform=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dataset[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p>下载的数据如下：</p>


<p>代码输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Downloading http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz</span><br><span class="line">Downloading http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz</span><br><span class="line">Downloading http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz</span><br><span class="line">Downloading http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz</span><br><span class="line">Processing...</span><br><span class="line">Done!</span><br><span class="line">(&lt;PIL.Image.Image image mode=L size=28x28 at <span class="number">0x18D303B9C18</span>&gt;, tensor(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>



<p>可以其中数据集返回了两条数据，可以猜测为图片的数据和目标值</p>
<p>返回值的第0个为Image类型，可以调用show() 方法打开，发现为手写数字5</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.MNIST(root=<span class="string">&quot;./data&quot;</span>,train=<span class="literal">True</span>,download=<span class="literal">True</span>,transform=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dataset[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">img = dataset[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">img.show() <span class="comment">#打开图片</span></span><br></pre></td></tr></table></figure>

<p>图片如下：</p>
<img src="/2021/07/18/pytorch3/MNIST-dataset-5.png" class>  

<p>由上可知：返回值为<code>(图片，目标值)</code>,这个结果也可以通过观察源码得到</p>
]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实验课作业一——进程同步</title>
    <url>/2021/04/11/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&ensp;&ensp;&ensp;&ensp;linux模拟进程同步问题。</p>
<span id="more"></span>
<h1 id="一、实验概述"><a href="#一、实验概述" class="headerlink" title="一、实验概述"></a>一、实验概述</h1><h2 id="1、实验目的及要求"><a href="#1、实验目的及要求" class="headerlink" title="1、实验目的及要求"></a>1、实验目的及要求</h2><p>（1）了解进程同步和互斥的含义<br>（2）掌握操作系统进程同步的基本原理<br>（3）理解基本进程同步模型，学会使用进程同步机制<br>（4）能够编码实现进程同步问题  </p>
<h2 id="2、实验内容"><a href="#2、实验内容" class="headerlink" title="2、实验内容"></a>2、实验内容</h2><p>&ensp;&ensp;&ensp;&ensp;阅览室读书问题：假定一个阅览室最多可容纳10人，读者进入和离开阅览室时都必须在阅览室门口的一个登记表上进行登记，而且每次只允许一人进行登记操作。请用信号量实现上述进程的同步问题。（假设读者有20个每个读者阅读时间是随机的）。<br>(在ubuntu/windows环境下，编码实现）</p>
<h2 id="3、基本理论介绍"><a href="#3、基本理论介绍" class="headerlink" title="3、基本理论介绍"></a>3、基本理论介绍</h2><p>（1）P、V操作<br>&ensp;&ensp;&ensp;&ensp;PV操作由P操作原语和V操作原语组成（原语是不可中断的过程），对信号量进行操作，具体定义如下：<br>&ensp;&ensp;&ensp;&ensp;P（S）：①将信号量S的值减1，即S=S-1；<br>②如果S&gt;0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。<br>&ensp;&ensp;&ensp;&ensp;V（S）：①将信号量S的值加1，即S=S+1；<br>&ensp;&ensp;&ensp;&ensp;②如果S&gt;0，则该进程继续执行；否则释放队列中第一个等待信号量的进程。<br>（2）信号量<br>&ensp;&ensp;&ensp;&ensp;信号量（semaphore）的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程。信号量的值与相应资源的使用情况有关。当它的值大于0时，表示当前可用资源的数量；当它的值小于0时，其绝对值表示等待使用该资源的进程个数。注意，信号量的值仅能由PV操作来改变。<br>&ensp;&ensp;&ensp;&ensp;一般来说，信号量S&gt;0时，S表示可用资源的数量。执行一次P操作意味着请求分配一个单位资源，因此S的值减1；当S&lt;0时，表示已经没有可用资源，请求者必须等待别的进程释放该类资源，它才能运行下去。而执行一个V操作意味着释放一个单位资源，因此S的值加1；若S&lt;0，表示有某些进程正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去。  </p>
<h1 id="二、实验过程"><a href="#二、实验过程" class="headerlink" title="二、实验过程"></a>二、实验过程</h1><h2 id="1、分析题目"><a href="#1、分析题目" class="headerlink" title="1、分析题目"></a>1、分析题目</h2><p>&ensp;&ensp;&ensp;&ensp;由题知：阅览室的座位数代表资源数，登记区为临界资源mutex，出和入用信号量empty和full来记录，其中empty的初始值为10，full的初始值为0。<br>&ensp;&ensp;&ensp;&ensp;进入时：<br>&ensp;&ensp;&ensp;&ensp;①等待阅览室有空座位，即empty&gt;0，分配资源<br>&ensp;&ensp;&ensp;&ensp;②进入登记区，等待临界资源mutex<br>&ensp;&ensp;&ensp;&ensp;③进行登记，进入阅览室，阅览室座位减少，即释放一个full<br>&ensp;&ensp;&ensp;&ensp;退出时：<br>&ensp;&ensp;&ensp;&ensp;①首先确保阅览室内有人正在阅读，即等待full（读者先阅读若干时间）<br>&ensp;&ensp;&ensp;&ensp;②读者想要退出，进入登记区，等待临界资源mutex<br>&ensp;&ensp;&ensp;&ensp;③进行登记，退出阅览室，阅览室座位增加，即释放一个empty  </p>
<h2 id="2、代码结构"><a href="#2、代码结构" class="headerlink" title="2、代码结构"></a>2、代码结构</h2><p>&ensp;&ensp;&ensp;&ensp;①void IN_fun(void* arg)进入的函数<br>&ensp;&ensp;&ensp;&ensp;②void OUT_fun(void* arg)退出的函数<br>&ensp;&ensp;&ensp;&ensp;③int main()主函数  </p>
<h2 id="3、程序伪代码"><a href="#3、程序伪代码" class="headerlink" title="3、程序伪代码"></a>3、程序伪代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Void IN_fun()&#123;</span><br><span class="line">Wait(empty);</span><br><span class="line">Wait(mutex);</span><br><span class="line">登记</span><br><span class="line">Signal(mutex);</span><br><span class="line">Signal(full);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Void OUT_fun()&#123;</span><br><span class="line">阅读</span><br><span class="line">Wait(full);</span><br><span class="line">Wait(mutex);</span><br><span class="line">Signal(mutex);</span><br><span class="line">Signal(empty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、实验结果"><a href="#三、实验结果" class="headerlink" title="三、实验结果"></a>三、实验结果</h1><h2 id="1、功能实现"><a href="#1、功能实现" class="headerlink" title="1、功能实现"></a>1、功能实现</h2><p>&ensp;&ensp;&ensp;&ensp;该程序用进程同步模拟了阅览室的人员进出问题。</p>
<h2 id="2、结果测试"><a href="#2、结果测试" class="headerlink" title="2、结果测试"></a>2、结果测试</h2><p><img src="/2021/04/11/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/1.png" alt="1"><br><img src="/2021/04/11/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/2.png" alt="2"></p>
<h2 id="3、结果分析"><a href="#3、结果分析" class="headerlink" title="3、结果分析"></a>3、结果分析</h2><p>&ensp;&ensp;&ensp;&ensp;实验结果如上图所示，剩余资源和读者进出都能够正确提示。实现了进程同步。</p>
<h1 id="四、心得体会"><a href="#四、心得体会" class="headerlink" title="四、心得体会"></a>四、心得体会</h1><p>&ensp;&ensp;&ensp;&ensp;略。</p>
<h1 id="五、代码附录"><a href="#五、代码附录" class="headerlink" title="五、代码附录"></a>五、代码附录</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READERS_NUM 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_SIZE 11</span></span><br><span class="line"><span class="keyword">int</span> pool[POOL_SIZE];</span><br><span class="line"><span class="keyword">int</span> out = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> in = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">sem_t</span> empty;</span><br><span class="line"><span class="keyword">sem_t</span> full;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IN_fun</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		sem_wait(&amp;empty);</span><br><span class="line">		pthread_mutex_lock(&amp;mutex);</span><br><span class="line">		in = (in+<span class="number">1</span>)%POOL_SIZE;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;READERS %d entered the reading room\n&quot;</span>,(<span class="keyword">int</span>)(<span class="keyword">long</span>)arg);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d seats are empty\n&quot;</span>,(out-in+POOL_SIZE<span class="number">-1</span>)%POOL_SIZE);</span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">		sem_post(&amp;full);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OUT_fun</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		sleep(<span class="number">10</span>);</span><br><span class="line">		sem_wait(&amp;full);</span><br><span class="line">		pthread_mutex_lock(&amp;mutex);</span><br><span class="line">		out = (out + <span class="number">1</span>)%POOL_SIZE;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;READER %d quited the room\n&quot;</span>,(<span class="keyword">int</span>)(<span class="keyword">long</span>)arg);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d seats are empty\n&quot;</span>,(out-in+POOL_SIZE<span class="number">-1</span>)%POOL_SIZE);</span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">		sem_post(&amp;empty);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">pthread_t</span> IN_id[READERS_NUM];</span><br><span class="line">	<span class="keyword">pthread_t</span> OUT_id[READERS_NUM];</span><br><span class="line">	pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">int</span> ret = sem_init(&amp;empty,<span class="number">0</span>,POOL_SIZE<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;sem_init error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ret = sem_init(&amp;full,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;sem_init error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; READERS_NUM;i++)&#123;</span><br><span class="line">		ret = pthread_create(&amp;IN_id[i],<span class="literal">NULL</span>,(<span class="keyword">void</span>*)IN_fun,(<span class="keyword">void</span>*)(<span class="keyword">long</span>)i);</span><br><span class="line">		<span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;IN_id error&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		ret = pthread_create(&amp;OUT_id[i],<span class="literal">NULL</span>,(<span class="keyword">void</span>*)OUT_fun,(<span class="keyword">void</span>*)(<span class="keyword">long</span>)i);</span><br><span class="line">		<span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;OUT_id error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; READERS_NUM;i++)&#123;</span><br><span class="line">		pthread_join(IN_id[i],<span class="literal">NULL</span>);</span><br><span class="line">		pthread_join(OUT_id[i],<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>实验课作业</tag>
      </tags>
  </entry>
  <entry>
    <title>二维矩阵前缀和计算方法</title>
    <url>/2021/05/07/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;二维矩阵前缀和的思考与实现。</p>
<span id="more"></span>

<h1 id="一、一维数组前缀和"><a href="#一、一维数组前缀和" class="headerlink" title="一、一维数组前缀和"></a>一、一维数组前缀和</h1><p>&ensp;&ensp;&ensp;&ensp;首先在解答二维矩阵的前缀和的问题之前，先复习一下一维的前缀和</p>
<h2 id="1-1-前缀和的介绍"><a href="#1-1-前缀和的介绍" class="headerlink" title="1.1 前缀和的介绍"></a>1.1 前缀和的介绍</h2><p>&ensp;&ensp;&ensp;&ensp;假设我们有一个字符串ABCDE，什么是这个单词的前缀，A、AB、ABC、ABCD、ABCDE就是这个单词的前缀，就是从第一个字母开始，依次往后拼接。E、ED、EDC、EDCB、EDCBA被称为这个单词的后缀。<br>&ensp;&ensp;&ensp;&ensp;那么对于一个数组的前缀，例如数组a = [1,2,3,4,5]，我们维护一个由前缀的和组成的数组sum，sum[i]表示数组中a[0]~ a[i] 的和。<br>&ensp;&ensp;&ensp;&ensp;sum[0] = a[0]<br>&ensp;&ensp;&ensp;&ensp;sum[1] = a[0] + a[1]<br>&ensp;&ensp;&ensp;&ensp;sum[2] = a[0] + a[1] + a[2]<br>&ensp;&ensp;&ensp;&ensp;sum[3] = a[0] + a[1] + a[2] + a[3]<br>&ensp;&ensp;&ensp;&ensp;sum[4] = a[0] + a[1] + a[2] + a[3] + a[4]<br>&ensp;&ensp;&ensp;&ensp;sum数组就被称为前缀和数组。<br>&ensp;&ensp;&ensp;&ensp;用在整数数组中，sum数组即为前n个整数的和。  </p>
<h2 id="1-2-前缀和的作用"><a href="#1-2-前缀和的作用" class="headerlink" title="1.2 前缀和的作用"></a>1.2 前缀和的作用</h2><p>&ensp;&ensp;&ensp;&ensp;前缀和的最主要目的是求子数组的和的大小。例如元素a[1]到a[3]的和。可以用sum[3] - sum[0]表示。<br>&ensp;&ensp;&ensp;&ensp;用此法求多个子数组的和，因为只需要遍历一遍数组，记录下sum数组，所以复杂度为O(n)，计算sum[r] - sum[l]的复杂度为O(1)，可以忽略不计，大大提升了需要计算多个子数组和时的效率。<br>&ensp;&ensp;&ensp;&ensp;注意：这里sum中的i表示的是前i个数的和，不是下标，因为题目中需要用到前0个数的和。</p>
<h2 id="1-3-一维前缀和举例"><a href="#1-3-一维前缀和举例" class="headerlink" title="1.3 一维前缀和举例"></a>1.3 一维前缀和举例</h2><p><strong>例题1：</strong>   </p>
<p>输入一个长度为 n 的整数序列。</p>
<p>接下来再输入 m 个询问，每个询问输入一对 l,r。</p>
<p>对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。</p>
<p><strong>输入格式</strong><br>第一行包含两个整数 n 和 m。</p>
<p>第二行包含 n 个整数，表示整数数列。</p>
<p>接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。</p>
<p><strong>输出格式</strong><br>共 m 行，每行输出一个询问的结果。</p>
<p><strong>数据范围</strong><br>1≤l≤r≤n,<br>1≤n,m≤100000,<br>−1000≤数列中元素的值≤1000  </p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 3  </span><br><span class="line">2 1 3 6 4  </span><br><span class="line">1 2  </span><br><span class="line">1 3  </span><br><span class="line">2 4  </span><br></pre></td></tr></table></figure>
<p><strong>输出样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3  </span><br><span class="line">6  </span><br><span class="line">10 </span><br></pre></td></tr></table></figure>

<p><strong>代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> s[n+<span class="number">1</span>];</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        s[i] = s[i<span class="number">-1</span>] + a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s[y] - s[x<span class="number">-1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;思想和相关代码的实现都非常简单，但是如果简单对给出的每一组数据都采用从a[l]到a[r]累加求和的方式，复杂度会由O(m+n)上升为O(mn)，导致部分样例超时无法通过。</p>
<h1 id="二、二维矩阵前缀和"><a href="#二、二维矩阵前缀和" class="headerlink" title="二、二维矩阵前缀和"></a>二、二维矩阵前缀和</h1><h2 id="2-1-问题提出"><a href="#2-1-问题提出" class="headerlink" title="2.1 问题提出"></a>2.1 问题提出</h2><p><strong>例题二：</strong><br>输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。</p>
<p>对于每个询问输出子矩阵中所有数的和。</p>
<p><strong>输入格式</strong><br>第一行包含三个整数 n，m，q。</p>
<p>接下来 n 行，每行包含 m 个整数，表示整数矩阵。</p>
<p>接下来 q 行，每行包含四个整数 x1,y1,x2,y2，表示一组询问。</p>
<p><strong>输出格式</strong><br>共 q 行，每行输出一个询问的结果。</p>
<p><strong>数据范围</strong><br>1≤n,m≤1000,<br>1≤q≤200000,<br>1≤x1≤x2≤n,<br>1≤y1≤y2≤m,<br>−1000≤矩阵内元素的值≤1000  </p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4 3  </span><br><span class="line">1 7 2 4  </span><br><span class="line">3 6 2 8  </span><br><span class="line">2 1 2 3  </span><br><span class="line">1 1 2 2   </span><br><span class="line">2 1 3 4  </span><br><span class="line">1 3 3 4  </span><br></pre></td></tr></table></figure>
<p><strong>输出样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">17</span><br><span class="line">27</span><br><span class="line">21</span><br></pre></td></tr></table></figure>

<h2 id="2-2-问题思考"><a href="#2-2-问题思考" class="headerlink" title="2.2 问题思考"></a>2.2 问题思考</h2><p>&ensp;&ensp;&ensp;&ensp;要求子矩阵的和，很容易想到类比到一维数组的前缀和，使用相同的方式解决。在使用前缀和解决求子矩阵和的过程中，需要解决两个问题：<br>&ensp;&ensp;&ensp;&ensp;1）如何计算前缀和矩阵；<br>&ensp;&ensp;&ensp;&ensp;2）如何利用前缀和矩阵，计算某一个子矩阵的和。<br>&ensp;&ensp;&ensp;&ensp;通过解决这两个问题，便可以得到一个关于s[x][y]的递推式和答案的递推式，通过这两个递推式便能够以一个较低的复杂度解决相关问题。<br>&ensp;&ensp;&ensp;&ensp;下面依次来解决这两个问题。 </p>
<h2 id="2-3-使用容斥原理解决二维矩阵前缀和问题"><a href="#2-3-使用容斥原理解决二维矩阵前缀和问题" class="headerlink" title="2.3 使用容斥原理解决二维矩阵前缀和问题"></a>2.3 使用容斥原理解决二维矩阵前缀和问题</h2><h3 id="1）计算前缀和矩阵"><a href="#1）计算前缀和矩阵" class="headerlink" title="1）计算前缀和矩阵"></a>1）计算前缀和矩阵</h3><p>&ensp;&ensp;&ensp;&ensp;为了便于观察，首先画出样例给出的前缀和矩阵和原矩阵的示意图,如下：<br><img src="/2021/05/07/%E5%89%8D%E7%BC%80%E5%92%8C/%E5%89%8D%E7%BC%80%E5%92%8C%E7%9F%A9%E9%98%B5%E5%92%8C%E5%8E%9F%E7%9F%A9%E9%98%B5.png" alt="前缀和和原矩阵">  </p>
<p>&ensp;&ensp;&ensp;&ensp;对于这样的问题，想到用容斥原理来计算s[x][y]的值。  </p>
<p>&ensp;&ensp;&ensp;&ensp;容斥原理的简单介绍如下：<br>&ensp;&ensp;&ensp;&ensp;如果被计数的事物有A、B、C三类，那么，A类和B类和C类元素个数总和= A类元素个数+ B类元素个数+C类元素个数—既是A类又是B类的元素个数—既是A类又是C类的元素个数—既是B类又是C类的元素个数+既是A类又是B类而且是C类的元素个数。（A∪B∪C = A+B+C - A∩B - B∩C - C∩A + A∩B∩C）  </p>
<p>&ensp;&ensp;&ensp;&ensp;以求得s[2][3]为例，用s[1][3]加上s[2][2],得到的和的区域范围如下所示：  </p>
<p><img src="/2021/05/07/%E5%89%8D%E7%BC%80%E5%92%8C/%E5%AE%B9%E6%96%A51.png" alt="容斥1"><br>&ensp;&ensp;&ensp;&ensp;黄色标出的区域进行了一次求和，蓝色区域进行了两次求和，为了保证该2x3的范围内每个区域都只进行了一次运算，根据容斥原理，减去这两个区域的交集，即s[1][2]，再加上a[2][3]，便得到了s[2][3]的值。所以s[x][y]的值可由以下递推式得到：<br>&ensp;&ensp;&ensp;&ensp;s[x][y] = s[x - 1][y] + s[x][y - 1] - s[x - 1][y - 1] + a[x][y]  </p>
<h3 id="2）利用前缀和矩阵，计算子矩阵的和"><a href="#2）利用前缀和矩阵，计算子矩阵的和" class="headerlink" title="2）利用前缀和矩阵，计算子矩阵的和"></a>2）利用前缀和矩阵，计算子矩阵的和</h3><p>&ensp;&ensp;&ensp;&ensp;以图中红色所标出的子矩阵为例:<br><img src="/2021/05/07/%E5%89%8D%E7%BC%80%E5%92%8C/%E5%AE%B9%E6%96%A52.png" alt="容斥2"><br>&ensp;&ensp;&ensp;&ensp;首先明确一下，对于任何一个s[x][y]表示的是从(0,0)的点到(x,y)点所有元素的和，所以要解决的问题便是如何在9x9的黄色区域中扣除掉倒“7”字型的区域。<br>&ensp;&ensp;&ensp;&ensp;同样是利用容斥原理，首先扣除上方区域，即s[1][3]，接着扣除左边区域，即s[3][1]，最后加上重复扣除的这两个区域的交集，即s[1][1]。推广开来，对于求(x1,y1)到(x2,y2)的子矩阵的和的递推公式可写为：<br>&ensp;&ensp;&ensp;&ensp;sum = s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1]  </p>
<h2 id="2-4-代码实现"><a href="#2-4-代码实现" class="headerlink" title="2.4 代码实现"></a>2.4 代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">            s[i][j] = s[i<span class="number">-1</span>][j] + s[i][j<span class="number">-1</span>] - s[i<span class="number">-1</span>][j<span class="number">-1</span>] + a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i ++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x1, x2, y1, y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>&ensp;&ensp;&ensp;&ensp;对于二维矩阵的前缀和，通过容斥原理得到相关递推公式后便可轻松得出。部分范围的复杂度从O(mn)降低到了O(1)。</p>
]]></content>
      <categories>
        <category>practise</category>
      </categories>
      <tags>
        <tag>算法练习</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch线性回归</title>
    <url>/2021/07/17/%E5%86%B3%E7%AD%96%E6%A0%91%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<p>数据挖掘</p>
<span id="more"></span>  

<h1 id="决策树实验报告"><a href="#决策树实验报告" class="headerlink" title="决策树实验报告"></a>决策树实验报告</h1><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><ol>
<li><p>编程实现一个基于信息熵进行划分选择的决策树算法，并为表中的数据生成一棵决策树。</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>色泽</th>
<th>根蒂</th>
<th>敲声</th>
<th>纹理</th>
<th>脐部</th>
<th>触感</th>
<th>密度</th>
<th>含糖率</th>
<th>好瓜</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>青绿</td>
<td>蜷缩</td>
<td>浊响</td>
<td>清晰</td>
<td>凹陷</td>
<td>硬滑</td>
<td>0.697</td>
<td>0.460</td>
<td>是</td>
</tr>
<tr>
<td>2</td>
<td>乌黑</td>
<td>蜷缩</td>
<td>沉闷</td>
<td>清晰</td>
<td>凹陷</td>
<td>硬滑</td>
<td>0.774</td>
<td>0.376</td>
<td>是</td>
</tr>
<tr>
<td>3</td>
<td>乌黑</td>
<td>蜷缩</td>
<td>浊响</td>
<td>清晰</td>
<td>凹陷</td>
<td>硬滑</td>
<td>0.634</td>
<td>0.264</td>
<td>是</td>
</tr>
<tr>
<td>4</td>
<td>青绿</td>
<td>蜷缩</td>
<td>沉闷</td>
<td>清晰</td>
<td>凹陷</td>
<td>硬滑</td>
<td>0.608</td>
<td>0.318</td>
<td>是</td>
</tr>
<tr>
<td>5</td>
<td>浅白</td>
<td>蜷缩</td>
<td>浊响</td>
<td>清晰</td>
<td>凹陷</td>
<td>硬滑</td>
<td>0.556</td>
<td>0.215</td>
<td>是</td>
</tr>
<tr>
<td>6</td>
<td>青绿</td>
<td>稍蜷</td>
<td>浊响</td>
<td>清晰</td>
<td>稍凹</td>
<td>软粘</td>
<td>0.403</td>
<td>0.237</td>
<td>是</td>
</tr>
<tr>
<td>7</td>
<td>乌黑</td>
<td>稍蜷</td>
<td>浊响</td>
<td>稍糊</td>
<td>稍凹</td>
<td>软粘</td>
<td>0.481</td>
<td>0.149</td>
<td>是</td>
</tr>
<tr>
<td>8</td>
<td>乌黑</td>
<td>稍蜷</td>
<td>浊响</td>
<td>清晰</td>
<td>稍凹</td>
<td>硬滑</td>
<td>0.437</td>
<td>0.211</td>
<td>是</td>
</tr>
<tr>
<td>9</td>
<td>乌黑</td>
<td>稍蜷</td>
<td>沉闷</td>
<td>稍糊</td>
<td>稍凹</td>
<td>硬滑</td>
<td>0.666</td>
<td>0.091</td>
<td>否</td>
</tr>
<tr>
<td>10</td>
<td>青绿</td>
<td>硬挺</td>
<td>清脆</td>
<td>清晰</td>
<td>平坦</td>
<td>软粘</td>
<td>0.243</td>
<td>0.267</td>
<td>否</td>
</tr>
<tr>
<td>11</td>
<td>浅白</td>
<td>硬挺</td>
<td>清脆</td>
<td>模糊</td>
<td>平坦</td>
<td>硬滑</td>
<td>0.245</td>
<td>0.057</td>
<td>否</td>
</tr>
<tr>
<td>12</td>
<td>浅白</td>
<td>蜷缩</td>
<td>浊响</td>
<td>模糊</td>
<td>平坦</td>
<td>软粘</td>
<td>0.343</td>
<td>0.099</td>
<td>否</td>
</tr>
<tr>
<td>13</td>
<td>青绿</td>
<td>稍蜷</td>
<td>浊响</td>
<td>稍糊</td>
<td>凹陷</td>
<td>硬滑</td>
<td>0.639</td>
<td>0.161</td>
<td>否</td>
</tr>
<tr>
<td>14</td>
<td>浅白</td>
<td>稍蜷</td>
<td>沉闷</td>
<td>稍糊</td>
<td>凹陷</td>
<td>硬滑</td>
<td>0.657</td>
<td>0.198</td>
<td>否</td>
</tr>
<tr>
<td>15</td>
<td>乌黑</td>
<td>稍蜷</td>
<td>浊响</td>
<td>清晰</td>
<td>稍凹</td>
<td>软粘</td>
<td>0.360</td>
<td>0.370</td>
<td>否</td>
</tr>
<tr>
<td>16</td>
<td>浅白</td>
<td>蜷缩</td>
<td>浊响</td>
<td>模糊</td>
<td>平坦</td>
<td>硬滑</td>
<td>0.593</td>
<td>0.042</td>
<td>否</td>
</tr>
<tr>
<td>17</td>
<td>青绿</td>
<td>蜷缩</td>
<td>沉闷</td>
<td>稍糊</td>
<td>稍凹</td>
<td>硬滑</td>
<td>0.719</td>
<td>0.103</td>
<td>否</td>
</tr>
</tbody></table>
</li>
<li><p>编程实现基于基尼指数进行划分选择的决策树算法，为表中数据生成预剪枝，后剪枝决策树，并与未剪枝的决策树进行比较。</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>色泽</th>
<th>根蒂</th>
<th>敲声</th>
<th>纹理</th>
<th>脐部</th>
<th>触感</th>
<th>好瓜</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>青绿</td>
<td>蜷缩</td>
<td>浊响</td>
<td>清晰</td>
<td>凹陷</td>
<td>硬滑</td>
<td>是</td>
</tr>
<tr>
<td>2</td>
<td>乌黑</td>
<td>蜷缩</td>
<td>沉闷</td>
<td>清晰</td>
<td>凹陷</td>
<td>硬滑</td>
<td>是</td>
</tr>
<tr>
<td>3</td>
<td>乌黑</td>
<td>蜷缩</td>
<td>浊响</td>
<td>清晰</td>
<td>凹陷</td>
<td>硬滑</td>
<td>是</td>
</tr>
<tr>
<td>4</td>
<td>青绿</td>
<td>蜷缩</td>
<td>沉闷</td>
<td>清晰</td>
<td>凹陷</td>
<td>硬滑</td>
<td>是</td>
</tr>
<tr>
<td>5</td>
<td>浅白</td>
<td>蜷缩</td>
<td>浊响</td>
<td>清晰</td>
<td>凹陷</td>
<td>硬滑</td>
<td>是</td>
</tr>
<tr>
<td>6</td>
<td>青绿</td>
<td>稍蜷</td>
<td>浊响</td>
<td>清晰</td>
<td>稍凹</td>
<td>软粘</td>
<td>是</td>
</tr>
<tr>
<td>7</td>
<td>乌黑</td>
<td>稍蜷</td>
<td>浊响</td>
<td>稍糊</td>
<td>稍凹</td>
<td>软粘</td>
<td>是</td>
</tr>
<tr>
<td>8</td>
<td>乌黑</td>
<td>稍蜷</td>
<td>浊响</td>
<td>清晰</td>
<td>稍凹</td>
<td>硬滑</td>
<td>是</td>
</tr>
<tr>
<td>9</td>
<td>乌黑</td>
<td>稍蜷</td>
<td>沉闷</td>
<td>稍糊</td>
<td>稍凹</td>
<td>硬滑</td>
<td>否</td>
</tr>
<tr>
<td>10</td>
<td>青绿</td>
<td>硬挺</td>
<td>清脆</td>
<td>清晰</td>
<td>平坦</td>
<td>软粘</td>
<td>否</td>
</tr>
<tr>
<td>11</td>
<td>浅白</td>
<td>硬挺</td>
<td>清脆</td>
<td>模糊</td>
<td>平坦</td>
<td>硬滑</td>
<td>否</td>
</tr>
<tr>
<td>12</td>
<td>浅白</td>
<td>蜷缩</td>
<td>浊响</td>
<td>模糊</td>
<td>平坦</td>
<td>软粘</td>
<td>否</td>
</tr>
<tr>
<td>13</td>
<td>青绿</td>
<td>稍蜷</td>
<td>浊响</td>
<td>稍糊</td>
<td>凹陷</td>
<td>硬滑</td>
<td>否</td>
</tr>
<tr>
<td>14</td>
<td>浅白</td>
<td>稍蜷</td>
<td>沉闷</td>
<td>稍糊</td>
<td>凹陷</td>
<td>硬滑</td>
<td>否</td>
</tr>
<tr>
<td>15</td>
<td>乌黑</td>
<td>稍蜷</td>
<td>浊响</td>
<td>清晰</td>
<td>稍凹</td>
<td>软粘</td>
<td>否</td>
</tr>
<tr>
<td>16</td>
<td>浅白</td>
<td>蜷缩</td>
<td>浊响</td>
<td>模糊</td>
<td>平坦</td>
<td>硬滑</td>
<td>否</td>
</tr>
<tr>
<td>17</td>
<td>青绿</td>
<td>蜷缩</td>
<td>沉闷</td>
<td>稍糊</td>
<td>稍凹</td>
<td>硬滑</td>
<td>否</td>
</tr>
</tbody></table>
</li>
<li><p>选择两个UCI数据集，对上述3种算法产生的未剪枝，预剪枝，后剪枝的决策树进行实验比较</p>
</li>
</ol>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><ul>
<li>定义：一种描述对实例进行分类的树形结构。决策树由点和有向边组成。节点有两种类型：内部节点和叶节点。内部节点表示一种特征或者属性，叶节点表示一个分类。构建决策树时通常采用自上而下的方法，在每一步选择一个最好的属性来分裂。[8] “最好” 的定义是使得子节点中的训练集尽量的纯。不同的算法使用不同的指标来定义”最好”。</li>
<li>意义：每次都找不同的切分点，将样本空间逐渐进行细分，最后把属于同一类的空间进行合并，就形成了决策边界，树的层次越深，决策边界的切分就越细，区分越准确，同时也越有可能产生过拟合。<ul>
<li>决策树是一个预测模型；他代表的是对象属性与对象值之间的一种映射关系。树中每个节点表示某个对象，而每个分叉路径则代表的某个可能的属性值，而每个叶结点则对应从根节点到该叶节点所经历的路径所表示的对象的值。决策树仅有单一输出，若欲有复数输出，可以建立独立的决策树以处理不同输出。</li>
<li>分支使用的是节点属性中的离散型数据，如果数据是连续型的，也需要转化成离散型数据才能在决策树中展示。</li>
<li>决策树的路径具有一个重要的性质：互斥且完备,即每一个样本均被且只能被一条路径所覆盖。决策树学习算法主要由三部分构成：<ul>
<li>特征选择</li>
<li>决策树生成</li>
<li>决策树的剪枝</li>
</ul>
</li>
</ul>
</li>
<li>决策树的建立<br>开始，构建根节点，将所有训练数据放在根节点，选择一个最优特征，按照这一特征的取值将训练数据分割为子集，使各个子集有一个当前条件下最好的分类。如果这些子集能被基本正确分类，那么构造叶节点，将对应子集集中到叶节点。如果有子集不能被正确分类，那么就这些子集选择新的最优特征，继续对其进行分割，构建相应的节点。递归进行上述的操作，直到所有训练数据子集均能被正确分类。<ul>
<li>节点分裂：一般当一个节点所代表的属性无法给出判断时，则选择将这一节点分成2个子节点（如不是二叉树的情况会分成n个子节点）</li>
<li>阈值的确定，选择适当的阈值使得分类错误率最小。</li>
</ul>
</li>
<li>与其他的数据挖掘算法相比，决策树有许多优点:<ul>
<li>易于理解和解释，人们很容易理解决策树的意义。</li>
<li>只需很少的数据准备，其他技术往往需要数据归一化。</li>
<li>既可以处理数值型数据也可以处理类别型数据。其他技术往往只能处理一种数据类型。例如关联规则只能处理类别型的而神经网络只能处理数值型的数据。</li>
<li>使用白箱模型，输出结果容易通过模型的结构来解释。而神经网络是黑箱模型，很难解释输出的结果。</li>
<li>可以通过测试集来验证模型的性能，可以考虑模型的稳定性。</li>
<li>强健控制，对噪声处理有好的强健性。</li>
<li>可以很好的处理大规模数据 。</li>
</ul>
</li>
</ul>
<h3 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h3><ul>
<li><p>信息熵 entropy<br>  熵是接收的每条消息中包含的信息的平均量，熵是对不确定性的测量。但是在信息世界，熵越高，则能传输越多的信息，熵越低，则意味着传输的信息越少。<br>  当取自有限的样本时，熵的公式可以表示为：<br>  $$H(X) = -\sum^{n}_{i = 1}p_i \log_2 p_i$$<br>  其中若 $p_i = 0$ 则定义 $p_i\log p_i = 0$</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_ent</span>(<span class="params">datasets</span>):</span></span><br><span class="line">    data_length = <span class="built_in">len</span>(datasets)</span><br><span class="line">    label_count = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(data_length):</span><br><span class="line">        label = datasets[i][-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> label <span class="keyword">not</span> <span class="keyword">in</span> label_count:</span><br><span class="line">            label_count[label] = <span class="number">0</span></span><br><span class="line">        label_count[label] += <span class="number">1</span></span><br><span class="line">    ent = -<span class="built_in">sum</span>([(p / data_length) * log(p / data_length, <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">for</span> p <span class="keyword">in</span> label_count.values()])</span><br><span class="line">    <span class="keyword">return</span> ent</span><br></pre></td></tr></table></figure>

<ul>
<li>信息量<br>信息量是对信息的度量，就跟时间的度量是秒一样，当我们考虑一个离散的随机变量x的时候，当我们观察到的这个变量的一个具体值的时候，我们接收到了多少信息呢？多少信息用信息量来衡量，我们接受到的信息量跟具体发生的事件有关。信息的大小跟随机事件的概率有关。越小概率的事情发生了产生的信息量越大，越大概率的事情发生了产生的信息量越小</li>
</ul>
</li>
<li><p>信息增益 information gain<br>  得知特征 $X$ 的信息而使得类 $Y$ 的信息的不确定性减少的程度。<br>  特征 $A$ 对训练数据集 $D$ 的信息增益 $g(D, A)$ 定义为集合 $D$ 的经验熵 $H(D)$ 与特征 $A$ 给定条件下 $D$ 的经验条件熵 $H(D|A)$ 的差。<br>  $$g(D,A) = H(D) - H(D|A)$$<br>  一般地，熵 $H(Y)$ 与条件熵 $H(Y|X)$ 之差称为互信息(mutual information) 根据信息增益准则进行特征选择的方法是：对训练数据集D，计算其每个特征的信息增益，并比它们的大小，从而选择信息增益最大的特征。<br>  假设训练数据集为 $D$，样本容量为 $|D|$,有 $K$ 个类别 $C_k$，$|C_k|$ 为类别 $C_k$ 的样本个数。某一特征 $A$ 有 $n$ 个不同的取值 $a_1, a_2, …, a_n$。根据特征 $A$ 的取值可将数据集 $D$ 划分为 $n$ 个子集 $D_1, D_2, …, D_n$， $|D_i$|为 $D_i$ 的样本个数。并记子集 $D_i$ 中属于类 $C_k$ 的样本的集合为 $D_{ik}$，$|D_{ik}|$ 为 $D_{ik}$ 的样本个数。</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cond_ent</span>(<span class="params">datasets, axis=<span class="number">0</span></span>):</span></span><br><span class="line">    data_length = <span class="built_in">len</span>(datasets)</span><br><span class="line">    feature_sets = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(data_length):</span><br><span class="line">        feature = datasets[i][axis]</span><br><span class="line">        <span class="keyword">if</span> feature <span class="keyword">not</span> <span class="keyword">in</span> feature_sets:</span><br><span class="line">            feature_sets[feature] = []</span><br><span class="line">        feature_sets[feature].append(datasets[i])</span><br><span class="line">    cond_ent = <span class="built_in">sum</span>(</span><br><span class="line">        [(<span class="built_in">len</span>(p) / data_length) * calc_ent(p) <span class="keyword">for</span> p <span class="keyword">in</span> feature_sets.values()])</span><br><span class="line">    <span class="keyword">return</span> cond_ent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info_gain</span>(<span class="params">ent, cond_ent</span>):</span></span><br><span class="line">    <span class="keyword">return</span> ent - cond_ent</span><br></pre></td></tr></table></figure></li>
</ul>
<p>ID3算法的核心是在决策树的各个结点上应用信息增益准则进行特征选择。具体做法是：</p>
<ul>
<li>从根节点开始，对结点计算所有可能特征的信息增益，选择信息增益最大的特征作为结点的特征，并由该特征的不同取值构建子节点；</li>
<li>对子节点递归地调用以上方法，构建决策树；</li>
<li>直到所有特征的信息增益均很小或者没有特征可选时为止。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">判断数据集中的每个子项是否属于同一类：</span><br><span class="line">    if true:</span><br><span class="line">        return 类标签；</span><br><span class="line">    else:</span><br><span class="line">        寻找划分数据集的最佳特征</span><br><span class="line">        根据最佳特征划分数据集</span><br><span class="line">        创建分支节点</span><br><span class="line">        for 每个划分的子集</span><br><span class="line">            递归调用createBranch();</span><br><span class="line">        return 分支节点</span><br></pre></td></tr></table></figure>

<h3 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a>C4.5</h3><ul>
<li>信息增益比 information gain ratio<br>  以信息增益作为划分训练数据集的特征，存在偏向与选择取值较多的特征的问题。使用信息增益比可以对这个问题进行矫正。<br>  特征 $A$ 对训练数据集 $D$ 的信息增益比 $g_R(D,A)$ 定义为其信息增益 $g(D,A)$ 和训练数据集 $D$ 关于特征 $A$ 的熵 $H_A(D)$ 的比值。<br>  $$g_R(D,A) = \frac{g(D,A)}{H_A(D,A)}$$<br>  其中 $H_A(D) = \sum_{i=1}^n \frac{|D_i|}{|D|} \log_2 \frac{|D_i|}{|D|}$, $n$ 是特征 $A$ 取值的个数。</li>
</ul>
<p>相比 ID3 算法，C4.5 算法更换了特征选择的标准，使用信息增益比进行特征选择。不直接选择增益率最大的候选划分属性，候选划分属性中找出信息增益高于平均水平的属性（这样保证了大部分好的的特征），再从中选择增益率最高的（又保证了不会出现编号特征这种极端的情况）<br>对于连续值属性来说，可取值数目不再有限，因此可以采用离散化技术（如二分法）进行处理。将属性值从小到大排序，然后选择中间值作为分割点，数值比它小的点被划分到左子树，数值不小于它的点被分到又子树，计算分割的信息增益率，选择信息增益率最大的属性值进行分割。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Function C4.5(R:包含连续属性的无类别属性集合,C:类别属性,S:训练集)  </span><br><span class="line">/*返回一棵决策树*/  </span><br><span class="line">Begin  </span><br><span class="line">   If S 为空,返回一个值为 Failure 的单个节点;  </span><br><span class="line">   If S 是由相同类别属性值的记录组成：  </span><br><span class="line">      返回一个带有该值的单个节点;  </span><br><span class="line">   If R 为空,则返回一个单节点,其值为在 S 的记录中找出的频率最高的类别属性值;  </span><br><span class="line">   [注意未出现错误则意味着是不适合分类的记录]；  </span><br><span class="line">  For 所有的属性 R(Ri) Do  </span><br><span class="line">        If 属性 Ri 为连续属性，则  </span><br><span class="line">     Begin  </span><br><span class="line">           将Ri的最小值赋给 A1：  </span><br><span class="line">        将Rm的最大值赋给Am；/*m值手工设置*/  </span><br><span class="line">           For j From 2 To m-1 Do Aj=A1+j*(A1Am)/m;  </span><br><span class="line">           将 Ri 点的基于&#123;&lt; =Aj,&gt;Aj&#125;的最大信息增益属性 (Ri,S) 赋给 A；  </span><br><span class="line">     End；  </span><br><span class="line">  将 R 中属性之间具有最大信息增益的属性 (D,S) 赋给 D;  </span><br><span class="line">   将属性D的值赋给&#123;dj/j=1,2...m&#125;；  </span><br><span class="line">  将分别由对应于 D 的值为 dj 的记录组成的S的子集赋给 &#123;sj/j=1,2...m&#125;;  </span><br><span class="line">   返回一棵树，其根标记为 D;树枝标记为 d1,d2...dm;  </span><br><span class="line">   再分别构造以下树:  </span><br><span class="line">   C4.5(R-&#123;D&#125;,C,S1),C4.5(R-&#123;D&#125;,C,S2)...C4.5(R-&#123;D&#125;,C,Sm);  </span><br><span class="line"></span><br><span class="line">End C4.5</span><br></pre></td></tr></table></figure>

<h3 id="CART"><a href="#CART" class="headerlink" title="CART"></a>CART</h3><p>CART与ID3区别： CART中用于选择变量的不纯性度量是Gini指数； 如果目标变量是标称的，并且是具有两个以上的类别，则CART可能考虑将目标类别合并成两个超类别（双化）； 如果目标变量是连续的，则CART算法找出一组基于树的回归方程来预测目标变量。</p>
<ul>
<li><p>Gini 指数<br>  分类问题中假设有 $K$ 个类，样本点属于第 $k$ 个类的概率为 $p_k$，则概率分布的基尼指数为定义为<br>  $$Gini(p) = \sum_{k=1}^K p_k(1 - p_k) = 1 - \sum_{k = 1}^K p_k^2$$<br>  对于二分类问题和给定的样本集合 $D$ 其基尼指数为<br>  $$Gini(D) = 1 - \sum_{k=1}^K (\frac{|C_k|}{|D|})^2$$<br>  若样本集合 $D$ 根据特征 $A$ 是否取某一可能的值 $a$ 分割为 $D_1, D_2$ 两部分，则在特征 $A$ 的条件下集合 $D$ 的基尼指数定义为<br>  $$Gini(D,A) = \frac{|D_1|}{|D|} Gini(D_1) + \frac{|D_2|}{|D|} Gini(D_2)$$<br>  $Gini(D)$ 反映了数据集 $D$ 的纯度，值越小，纯度越高。我们在候选集合中选择使得划分后基尼指数最小的属性作为最优化分属性。</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gini</span>(<span class="params">data_set</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算gini的值，即Gini(p)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    length = <span class="built_in">len</span>(data_set)</span><br><span class="line">    category_2_cnt = calculate_diff_count(data_set)</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> category <span class="keyword">in</span> category_2_cnt:</span><br><span class="line">        <span class="built_in">sum</span> += <span class="built_in">pow</span>(<span class="built_in">float</span>(category_2_cnt[category]) / length, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> - <span class="built_in">sum</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>CART是一棵二叉树，采用二元切分法，每次把数据切成两份，分别进入左子树、右子树。而且每个非叶子节点都有两个孩子，所以CART的叶子节点比非叶子多1。相比ID3和C4.5，CART应用要多一些，既可以用于分类也可以用于回归。CART分类时，使用基尼指数（Gini）来选择最好的数据分割的特征，gini描述的是纯度，与信息熵的含义相似。CART中每一次迭代都会降低GINI系数。</p>
<ul>
<li><p>算法流程：</p>
<ol>
<li>CART回归树预测回归连续型数据，假设X与Y分别是输入和输出变量，并且Y是连续变量。在训练数据集所在的输入空间中，递归的将每个区域划分为两个子区域并决定每个子区域上的输出值，构建二叉决策树。</li>
<li>选择最优切分变量j与切分点 $s$：遍历变量 $j$，对规定的切分变量 $j$ 扫描切分点 $s$，选择使下式得到最小值时的 $(j,s)$ 对。其中 $R_m$ 是被划分的输入空间，$c_m$ 是空间 $R_m$ 对应的固定输出值。</li>
<li>用选定的 $(j,s)$ 对，划分区域并决定相应的输出值。</li>
<li>继续对两个子区域调用上述步骤，将输入空间划分为 $M$ 个区域 $R_1,R_2,…,R_m$，生成决策树。</li>
</ol>
<p>  当输入空间划分确定时，可以用平方误差来表示回归树对于训练数据的预测方法，用平方误差最小的准则求解每个单元上的最优输出值。<br>  $$\sum_{x_i \in R_m} (y_i - f(x_i))^2$$</p>
</li>
</ul>
<h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>为了避免决策树“过拟合”样本。前面的算法生成的决策树非常的详细而庞大，每个属性都被详细地加以考虑，决策树的树叶节点所覆盖的训练样本都是“纯”的。因此用这个决策树来对训练样本进行分类的话，你会发现对于训练样本而言，这个树表现堪称完美，它可以100%完美正确得对训练样本集中的样本进行分类（因为决策树本身就是100%完美拟合训练样本的产物）。但是，这会带来一个问题，如果训练样本中包含了一些错误，按照前面的算法，这些错误也会100%一点不留得被决策树学习了，这就是“过拟合”。</p>
<h4 id="预剪枝-pre-pruning"><a href="#预剪枝-pre-pruning" class="headerlink" title="预剪枝 pre-pruning"></a>预剪枝 pre-pruning</h4><p>预剪枝就是在树的构建过程（只用到训练集），设置一个阈值（样本个数小于预定阈值或GINI指数小于预定阈值），使得当在当前分裂节点中分裂前和分裂后的误差超过这个阈值则分列，否则不进行分裂操作。所有决策树的构建方法，都是在无法进一步降低熵的情况下才会停止创建分支的过程，为了避免过拟合，可以设定一个阈值，熵减小的数量小于这个阈值，即使还可以继续降低熵，也停止继续创建分支。但是这种方法实际中的效果并不好。<br>在划分之前，所有样本集中于根节点，若不进行划分，该节点被标记为叶节点，其类别标记为训练样例最多的类别。若进行划分在测试集上的准确率小于在根节点不进行划分的准确率，或增幅没有超过阈值，都不进行划分，作为一个叶节点返回当前数据集中最多的标签类型。</p>
<ul>
<li><p>预剪枝就是在完全正确分类训练集之前，较早地停止树的生长。 具体在什么时候停止决策树的生长有多种不同的方法:</p>
<ol>
<li>一种最为简单的方法就是在决策树到达一定高度的情况下就停止树的生长。</li>
<li>到达此结点的实例具有相同的特征向量，而不必一定属于同一类， 也可停止生长。</li>
<li>到达此结点的实例个数小于某一个阈值也可停止树的生长。</li>
<li>还有一种更为普遍的做法是计算每次扩张对系统性能的增益，如果这个增益值小于某个阈值则不进行扩展。</li>
</ol>
</li>
<li><p>优点：快速，可以在构建决策树时进行剪枝，显著降低了过拟合风险。由于预剪枝不必生成整棵决策树，且算法相对简单，效率很高，适合解决大规模问题。但是尽管这一方法看起来很直接， 但是怎样精确地估计何时停止树的增长是相当困难的。</p>
</li>
<li><p>缺点：预剪枝基于贪心思想，本质上禁止分支展开，给决策树带来了欠拟合的风险。因为视野效果问题 。 也就是说在相同的标准下，也许当前的扩展会造成过度拟合训练数据，但是更进一步的扩展能够满足要求，也有可能准确地拟合训练数据。这将使得算法过早地停止决策树的构造。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> pre_pruning:</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(test_dataset)):  <span class="comment"># build label for test dataset</span></span><br><span class="line">        ans.append(test_dataset[index][-<span class="number">1</span>])</span><br><span class="line">    result_counter = Counter()</span><br><span class="line">    <span class="keyword">for</span> vec <span class="keyword">in</span> dataset:</span><br><span class="line">        result_counter[vec[-<span class="number">1</span>]] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># what will it be if it is a leaf node</span></span><br><span class="line">    leaf_output = result_counter.most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    root_acc = cal_acc(test_output=[leaf_output] * <span class="built_in">len</span>(test_dataset),</span><br><span class="line">                        label=ans)</span><br><span class="line">    outputs = []</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:  <span class="comment"># expand the node</span></span><br><span class="line">        cut_testset = splitdataset(test_dataset, bestFeat, value)</span><br><span class="line">        cut_dataset = splitdataset(dataset, bestFeat, value)</span><br><span class="line">        <span class="keyword">for</span> vec <span class="keyword">in</span> cut_testset:</span><br><span class="line">            ans.append(vec[-<span class="number">1</span>])</span><br><span class="line">        result_counter = Counter()</span><br><span class="line">        <span class="keyword">for</span> vec <span class="keyword">in</span> cut_dataset:</span><br><span class="line">            result_counter[vec[-<span class="number">1</span>]] += <span class="number">1</span></span><br><span class="line">        leaf_output = result_counter.most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]  <span class="comment"># what will it be if it is a leaf node</span></span><br><span class="line">        outputs += [leaf_output] * <span class="built_in">len</span>(cut_testset)</span><br><span class="line">    cut_acc = cal_acc(test_output=outputs, label=ans)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cut_acc &lt;= root_acc + threshold: <span class="comment"># whether expand the node or not</span></span><br><span class="line">        <span class="keyword">return</span> leaf_output</span><br></pre></td></tr></table></figure>

<h4 id="后剪枝-post-pruning"><a href="#后剪枝-post-pruning" class="headerlink" title="后剪枝 post-pruning"></a>后剪枝 post-pruning</h4><p>决策树构造完成后进行剪枝。剪枝的过程是对拥有同样父节点的一组节点进行检查，判断如果将其合并，熵的增加量是否小于某一阈值。如果确实小，则这一组节点可以合并一个节点，其中包含了所有可能的结果。后剪枝是目前最普遍的做法。<br>后剪枝的剪枝过程是删除一些子树，然后用其叶子节点代替，这个叶子节点所标识的类别通过大多数原则 (majority class criterion) 确定。所谓大多数原则，是指剪枝过程中, 将一些子树删除而用叶节点代替,这个叶节点所标识的类别用这棵子树中大多数训练样本所属的类别来标识。相比于前剪枝，后剪枝方法更常用，是因为在前剪枝方法中精确地估计何时停止树增长很困难。</p>
<ul>
<li>优点：欠拟合风险小，泛化性能好</li>
<li>缺点：在生成决策树之后完成，自底向上对所有非叶节点进行逐一考察，训练的时间开销较大</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prune_tree</span>(<span class="params">node, prunedList</span>):</span></span><br><span class="line">    <span class="comment"># Base case: we&#x27;ve reached a leaf</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Leaf):</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    <span class="comment"># If we reach a pruned node, make that node a leaf node and return.</span></span><br><span class="line">    <span class="comment"># Since it becomes a leaf node, the nodes</span></span><br><span class="line">    <span class="comment"># below it are automatically not considered</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(node.<span class="built_in">id</span>) <span class="keyword">in</span> prunedList:</span><br><span class="line">        <span class="keyword">return</span> Leaf(node.rows, node.<span class="built_in">id</span>, node.depth)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Call this function recursively on the true branch</span></span><br><span class="line">    node.true_branch = prune_tree(node.true_branch, prunedList)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Call this function recursively on the false branch</span></span><br><span class="line">    node.false_branch = prune_tree(node.false_branch, prunedList)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>

<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>测试数据使用李航老师的统计方法中对应的数据集。</p>
<h3 id="ID3-算法实现"><a href="#ID3-算法实现" class="headerlink" title="ID3 算法实现"></a>ID3 算法实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ID3_chooseBestFeature</span>(<span class="params">dataset</span>):</span></span><br><span class="line">    numFeatures = <span class="built_in">len</span>(dataset[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    baseEnt = cal_entropy(dataset)</span><br><span class="line">    bestInfoGain = <span class="number">0.0</span></span><br><span class="line">    bestFeature = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFeatures):  <span class="comment"># check all features</span></span><br><span class="line">        featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataset]</span><br><span class="line">        uniqueVals = <span class="built_in">set</span>(featList)</span><br><span class="line">        newEnt = <span class="number">0.0</span></span><br><span class="line">        <span class="comment"># claculate entropy of every divide ways</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">            <span class="comment"># choose the samples mmeeting the requirement</span></span><br><span class="line">            subdataset = splitdataset(dataset, i, value)</span><br><span class="line">            p = <span class="built_in">len</span>(subdataset) / <span class="built_in">float</span>(<span class="built_in">len</span>(dataset))</span><br><span class="line">            newEnt += p * cal_entropy(subdataset)</span><br><span class="line">        infoGain = baseEnt - newEnt</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (infoGain &gt; bestInfoGain):</span><br><span class="line">            bestInfoGain = infoGain  <span class="comment"># choose the largest information gain</span></span><br><span class="line">            bestFeature = i</span><br><span class="line">    <span class="keyword">return</span> bestFeature</span><br></pre></td></tr></table></figure>

<h3 id="C4-5-算法实现"><a href="#C4-5-算法实现" class="headerlink" title="C4.5 算法实现"></a>C4.5 算法实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">C45_chooseBestFeatureToSplit</span>(<span class="params">dataset</span>):</span></span><br><span class="line">    numFeatures = <span class="built_in">len</span>(dataset[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    baseEnt = cal_entropy(dataset)</span><br><span class="line">    bestInfoGain_ratio = <span class="number">0.0</span></span><br><span class="line">    bestFeature = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFeatures):  <span class="comment"># check every feature</span></span><br><span class="line">        featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataset]</span><br><span class="line">        uniqueVals = <span class="built_in">set</span>(featList)</span><br><span class="line">        newEnt = <span class="number">0.0</span></span><br><span class="line">        IV = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">            subdataset = splitdataset(dataset, i, value)</span><br><span class="line">            p = <span class="built_in">len</span>(subdataset) / <span class="built_in">float</span>(<span class="built_in">len</span>(dataset))</span><br><span class="line">            newEnt += p * cal_entropy(subdataset)</span><br><span class="line">            IV = IV - p * log(p, <span class="number">2</span>)</span><br><span class="line">        infoGain = baseEnt - newEnt</span><br><span class="line">        <span class="keyword">if</span> (IV == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        infoGain_ratio = infoGain / IV  <span class="comment"># infoGain_ratio of current feature</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (infoGain_ratio &gt; bestInfoGain_ratio):  <span class="comment"># choose the greatest gain ratio</span></span><br><span class="line">            bestInfoGain_ratio = infoGain_ratio</span><br><span class="line">            bestFeature = i  <span class="comment"># choose the feature corsbounding to the gain ratio</span></span><br><span class="line">    <span class="keyword">return</span> bestFeature</span><br></pre></td></tr></table></figure>

<h3 id="CART-算法实现"><a href="#CART-算法实现" class="headerlink" title="CART 算法实现"></a>CART 算法实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CART_chooseBestFeature</span>(<span class="params">dataset</span>):</span></span><br><span class="line">    numFeatures = <span class="built_in">len</span>(dataset[<span class="number">0</span>]) - <span class="number">1</span>  <span class="comment"># except the column of labels</span></span><br><span class="line">    bestGini = <span class="number">999999.0</span></span><br><span class="line">    bestFeature = -<span class="number">1</span>  <span class="comment"># default label</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numFeatures):</span><br><span class="line">        featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataset]</span><br><span class="line">        uniqueVals = <span class="built_in">set</span>(featList)  <span class="comment"># get the possible values of each feature</span></span><br><span class="line">        gini = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">            subdataset = splitdataset(dataset, i, value)</span><br><span class="line">            p = <span class="built_in">len</span>(subdataset) / <span class="built_in">float</span>(<span class="built_in">len</span>(dataset))</span><br><span class="line">            subp = <span class="built_in">len</span>(splitdataset(subdataset, -<span class="number">1</span>, <span class="string">&#x27;0&#x27;</span>)) / <span class="built_in">float</span>(<span class="built_in">len</span>(subdataset))</span><br><span class="line">        gini += p * (<span class="number">1.0</span> - <span class="built_in">pow</span>(subp, <span class="number">2</span>) - <span class="built_in">pow</span>(<span class="number">1</span> - subp, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gini &lt; bestGini):</span><br><span class="line">            bestGini = gini</span><br><span class="line">            bestFeature = i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bestFeature</span><br></pre></td></tr></table></figure>

<h3 id="建树操作"><a href="#建树操作" class="headerlink" title="建树操作"></a>建树操作</h3><p>因为建树过程相似，仅选取 ID3 算法的建树过程。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ID3_create_tree</span>(<span class="params">dataset, labels, test_dataset</span>):</span></span><br><span class="line">    classList = [example[-<span class="number">1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataset]</span><br><span class="line">    <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == <span class="built_in">len</span>(classList):</span><br><span class="line">        <span class="comment"># 类别完全相同，停止划分</span></span><br><span class="line">        <span class="keyword">return</span> classList[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(dataset[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 遍历完所有特征时返回出现次数最多的</span></span><br><span class="line">        <span class="keyword">return</span> majority_count(classList)</span><br><span class="line">    bestFeat = ID3_choose_best_feature(dataset)</span><br><span class="line">    bestFeatLabel = labels[bestFeat]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">u&quot;此时最优索引为：&quot;</span> + (bestFeatLabel))</span><br><span class="line"></span><br><span class="line">    ID3Tree = &#123;bestFeatLabel: &#123;&#125;&#125;</span><br><span class="line">    <span class="keyword">del</span> (labels[bestFeat])</span><br><span class="line">    <span class="comment"># 得到列表包括节点所有的属性值</span></span><br><span class="line">    featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> dataset]</span><br><span class="line">    uniqueVals = <span class="built_in">set</span>(featValues)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:  <span class="comment"># 枚举对用特征的每个取值</span></span><br><span class="line">        subLabels = labels[:]</span><br><span class="line">        ID3Tree[bestFeatLabel][value] = ID3_create_tree(</span><br><span class="line">            split_dataset(dataset, bestFeat, value),</span><br><span class="line">            subLabels,</span><br><span class="line">            split_dataset(test_dataset, bestFeat, value))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cut_acc &gt;= root_acc:</span><br><span class="line">            <span class="keyword">return</span> leaf_output</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ID3Tree  <span class="comment"># 如果没有剪枝返回节点</span></span><br></pre></td></tr></table></figure>

<h3 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h3><p>在实现时检查划分，如果在测试集上的准确率下降或没有上升到一个阈值时，将进行剪枝。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> pre_pruning:</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(test_dataset)):</span><br><span class="line">        ans.append(test_dataset[index][-<span class="number">1</span>])</span><br><span class="line">    result_counter = Counter()</span><br><span class="line">    <span class="keyword">for</span> vec <span class="keyword">in</span> dataset:</span><br><span class="line">        result_counter[vec[-<span class="number">1</span>]] += <span class="number">1</span></span><br><span class="line">    leaf_output = result_counter.most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    root_acc = cal_acc(test_output=[leaf_output] * <span class="built_in">len</span>(test_dataset), label=ans)</span><br><span class="line">    <span class="comment"># 若当前节点是叶节点的准确率</span></span><br><span class="line">    outputs = []</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">        cut_testset = split_dataset(test_dataset, bestFeat, value)</span><br><span class="line">        cut_dataset = split_dataset(dataset, bestFeat, value)</span><br><span class="line">        <span class="keyword">for</span> vec <span class="keyword">in</span> cut_testset:</span><br><span class="line">            ans.append(vec[-<span class="number">1</span>])</span><br><span class="line">        result_counter = Counter()</span><br><span class="line">        <span class="keyword">for</span> vec <span class="keyword">in</span> cut_dataset:</span><br><span class="line">            result_counter[vec[-<span class="number">1</span>]] += <span class="number">1</span></span><br><span class="line">        leaf_output = result_counter.most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        outputs += [leaf_output] * <span class="built_in">len</span>(cut_testset)</span><br><span class="line">    cut_acc = cal_acc(test_output=outputs, label=ans)  <span class="comment"># 不进行剪枝在测试集上的准确率</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cut_acc &lt;= root_acc + threshold:  <span class="comment"># 检查准确率上升情况</span></span><br><span class="line">        <span class="keyword">return</span> leaf_output</span><br></pre></td></tr></table></figure>

<h3 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h3><p>因为后剪枝的方法是自下而上的判断是否应该进行剪枝，所以在实现时在返回节点对象之前进行剪枝，决定是返回对象还是返回单一类别。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> post_pruning:</span><br><span class="line">    tree_output = test_tree(C45Tree,</span><br><span class="line">                            featLabels=total_labels,</span><br><span class="line">                            testDataSet=test_dataset)</span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> vec <span class="keyword">in</span> test_dataset:</span><br><span class="line">        ans.append(vec[-<span class="number">1</span>])</span><br><span class="line">    root_acc = cal_acc(tree_output, ans)</span><br><span class="line">    result_counter = Counter()</span><br><span class="line">    <span class="keyword">for</span> vec <span class="keyword">in</span> dataset:</span><br><span class="line">        result_counter[vec[-<span class="number">1</span>]] += <span class="number">1</span></span><br><span class="line">    leaf_output = result_counter.most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    cut_acc = cal_acc([leaf_output] * <span class="built_in">len</span>(test_dataset), ans)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cut_acc &gt;= root_acc:</span><br><span class="line">        <span class="keyword">return</span> leaf_output</span><br></pre></td></tr></table></figure>

<p>表面上后剪枝的操作比预剪枝少，实际上在测试时递归的测试了当前节点所在子树的正确率。所以后剪枝带来的开销远大于的预剪枝。</p>
<h2 id="实验结果分析"><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h2><h3 id="西瓜数据集3-0"><a href="#西瓜数据集3-0" class="headerlink" title="西瓜数据集3.0"></a>西瓜数据集3.0</h3><p>实现基于信息熵进行划分的决策树算法（ID3）算法，并可视化结果如下：</p>
<p><img src="/2021/07/17/%E5%86%B3%E7%AD%96%E6%A0%91%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/ID3-1.png" alt="img"></p>
<p>可以注意到直接使用了编号信息进行划分，这一点和书中描述的 “基于信息增益的算法对可取数值较多的属性有偏好” 一致。下来除去编号属性并对结果进行可视化，结果如下：</p>
<p><img src="/2021/07/17/%E5%86%B3%E7%AD%96%E6%A0%91%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/ID3-2.png" alt="img"></p>
<h3 id="西瓜数据集2-0"><a href="#西瓜数据集2-0" class="headerlink" title="西瓜数据集2.0"></a>西瓜数据集2.0</h3><p>实现基于基尼指数进行划分选择的决策树算法，并进行相应的剪枝操作，使用书中的测试集，验证集划分。</p>
<ul>
<li>未剪枝  <img src="/2021/07/17/%E5%86%B3%E7%AD%96%E6%A0%91%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/4.4-1'.png" height="400"></li>
<li>预剪枝  <img src="/2021/07/17/%E5%86%B3%E7%AD%96%E6%A0%91%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/4.4-2.png" height="150"></li>
<li>后剪枝  <img src="/2021/07/17/%E5%86%B3%E7%AD%96%E6%A0%91%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/4.4-3.png" height="300"></li>
</ul>
<h3 id="UCI-数据集"><a href="#UCI-数据集" class="headerlink" title="UCI 数据集"></a>UCI 数据集</h3><p>使用 UCI 数据集来判断未剪枝，预剪枝，后剪枝的方法产生的差异。</p>
<h4 id="Iris"><a href="#Iris" class="headerlink" title="Iris"></a>Iris</h4><p>总数据集一共 150 条数据，共三个类别。在数据集中随机抽取30条数据组成测试集，再从中随机抽取30个作为训练时的验证集，余下的90条数据组成训练集。数据集的描述内容包括：花萼长度，花萼宽度，花瓣长度，花瓣宽度。</p>
<ul>
<li>使用 CART 进行实验<ul>
<li>未剪枝<pre><code>&lt;img src=&quot;4.6-1.png&quot; height=500&gt;
</code></pre>
</li>
<li>预剪枝<pre><code>&lt;img src=&quot;4.6-2.png&quot; height=400&gt;
</code></pre>
</li>
<li>后剪枝<pre><code> 不是剪枝一定要剪掉某个节点，如果树中本身的节点符合要求，可以不用剪枝。
&lt;img src=&quot;4.6-1.png&quot; height=500&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<p>经过观察，通过修改随机数种子来更改测试集和验证集的划分可以很大程度上影响决策树的准确率。</p>
<p>将数据集划分函数的 <code>random state</code> 从 15 改成 1 之后，后剪枝产生的决策树变为下图：<br><img src="/2021/07/17/%E5%86%B3%E7%AD%96%E6%A0%91%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/4.6-4.png" alt="img"><br>所以数据集的划分可以显著影响树的形状和结果的准确率。</p>
<h4 id="Balloons"><a href="#Balloons" class="headerlink" title="Balloons"></a>Balloons</h4><ul>
<li><p>数据集描述<br>  数据集较小，共20个样本，四个属性。<a href="https://archive.ics.uci.edu/ml/datasets/Balloons">数据集链接</a></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>取值</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>yellow, purple</td>
</tr>
<tr>
<td>size</td>
<td>large, small</td>
</tr>
<tr>
<td>act</td>
<td>stretch, dip</td>
</tr>
<tr>
<td>age</td>
<td>adult, child</td>
</tr>
<tr>
<td>label</td>
<td>T, F</td>
</tr>
</tbody></table>
<p>  其中选择4个样本作为测试集，4个样本作为训练时使用的验证集，余下的作为训练集。</p>
</li>
<li><p>不剪枝<br>  <img src="/2021/07/17/%E5%86%B3%E7%AD%96%E6%A0%91%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/4.6-5.png" alt="img"></p>
</li>
<li><p>预剪枝<br>  <img src="/2021/07/17/%E5%86%B3%E7%AD%96%E6%A0%91%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/4.6-6.png" alt="img"></p>
</li>
<li><p>后剪枝<br>  <img src="/2021/07/17/%E5%86%B3%E7%AD%96%E6%A0%91%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/4.6-5.png" alt="img"></p>
</li>
</ul>
<h2 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h2><p>通过本次实验有如下的发现和收获：</p>
<ul>
<li>训练数据集大小和模型精度的关系：<ul>
<li>当训练数据集过小时，建立的模型精度过低，不具有参考价值。</li>
<li>随训练数据集尺寸增大，建立模型的分类精度也会随之增大。</li>
<li>当训练数据集尺寸增大到一定程度时，建立模型的精度不会再持续增大，且最大分类精度不会超过模型对训练数据的拟合度。</li>
</ul>
</li>
<li>测试数据集大小与模型精度的关系：<ul>
<li>当测试数据集过小时，所测模型精度不具有代表性，没有参考价值。</li>
<li>随测试数据集尺寸增大，模型精度也会随之增大。</li>
<li>当测试数据集尺寸增大到一定程度时，对模型精度的测量值不会再持续增大，并保持在某一数值上下微小浮动。</li>
</ul>
</li>
<li>属性个数对数据集大小与模型精度的关系的影响：<ul>
<li>当实例的属性个数过少时，所建模型精度低，没有参考价值。</li>
<li>随实例的属性个数增多，所建立模型的精度也会随之增大。</li>
</ul>
</li>
</ul>
<p>通过本次实验透彻的了解了决策树各种构造算法和剪枝算法，通过使用 Python 进行实现基本的决策树和简单的剪枝算法，锻炼了我的代码能力和对相应伪代码的理解能力。</p>
<p>在一开始，我对于决策树的整体没有认识，不知道如何从零开始构建一棵决策树，通过仔细研究课本，将思路从认识整体调整为模拟数据的流向。<br>首先定义参与到结构中的决策树的数据格式为 list 数组类型的嵌套。然后思考如何构建一棵决策树，自然而然想到的就是递归，通过返回节点的实例来递归建树。<br>下面碰到的问题就在于如何有机统一不同特征的不同的取值可能和在推理时的便利实现相结合，那么 Python 内建的 dict 字典类型就是很好的选择，通过设置特征的不同的可能取值为 key 值，对应的 value 为递归返回的结果，若连接的为叶节点，则 value 为 ‘0’ 或 ‘1’ 表示正负例，若为决策树的内部节点，则储存对应的对象，将查询请求递归处理直到叶节点。<br>下来就是漫长的 debug 时间，通过 pyCharm 方便的断点，我能成功复现每个异常发生时的程序情况，思考为什么会发生当前的状况和怎样进行修改。一开始我在实现后剪枝是还是给整个函数传入一整棵树，先递归到叶节点在向上逐层剪枝。但是在我仔细研究课本过后，发现书上给的顺序本就是自底向上的，所以只需要在建树时先剪枝再返回节点即可。</p>
<p>通过实现决策树和两个剪枝算法，我懂得了实际生活中，专业知识是怎样应用与实践的。同时了解了所谓的复现是什么，通过别人的描述重现他人的工作。了解到在实验中应该先彻底明白算法再进行复现，否则可能因为理解的偏差很多工作可能是错误的。为了最大化效率，应该先明确每个实现细节，在确定完了细节之后从下向上构建代码。</p>
]]></content>
      <categories>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实验课作业三——银行家算法</title>
    <url>/2021/05/06/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&ensp;&ensp;&ensp;&ensp;用C语言模拟银行家算法。个人实验报告使用，如果想参考，不得保留原文40%以上，谢谢配合。</p>
<span id="more"></span>

<h1 id="一、实验目的及要求"><a href="#一、实验目的及要求" class="headerlink" title="一、实验目的及要求"></a>一、实验目的及要求</h1><ul>
<li><p>通过编写和调试一个系统动态分配资源的简单模拟程序；  </p>
</li>
<li><p>观察死锁产生的条件 ； </p>
</li>
<li><p>模拟死锁避免的实现  ；</p>
</li>
<li><p>加深对死锁避免 ；</p>
</li>
<li><p>系统安全状态的理解；  </p>
</li>
<li><p>体会和了解死锁以及避免死锁的具体实现方法。  </p>
</li>
</ul>
<h1 id="二、基本理论介绍"><a href="#二、基本理论介绍" class="headerlink" title="二、基本理论介绍"></a>二、基本理论介绍</h1><h2 id="2-1-银行家算法"><a href="#2-1-银行家算法" class="headerlink" title="2.1 银行家算法"></a>2.1 银行家算法</h2><p>&ensp;&ensp;&ensp;&ensp;银行家算法（Banker’s Algorithm）是一个避免死锁（Deadlock）的著名算法，是由艾兹格·迪杰斯特拉在1965年为T.H.E系统设计的一种避免死锁产生的算法。<br>&ensp;&ensp;&ensp;&ensp;它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。</p>
<h2 id="2-2-安全状态"><a href="#2-2-安全状态" class="headerlink" title="2.2 安全状态"></a>2.2 安全状态</h2><p>&ensp;&ensp;&ensp;&ensp;如果存在一个由系统中所有进程构成的安全序列P1，…，Pn，则系统处于安全状态。安全状态一定是没有死锁发生。</p>
<h2 id="2-3-不安全状态"><a href="#2-3-不安全状态" class="headerlink" title="2.3 不安全状态"></a>2.3 不安全状态</h2><p>&ensp;&ensp;&ensp;&ensp;不存在一个安全序列。不安全状态不一定导致死锁。</p>
<h2 id="2-4-银行家算法所涉及的数据结构"><a href="#2-4-银行家算法所涉及的数据结构" class="headerlink" title="2.4 银行家算法所涉及的数据结构"></a>2.4 银行家算法所涉及的数据结构</h2><h3 id="1）可利用资源向量Available"><a href="#1）可利用资源向量Available" class="headerlink" title="1）可利用资源向量Available"></a>1）可利用资源向量Available</h3><p>&ensp;&ensp;&ensp;&ensp;是个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果Available[j]=K，则表示系统中现有Rj类资源K个。</p>
<h3 id="2）最大需求矩阵Max"><a href="#2）最大需求矩阵Max" class="headerlink" title="2）最大需求矩阵Max"></a>2）最大需求矩阵Max</h3><p>&ensp;&ensp;&ensp;&ensp;这是一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rj类资源的最大数目为K。</p>
<h3 id="3）分配矩阵Allocation"><a href="#3）分配矩阵Allocation" class="headerlink" title="3）分配矩阵Allocation"></a>3）分配矩阵Allocation</h3><p>&ensp;&ensp;&ensp;&ensp;这也是一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得Rj类资源的 数目为K。</p>
<h3 id="4）需求矩阵Need。"><a href="#4）需求矩阵Need。" class="headerlink" title="4）需求矩阵Need。"></a>4）需求矩阵Need。</h3><p>&ensp;&ensp;&ensp;&ensp;这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K，则表示进程i还需要Rj类资源K个，方能完成其任务。<br>Need[i,j]=Max[i,j]-Allocation[i,j]</p>
<h1 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h1><ol>
<li>设计进程管理数据结构</li>
<li>输入系统资源当前的使用情况，如：系统当前的进程数、各进程的资源信息等</li>
<li>设计安全性检查算法检查系统状态是否安全</li>
<li>动态申请资源，设计银行家算法，在银行家算法中调用安全性检查算法，判断本次申请是否能够满足，进行资源分配</li>
<li>输出每次分配后的安全序列，及系统当前资源分配信息</li>
</ol>
<h1 id="四、功能实现"><a href="#四、功能实现" class="headerlink" title="四、功能实现"></a>四、功能实现</h1><h2 id="4-1-银行家算法实现"><a href="#4-1-银行家算法实现" class="headerlink" title="4.1 银行家算法实现"></a>4.1 银行家算法实现</h2><p>&ensp;&ensp;&ensp;&ensp;在避免死锁的方法中，所施加的限制条件较弱，有可能获得令人满意的系统性能。在该方法中把系统的状态分为安全状态和不安全状态，只要能使系统始终都处于安全状态，便可以避免发生死锁。<br>&ensp;&ensp;&ensp;&ensp;银行家算法的基本思想是分配资源之前，判断系统是否是安全的；若是，才分配。它是最具有代表性的避免死锁的算法。<br>&ensp;&ensp;&ensp;&ensp;设进程cusneed提出请求REQUEST [i]，则银行家算法按如下规则进行判断。<br>&ensp;&ensp;&ensp;&ensp;(1)如果REQUEST [cusneed] [i]&lt;= NEED[cusneed][i]，则转(2)；否则，出错。<br>&ensp;&ensp;&ensp;&ensp;(2)如果REQUEST [cusneed] [i]&lt;= AVAILABLE[i]，则转(3)；否则，等待。<br>&ensp;&ensp;&ensp;&ensp;(3)系统试探分配资源，修改相关数据：<br>&ensp;&ensp;&ensp;&ensp;AVAILABLE[i]-=REQUEST[cusneed][i];<br>&ensp;&ensp;&ensp;&ensp;ALLOCATION[cusneed][i]+=REQUEST[cusneed][i];<br>&ensp;&ensp;&ensp;&ensp;NEED[cusneed][i]-=REQUEST[cusneed][i];<br>&ensp;&ensp;&ensp;&ensp;(4)系统执行安全性检查，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待。  </p>
<h2 id="4-2-安全性检查算法"><a href="#4-2-安全性检查算法" class="headerlink" title="4.2 安全性检查算法"></a>4.2 安全性检查算法</h2><p>&ensp;&ensp;&ensp;&ensp;(1)设置两个工作向量Work=AVAILABLE;FINISH<br>&ensp;&ensp;&ensp;&ensp;(2)从进程集合中找到一个满足下述条件的进程，<br>&ensp;&ensp;&ensp;&ensp;FINISH==false;<br>&ensp;&ensp;&ensp;&ensp;NEED&lt;=Work;<br>&ensp;&ensp;&ensp;&ensp;如找到，执行（3)；否则，执行（4)<br>&ensp;&ensp;&ensp;&ensp;(3)设进程获得资源，可顺利执行，直至完成，从而释放资源。<br>&ensp;&ensp;&ensp;&ensp;Work=Work+ALLOCATION;<br>&ensp;&ensp;&ensp;&ensp;Finish=true;<br>&ensp;&ensp;&ensp;&ensp;转到（2）<br>&ensp;&ensp;&ensp;&ensp;(4)如所有的进程Finish= true，则表示安全；否则系统不安全。  </p>
<h2 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> processNum 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> resourceNum 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXINT 9999</span></span><br><span class="line"><span class="keyword">int</span> avaliable[resourceNum] = &#123; <span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> max[processNum][resourceNum] = &#123;<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> allocation[processNum][resourceNum] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> need[processNum][resourceNum] = &#123;<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> finish[processNum];</span><br><span class="line"><span class="keyword">int</span> request[resourceNum];</span><br><span class="line"><span class="keyword">int</span> safeSeries[processNum] = &#123; MAXINT, MAXINT , MAXINT , MAXINT , MAXINT &#125;;</span><br><span class="line"><span class="comment">//int processNum, resourceNum;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入进程和资源数量，用空格分开\n&quot;</span>);</span><br><span class="line">	<span class="comment">//scanf(&quot;%d%d&quot;, &amp;processNum, &amp;resourceNum);</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入当前可用资源数\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; resourceNum; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;avaliable[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入最大需求矩阵\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; processNum; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;max[i][j]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入分配矩阵\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; processNum; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;allocation[i][j]);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; processNum; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++)</span><br><span class="line">			need[i][j] = max[i][j] - allocation[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;当前资源剩余:&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, avaliable[j]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;进程名\t Max\t \tAllocation\tNeed\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; processNum; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; P%d\t&quot;</span>, i);</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, max[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\t\t&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, allocation[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\t\t&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, need[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Safeinfo</span><span class="params">(<span class="keyword">int</span>* work, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isSafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> truefinished = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> work[resourceNum];</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; resourceNum; i++)</span><br><span class="line">		work[i] = avaliable[i];</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; processNum; i++)</span><br><span class="line">		finish[i] = <span class="literal">false</span>;</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> temp0;</span><br><span class="line">	<span class="keyword">while</span> (truefinished != processNum) &#123;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (finish[i] != <span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++)</span><br><span class="line">				<span class="keyword">if</span> (need[i][j] &gt; work[j]) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (j == resourceNum) &#123;</span><br><span class="line">			finish[i] = <span class="literal">true</span>;</span><br><span class="line">			<span class="built_in">Safeinfo</span>(work, i);</span><br><span class="line">			<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; resourceNum; k++) &#123;</span><br><span class="line">				work[k] += allocation[i][k];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> k2;</span><br><span class="line">			safeSeries[truefinished++] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= processNum) &#123;</span><br><span class="line">			<span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">				temp = truefinished;</span><br><span class="line">				temp0 = truefinished;</span><br><span class="line">			&#125;</span><br><span class="line">			i = i % processNum;</span><br><span class="line">			<span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">				temp = truefinished;</span><br><span class="line">				<span class="keyword">if</span> (temp == temp0)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					temp0 = temp;</span><br><span class="line">			&#125;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = truefinished;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (truefinished == processNum) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n系统安全,\n\n安全序列为：&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; processNum; i++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, safeSeries[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;******系统不安全******\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Safeinfo</span><span class="params">(<span class="keyword">int</span>* work, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; P%d\t&quot;</span>, i);</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, work[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\t&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, need[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t &quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, allocation[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\t&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, allocation[i][j] + work[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, curProcess;</span><br><span class="line">	<span class="keyword">int</span> wheInit = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (wheInit)</span><br><span class="line">		<span class="comment">//Init();</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;---------------------------------------------------------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">showin</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n系统安全情况分析\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; PID\t Work\t\tNeed\tAllocation\tWork+Allocation\n&quot;</span>);</span><br><span class="line">	<span class="built_in">isSafe</span>();</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n---------------------------------------------------------\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n输入要分配的进程：&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;curProcess);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n输入要分配给进程P%d的资源：&quot;</span>, curProcess);</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;request[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (request[j] &lt;= need[curProcess][j])<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;ERROR！\n&quot;</span>); <span class="keyword">break</span>; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (j == resourceNum) &#123;</span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (request[j] &lt;= need[curProcess][j])<span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;资源不足，等待中！\n&quot;</span>); <span class="keyword">break</span>; &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (j == resourceNum) &#123;</span><br><span class="line">				<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">					avaliable[j] -= request[j];</span><br><span class="line">					allocation[curProcess][j] += request[j];</span><br><span class="line">					need[curProcess][j] -= request[j];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;\n系统安全情况分析\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot; PID\t Work\t\tNeed\tAllocation\tWork+Allocation\n&quot;</span>);</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">isSafe</span>()) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;分配成功！\n&quot;</span>);</span><br><span class="line">					<span class="built_in">showin</span>();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">						avaliable[j] += request[j];</span><br><span class="line">						allocation[curProcess][j] -= request[j];</span><br><span class="line">						need[curProcess][j] += request[j];</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;分配失败！\n&quot;</span>);</span><br><span class="line">					<span class="built_in">showin</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、结果测试与分析"><a href="#五、结果测试与分析" class="headerlink" title="五、结果测试与分析"></a>五、结果测试与分析</h1><p>&ensp;&ensp;&ensp;&ensp;以下为部分运行结果截图：</p>
<p><img src="/2021/05/06/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/%E5%88%86%E9%85%8D%E6%88%90%E5%8A%9F.png" alt="分配成功"><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;图1 分配成功<br><img src="/2021/05/06/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/%E5%88%86%E9%85%8D%E5%A4%B1%E8%B4%A5.png" alt="分配失败"><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;图2 分配失败   </p>
<p>&ensp;&ensp;&ensp;&ensp;分析略</p>
<h1 id="六、心得体会"><a href="#六、心得体会" class="headerlink" title="六、心得体会"></a>六、心得体会</h1><p>&ensp;&ensp;&ensp;&ensp;以上文字和代码仅供参考，请勿直接复制用于完成作业。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>实验课作业</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实验课作业四——动态分区内存管理</title>
    <url>/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&ensp;&ensp;&ensp;&ensp;用C语言模拟动态分区分配算法。本篇实验报告用于上交期末课程作业，图文请勿抄袭，谢谢配合。一经发现，必定追究。</p>
<span id="more"></span>

<h1 id="一、实验目的及要求"><a href="#一、实验目的及要求" class="headerlink" title="一、实验目的及要求"></a>一、实验目的及要求</h1><p>&ensp;&ensp;&ensp;&ensp;本实验要求用高级语言编写模拟内存的动态分区分配和回收算法（不考虑紧凑），以便加深理解。<br>&ensp;&ensp;&ensp;&ensp;1.分配：实现首次适应算法（FF）、循环首次适应算法(NF)、最佳适应算法（BF），最坏适应算法(WF)的具体实现。<br>&ensp;&ensp;&ensp;&ensp;2.空闲分区的回收，需考虑合并问题。  </p>
<h1 id="二、基本理论介绍"><a href="#二、基本理论介绍" class="headerlink" title="二、基本理论介绍"></a>二、基本理论介绍</h1><h2 id="2-1-动态分区分配"><a href="#2-1-动态分区分配" class="headerlink" title="2.1 动态分区分配"></a>2.1 动态分区分配</h2><p> &ensp;&ensp;&ensp;&ensp;动态分区是指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。<br> &ensp;&ensp;&ensp;&ensp;动态分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分。这种存储管理技术是固定式分区的改进，既可以获得较大的灵活性，又能提高内存的利用率。<br> &ensp;&ensp;&ensp;&ensp;特点：分区的大小是可变的，分区的数目也是可变的。  </p>
<h2 id="2-2-空闲分区表"><a href="#2-2-空闲分区表" class="headerlink" title="2.2 空闲分区表"></a>2.2 空闲分区表</h2><p>&ensp;&ensp;&ensp;&ensp;空闲分区表为每个尚未分配的分区设置一个表项，包括分区的序号、大小、始址和状态。如下表：  </p>
<table>
<thead>
<tr>
<th>序号</th>
<th>大小</th>
<th>起址</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>48k</td>
<td>116k</td>
<td>空闲</td>
</tr>
<tr>
<td>2</td>
<td>252k</td>
<td>260k</td>
<td>空闲</td>
</tr>
</tbody></table>
<h2 id="2-3-空闲分区链"><a href="#2-3-空闲分区链" class="headerlink" title="2.3 空闲分区链"></a>2.3 空闲分区链</h2><p>&ensp;&ensp;&ensp;&ensp;为了实现对空闲分区的分配和链接，在每个分区的起始部分，设置一些用于控制分区分配的信息以及用于链接其它分区的前向指针；在分区尾部，则设置了一个后向指针。通过前、后向指针将所有的分区链接成一个双向链表。</p>
<h2 id="2-4-所涉及到的各个算法"><a href="#2-4-所涉及到的各个算法" class="headerlink" title="2.4 所涉及到的各个算法"></a>2.4 所涉及到的各个算法</h2><p><strong>1）首次适应算法（FF）</strong><br>&ensp;&ensp;&ensp;&ensp;空闲分区表(链)按低址―&gt;高址链接；<br>&ensp;&ensp;&ensp;&ensp;从表首顺序查找，找到第一个适合的空闲区，从该分区划出适当空间分配给请求者，余下的空闲分区更新数据后，仍然留空闲分区表(链)中。<br>&ensp;&ensp;&ensp;&ensp;回收过程：若有相邻空闲区，则合并；否则，将释放区按首地址升序的规则插入到空闲区表适当的位置。  </p>
<p>&ensp;&ensp;&ensp;&ensp;优点：<br>&ensp;&ensp;&ensp;&ensp;保留高地址大空闲区，利于大作业。<br>&ensp;&ensp;&ensp;&ensp;缺点：<br>&ensp;&ensp;&ensp;&ensp;a）容易产生碎片；<br>&ensp;&ensp;&ensp;&ensp;b）低地址端过多小空闲区，增加查找开销  </p>
<p><strong>2）循环首次适应算法(NF)</strong><br>&ensp;&ensp;&ensp;&ensp;按地址递增的顺序链接，从上一次分配的下一个地址开始查找，找到第一个适合的空闲区。划出适当空间分配给请求者，余下的空闲分区更新数据后，仍然留空闲分区表(链)中。</p>
<p>&ensp;&ensp;&ensp;&ensp;优点：使存储空间更均衡，便于查找<br>&ensp;&ensp;&ensp;&ensp;缺点：缺乏大的空闲分区，不利于大作业。  </p>
<p><strong>3）最佳适应算法（BF）</strong><br>&ensp;&ensp;&ensp;&ensp;以容量递增的次序链接，从表(链)首开始顺序查找，直到找到第一个适合的空闲分区。若该空闲区大于作业，则划出适当空间分配出去，剩余空闲区仍留在空闲分区表(链)中。</p>
<p>&ensp;&ensp;&ensp;&ensp;优点：找到的空闲区总既满足要求又是最小的。<br>&ensp;&ensp;&ensp;&ensp;缺点：留下较小的无法利用的外碎片。</p>
<p><strong>4）最坏适应算法(WF)</strong><br>&ensp;&ensp;&ensp;&ensp;要求空闲分区按容量递减排列，从表(链)首开始顺序查找，若第一个表目都不能满足要求，分配失败，否则，划出适当分区给申请者，剩余空闲区插入空闲区表适当位置。  </p>
<p>&ensp;&ensp;&ensp;&ensp;优点：基本不留小分区<br>&ensp;&ensp;&ensp;&ensp;缺点：较大的空闲分区不被保留。  </p>
<h1 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h1><p>&ensp;&ensp;&ensp;&ensp;本实验主要针对操作系统中内存管理相关理论进行实验，要求实验者编写一个程序，该程序管理一块虚拟内存，实现内存分配和回收功能  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）设计内存分配的数据结构（空闲分区表/空闲分区链），模拟管理64M的内存块；<br>&ensp;&ensp;&ensp;&ensp;（2）设计内存分配函数；<br>&ensp;&ensp;&ensp;&ensp;（3）设计内存回收函数；<br>&ensp;&ensp;&ensp;&ensp;（4）实现动态分配和回收操作；<br>&ensp;&ensp;&ensp;&ensp;（5）可动态显示每个内存块信息。  </p>
<h1 id="四、功能实现"><a href="#四、功能实现" class="headerlink" title="四、功能实现"></a>四、功能实现</h1><h2 id="4-1-设计内存分配的数据结构"><a href="#4-1-设计内存分配的数据结构" class="headerlink" title="4.1 设计内存分配的数据结构"></a>4.1 设计内存分配的数据结构</h2><p> <strong>1）定义空闲分区表</strong><br>&ensp;&ensp;&ensp;&ensp;由空闲分区表的定义可知，该数据结构包含以下几项：分区的序号、大小、始址和状态。<br>&ensp;&ensp;&ensp;&ensp;在程序中定义如下所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%88%86%E5%8C%BA%E8%A1%A8.png"> </p>
<p>&ensp;&ensp;&ensp;&ensp;其中id表示序号，base表示该分区的起始地址，size表示该分区的起始地址，status表示该分区的状态，用-1表示该分区空闲。<br><strong>2）定义空闲分区链</strong><br>&ensp;&ensp;&ensp;&ensp;由空闲分区链的定义可知，该数据结构包含以下几项：前向指针、后向指针，指向该分区块的指针（即能够包含该节点指向的分区块的信息）。空闲分区链图示如下：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9B%BE%E7%89%8713.png">  </p>
<p>在程序中定义如下：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%88%86%E5%8C%BA%E9%93%BE.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;其中，node指向该分区，包含该分区的信息，front和next分别为前向指针和后向指针。</p>
<h2 id="4-2-实现内存分配函数"><a href="#4-2-实现内存分配函数" class="headerlink" title="4.2 实现内存分配函数"></a>4.2 实现内存分配函数</h2><p><strong>1）首次适应算法（FF）</strong><br>&ensp;&ensp;&ensp;&ensp;根据首次适应算法的思想，程序实现的流程图如下所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/ff%E6%B5%81%E7%A8%8B%E5%9B%BE.png"> </p>
<p>&ensp;&ensp;&ensp;&ensp;首先从已建立好的数组中顺序查找，直至找到第一个大小能满足的空闲分区为止，然后按照作业大小，从该分区中划出一块内存空间分配给请求者，余下的空间开辟一块新的地址，大小为原来的大小减去作业大小，若查找结束都不能找到一个满足要求的分区，则此次内存分配失败。</p>
<p><strong>2）循环首次适应算法（NF）</strong><br>&ensp;&ensp;&ensp;&ensp;根据循环首次适应算法的思想，程序实现的流程图如下所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/nf%E6%B5%81%E7%A8%8B%E5%9B%BE.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;在为进程分配内存空间时，从上次找到的空闲分区的下一个空闲分区开始查找，直至找到第一个能满足要求的空闲分区，从中划出一块与请求大小相等的内存空间分配给作业。具体实现本算法时，除了将首次适应算法的开始地址从第一个空闲区的起始地址变为上次找到的空闲区的下个地址外，还要设置一个标志量，只有当全部空闲区都查找完毕，仍旧找不到一个满足要求的分区时，此次内存才分配失败。</p>
<p><strong>3）最佳适应算法（BF）</strong><br>&ensp;&ensp;&ensp;&ensp;根据最佳适应算法的思想，程序实现的流程图如下所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/bf%E6%B5%81%E7%A8%8B%E5%9B%BE.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;当使用最佳适应算法分配时，先遍历一遍空闲区，将大于作业大小的空闲区放入数组，取出其中最小的分区，从中划出一块与作业大小相等的空间分配给该作业。</p>
<p><strong>4）最坏适应算法(WF)</strong><br>&ensp;&ensp;&ensp;&ensp;根据最坏适应算法的思想，程序实现的流程图如下所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/wf%E6%B5%81%E7%A8%8B%E5%9B%BE.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;和最佳适应算法相类似，同样是在分配前先遍历一遍空闲区，找出大于该作业大小的空闲区，并将其放入数组，在其中取出空间最大的分区，从中划出一块与作业大小相等的空间分配给该作业。</p>
<h2 id="4-3-实现内存分配回收功能"><a href="#4-3-实现内存分配回收功能" class="headerlink" title="4.3 实现内存分配回收功能"></a>4.3 实现内存分配回收功能</h2><p>&ensp;&ensp;&ensp;&ensp;内存分配回收有四种情况，前一个分区空闲后一个分区不空闲，前一个分区不空闲后一个分区空闲，前后分区都不空闲，前后分区都空闲。可以将其合并为两种情况，即如果回收分区不是最后一个分区并且后一个分区空闲，则与后一个分区合并（前一个分区不空闲后一个分区空闲，前后分区都空闲），如果分区不是第一个空闲分区且前一个分区为空闲，则与前一个分区合并（前一个分区空闲后一个分区不空闲，前后分区都空闲）。<br>&ensp;&ensp;&ensp;&ensp;根据该思路的内存回收策略流程图如下所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;在程序中用四个if语句实现该流程图，除了上面提到的两种分类方式外，还需要特判该分区号的存在与否和该分区是否已被分配。</p>
<h1 id="五、结果测试与分析"><a href="#五、结果测试与分析" class="headerlink" title="五、结果测试与分析"></a>五、结果测试与分析</h1><h2 id="5-1-测试数据的选取"><a href="#5-1-测试数据的选取" class="headerlink" title="5.1 测试数据的选取"></a>5.1 测试数据的选取</h2><table>
<thead>
<tr>
<th>序号</th>
<th>操作</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Req</td>
<td>40M</td>
</tr>
<tr>
<td>2</td>
<td>Req</td>
<td>10M</td>
</tr>
<tr>
<td>3</td>
<td>Release</td>
<td>40M</td>
</tr>
<tr>
<td>4</td>
<td>Req</td>
<td>12M</td>
</tr>
<tr>
<td>5</td>
<td>Req</td>
<td>8M</td>
</tr>
<tr>
<td>6</td>
<td>Req</td>
<td>6M</td>
</tr>
<tr>
<td>7</td>
<td>Req</td>
<td>4M</td>
</tr>
<tr>
<td>8</td>
<td>Release</td>
<td>6M</td>
</tr>
</tbody></table>
<p>&ensp;&ensp;&ensp;&ensp;选取以上八个操作作为测试数据，来检验代码能否正确采取某一种分配策略和回收内存。下面依次将各个算法的运行结果与应得的结果进行比较。</p>
<h2 id="5-2-结果比较与分析"><a href="#5-2-结果比较与分析" class="headerlink" title="5.2 结果比较与分析"></a>5.2 结果比较与分析</h2><p><strong>1）首次适应算法</strong><br>&ensp;&ensp;&ensp;&ensp;由首次适应算法的思想，测试案例各个步骤在系统内如下所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/FF%E7%B3%BB%E7%BB%9F.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;即在最后的结果中，系统一共有7个区块，其中0-12M为12M大小的作业区，12-20M为8M大小的作业区，20-26M为6M大小的空闲区，26-30M为4M大小的作业区，30-40M为10M大小的空闲区，40-50M为10M大小的作业区，50-64M为14M大小的空闲区。<br>&ensp;&ensp;&ensp;&ensp;将相应数据输入到程序中，得到结果如下图所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/FF%E7%BB%93%E6%9E%9C%E5%9B%BE.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;可以看到内存分配策略和回收的功能都可以正确执行，程序最后得到的结果与预先得到的结果相一致，说明实验正确。</p>
<p><strong>2）循环首次适应算法</strong><br>&ensp;&ensp;&ensp;&ensp;由循环首次适应算法的思想，测试案例各个步骤在系统内如下所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/NF%E7%B3%BB%E7%BB%9F.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;即在最后的结果中，系统一共有7个区块，其中0-8M为8M大小的作业区，8-14M为6M大小的空闲区，14-18M为4M大小的作业区，18-40M为22M大小的空闲区，40-50M为10M大小的作业区，50-62M为12M大小的空闲区。<br>&ensp;&ensp;&ensp;&ensp;用该算法将相应数据输入到程序中，得到结果如下：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/BF%E7%BB%93%E6%9E%9C%E5%9B%BE.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;同样将该结果与预先得到的结果进行比较，发现能够得到理想的结果。</p>
<p><strong>3）最佳适应算法</strong><br>&ensp;&ensp;&ensp;&ensp;由最佳适应算法的思想，测试案例各个步骤在系统内如下所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/BF%E7%B3%BB%E7%BB%9F.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;即在最后的结果中，系统一共有7个区块，其中0-8M为8M大小的作业区，8-14M为6M大小的空闲区，14-18M为4M大小的作业区，18-40M为22M大小的空闲区，40-50M为10M大小的作业区，50-62M为12M大小的空闲区。<br>&ensp;&ensp;&ensp;&ensp;用该算法将相应数据输入到程序中，得到结果如下：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/BF%E7%BB%93%E6%9E%9C%E5%9B%BE.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;同样将该结果与预先得到的结果进行比较，发现能够得到理想的结果，并且发现该结果与循环首次适应算法得到的结果相同，于是重复多次修改了案例，也能得到正确的结果，证明实验是可行的。</p>
<p><strong>4）最坏适应算法</strong><br>&ensp;&ensp;&ensp;&ensp;由最坏适应算法的思想，测试案例各个步骤在系统内如下所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/FF%E7%B3%BB%E7%BB%9F.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;即在最后的结果中，系统一共有7个区块，其中0-12M为12M大小的作业区，12-20M为8M大小的作业区，20-26M为6M大小的空闲区，26-30M为4M大小的作业区，30-40M为10M大小的空闲区，40-50M为10M大小的作业区，50-64M为14M大小的空闲区。<br>&ensp;&ensp;&ensp;&ensp;将相应数据输入到程序中，得到结果如下图所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/WF%E7%BB%93%E6%9E%9C%E5%9B%BE.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;发现在该组测试样例下，得到的结果与首次适应算法相一致，尝试在原本的测试样例上再多加入一个5M大小的请求，由于最坏适应算法优先寻找最大的空闲区，所以会在最后一块（即大小为14M）的空闲区划分出相应大小的区域，而首次适应算法会将其分配于最前面，（即大小为6M）的空闲区。加入测试样例后，WF算法得到结果如下：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/WF%E7%BB%93%E6%9E%9C%E5%9B%BE2.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;得到的结果与由该算法思想得到的结果相一致，说明WF算法可以按照正确的分配策略运行，实验结果理想。</p>
<h1 id="六、心得体会"><a href="#六、心得体会" class="headerlink" title="六、心得体会"></a>六、心得体会</h1><p>&ensp;&ensp;&ensp;&ensp;本次实验要求模拟动态分区分配算法，在开始该实验前，首先要做的是理解并实现动态分区分配算法所涉及到的数据结构。该种分配方式下主要有空闲分区表和空闲分区链两种数据结构，在程序中前者用于存储各个分区的状态，包括大小，起始地址，序号和该区块空闲与否，后者则用来实现区块的划分和分配。只有理解了数据结构的原理，才能在后续具体的算法实现中，灵活的应用不同的数据结构得到我们想要的功能。<br>&ensp;&ensp;&ensp;&ensp;在各个算法具体实现之前，我结合算法的思想和分配策略，作出了每个算法的流程图，后续的程序都按照流程图的思路来设计，这其中也有不断发现错误返工修改流程图和程序的过程，最终是参考了网上的一些思路，将流程图和程序进行了完善。在具体实现算法时，我先完成了首次适应算法和最佳适应算法，因为循环首次适应算法和最坏适应算法的分配策略与前两者的分配策略相似，在以首次适应和最佳适应为基础框架后，略作修改便能实现循环首次适应算法和最坏适应算法。<br>&ensp;&ensp;&ensp;&ensp;实现资源回收时主要涉及到的问题是分类问题，一开始将情况想的太复杂，对于四个不一样的情况（详情见4.3）都进行特判，导致程序冗杂并且不能正确实现相关功能，后来将其分为两个大类，问题才迎刃而解，这也加深了我对算法的应用，以及资源回收及合并的理解。<br>&ensp;&ensp;&ensp;&ensp;在最后的结果测试方面，为了体现出各个算法分配策略的不同，我作出了系统中不同算法的图示，但由于测试所用的数据是根据作业4略作修改得来的，因此在实际的执行过程中，发现最坏适应算法和首次适应算法得到的结果相一致，为了体现出这两种算法分配策略的区别，我在使用最坏适应算法的程序样例中多加了一个测试点，发现能够得到理想的结果，后续修改多组数据进行测试也能得到正确的结果，说明该实验是成功的。<br>&ensp;&ensp;&ensp;&ensp;本次实验中，我对各个分配算法有了更加深刻的认识，加深了对算法的应用和技巧，在探索的过程中也加强了自主学习的能力和兴趣。</p>
<h1 id="七、附录代码"><a href="#七、附录代码" class="headerlink" title="七、附录代码"></a>七、附录代码</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lei_item</span>       </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;                </span><br><span class="line">	<span class="keyword">int</span> base;              </span><br><span class="line">	<span class="keyword">int</span> size;              </span><br><span class="line">	<span class="keyword">int</span> status;             </span><br><span class="line">&#125;Item;</span><br><span class="line"><span class="keyword">typedef</span> Item datatype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lei_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	datatype* node;      </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lei_list</span>* <span class="title">front</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lei_list</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;List;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max 64</span></span><br><span class="line"><span class="keyword">int</span> memory = Max;       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">init</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">	List <span class="built_in">list</span>;</span><br><span class="line">	<span class="built_in">list</span>.node = (datatype *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(datatype));</span><br><span class="line">	<span class="built_in">list</span>.node-&gt;base = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">list</span>.node-&gt;id = <span class="number">-1</span>;                    </span><br><span class="line">	<span class="built_in">list</span>.node-&gt;size = memory;</span><br><span class="line">	<span class="built_in">list</span>.node-&gt;status = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">list</span>.front = <span class="built_in">list</span>.next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">datatype* <span class="title">input</span><span class="params">()</span> </span>&#123;          </span><br><span class="line">	datatype* item = (datatype *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(datatype));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入作业号：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;item-&gt;id);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入所需要的内存的大小：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;item-&gt;size);</span><br><span class="line">	item-&gt;status = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Momery_state</span><span class="params">(List *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">	List* temp = <span class="built_in">list</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-----------------------------------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;内存分配状况\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-----------------------------------\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (temp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (temp-&gt;node-&gt;status == <span class="number">0</span> &amp;&amp; temp-&gt;node-&gt;id == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;分区号：0\n&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;起始地址：%d\n&quot;</span>, temp-&gt;node-&gt;base);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;内存大小：%d\n&quot;</span>, temp-&gt;node-&gt;size);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;分区状态：空闲\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;分区号：%d\t起始地址：%d\n&quot;</span>, temp-&gt;node-&gt;id, temp-&gt;node-&gt;base);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;内存大小：%d\n&quot;</span>, temp-&gt;node-&gt;size);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;分区状态：已分配\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-----------------------------------\n&quot;</span>);</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">First_fit</span><span class="params">(List *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">	datatype* item = input();</span><br><span class="line">	List* temp = <span class="built_in">list</span>;                     </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (temp)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (temp-&gt;node-&gt;status == <span class="number">0</span> &amp;&amp; temp-&gt;node-&gt;size &gt; item-&gt;size) &#123;       </span><br><span class="line">			List *front = temp-&gt;front;                                         </span><br><span class="line">			List *next = temp-&gt;next;                                            </span><br><span class="line">			<span class="keyword">int</span> base = temp-&gt;node-&gt;base;                                     </span><br><span class="line"></span><br><span class="line">			datatype* new_node = (datatype*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(datatype));        </span><br><span class="line">			new_node-&gt;id = <span class="number">-1</span>;                                                </span><br><span class="line">			new_node-&gt;size = temp-&gt;node-&gt;size - item-&gt;size;         </span><br><span class="line"></span><br><span class="line">			temp-&gt;node = item;                                </span><br><span class="line">			temp-&gt;node-&gt;status = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			new_node-&gt;status = <span class="number">0</span>;</span><br><span class="line">			new_node-&gt;base = base + temp-&gt;node-&gt;size;             </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			List* temp_next = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));           </span><br><span class="line">			temp_next-&gt;node = new_node;                             </span><br><span class="line">			temp_next-&gt;front = temp_next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (front == <span class="literal">NULL</span> &amp;&amp; next == <span class="literal">NULL</span>) &#123;                      </span><br><span class="line">				temp-&gt;node-&gt;base = <span class="number">0</span>;                               </span><br><span class="line">				temp-&gt;next = temp_next;</span><br><span class="line">				temp_next-&gt;front = temp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (front == <span class="literal">NULL</span> &amp;&amp; next != <span class="literal">NULL</span>) &#123;                 </span><br><span class="line">				temp-&gt;node-&gt;base = <span class="number">0</span>;</span><br><span class="line">				temp-&gt;node-&gt;status = <span class="number">1</span>;</span><br><span class="line">				temp_next-&gt;next = temp-&gt;next;</span><br><span class="line">				temp-&gt;next = temp_next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (front != <span class="literal">NULL</span>) &#123;                      </span><br><span class="line">				temp-&gt;node-&gt;base = temp-&gt;front-&gt;node-&gt;base + temp-&gt;front-&gt;node-&gt;size;       </span><br><span class="line">				temp_next-&gt;next = temp-&gt;next;                                       </span><br><span class="line">				temp_next-&gt;front = temp;                            </span><br><span class="line">				temp-&gt;next = temp_next;                             </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (temp-&gt;node-&gt;status == <span class="number">0</span> &amp;&amp; temp-&gt;node-&gt;size == item-&gt;size)</span><br><span class="line">		&#123;</span><br><span class="line">			item-&gt;base = temp-&gt;front-&gt;node-&gt;base + temp-&gt;front-&gt;node-&gt;size;               </span><br><span class="line">			item-&gt;status = <span class="number">1</span>;                                           </span><br><span class="line">			temp-&gt;node = item;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">next_fit</span><span class="params">(List *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">	datatype* item = input();</span><br><span class="line">	List* temp = <span class="built_in">list</span>;                      </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (temp)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (temp-&gt;node-&gt;status == <span class="number">0</span> &amp;&amp; temp-&gt;node-&gt;size &gt; item-&gt;size) &#123;       </span><br><span class="line">			List *front = temp-&gt;front;                                         </span><br><span class="line">			List *next = temp-&gt;next;                                            </span><br><span class="line">			<span class="keyword">int</span> base = temp-&gt;node-&gt;base;                                     </span><br><span class="line"></span><br><span class="line">			datatype* new_node = (datatype*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(datatype));          </span><br><span class="line">			new_node-&gt;id = <span class="number">-1</span>;                                                 </span><br><span class="line">			new_node-&gt;size = temp-&gt;node-&gt;size - item-&gt;size;         </span><br><span class="line"></span><br><span class="line">			temp-&gt;node = item;                                 </span><br><span class="line">			temp-&gt;node-&gt;status = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			new_node-&gt;status = <span class="number">0</span>;</span><br><span class="line">			new_node-&gt;base = base + temp-&gt;node-&gt;size;            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			List* temp_next = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));           </span><br><span class="line">			temp_next-&gt;node = new_node;                             </span><br><span class="line">			temp_next-&gt;front = temp_next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">   </span><br><span class="line">			<span class="keyword">if</span> (front == <span class="literal">NULL</span> &amp;&amp; next == <span class="literal">NULL</span>) &#123;                      </span><br><span class="line">				temp-&gt;node-&gt;base = <span class="number">0</span>;                              </span><br><span class="line">				temp-&gt;next = temp_next;</span><br><span class="line">				temp_next-&gt;front = temp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (front == <span class="literal">NULL</span> &amp;&amp; next != <span class="literal">NULL</span>) &#123;                </span><br><span class="line">				temp-&gt;node-&gt;base = <span class="number">0</span>;</span><br><span class="line">				temp-&gt;node-&gt;status = <span class="number">1</span>;</span><br><span class="line">				temp_next-&gt;next = temp-&gt;next;</span><br><span class="line">				temp-&gt;next = temp_next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (front != <span class="literal">NULL</span>) &#123;                      </span><br><span class="line">				temp-&gt;node-&gt;base = <span class="number">0</span>;									</span><br><span class="line">				temp_next-&gt;next = temp-&gt;next;                               </span><br><span class="line">				temp_next-&gt;front = temp;                              </span><br><span class="line">				temp-&gt;next = temp_next;                             </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (temp-&gt;node-&gt;status == <span class="number">0</span> &amp;&amp; temp-&gt;node-&gt;size == item-&gt;size)</span><br><span class="line">		&#123;</span><br><span class="line">			item-&gt;base = temp-&gt;front-&gt;node-&gt;base + temp-&gt;front-&gt;node-&gt;size;            </span><br><span class="line">			item-&gt;status = <span class="number">1</span>;                                          </span><br><span class="line">			temp-&gt;node = item;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Momory_recycle</span><span class="params">(List *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">	List* temp = <span class="built_in">list</span>;                      </span><br><span class="line">	<span class="keyword">int</span> number;                         </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入需要回收的ID号：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">	<span class="keyword">while</span> (temp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (temp-&gt;node-&gt;id == number)             </span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (temp-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				temp-&gt;node-&gt;status = <span class="number">0</span>;</span><br><span class="line">				temp-&gt;node-&gt;id = <span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">if</span> (temp-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">					temp-&gt;node-&gt;size = temp-&gt;node-&gt;size + temp-&gt;next-&gt;node-&gt;size;</span><br><span class="line">					temp-&gt;next = temp-&gt;next;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (temp-&gt;next-&gt;node-&gt;id == <span class="number">-1</span> &amp;&amp; temp-&gt;next-&gt;node-&gt;status == <span class="number">0</span>) &#123;</span><br><span class="line">					List* next = temp-&gt;next; </span><br><span class="line">					temp-&gt;node-&gt;size = temp-&gt;node-&gt;size + next-&gt;node-&gt;size;</span><br><span class="line">					temp-&gt;node-&gt;status = <span class="number">0</span>;</span><br><span class="line">					temp-&gt;node-&gt;id = <span class="number">-1</span>;</span><br><span class="line">					temp-&gt;next = next-&gt;next;</span><br><span class="line">					<span class="keyword">if</span> (next-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">						<span class="built_in">free</span>(next);</span><br><span class="line">						<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						next-&gt;next-&gt;front = temp;</span><br><span class="line">						<span class="built_in">free</span>(next);</span><br><span class="line">						<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">if</span> (temp-&gt;front-&gt;node-&gt;id != <span class="number">-1</span> &amp;&amp; temp-&gt;front-&gt;node-&gt;status != <span class="number">0</span> &amp;&amp; temp-&gt;next-&gt;node-&gt;id != <span class="number">-1</span> &amp;&amp; temp-&gt;next-&gt;node-&gt;status != <span class="number">0</span>) &#123;</span><br><span class="line">				temp-&gt;node-&gt;status = <span class="number">0</span>;</span><br><span class="line">				temp-&gt;node-&gt;id = <span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp-&gt;front-&gt;node-&gt;id == <span class="number">-1</span> &amp;&amp; temp-&gt;front-&gt;node-&gt;status == <span class="number">0</span> &amp;&amp; temp-&gt;next-&gt;node-&gt;id == <span class="number">-1</span> &amp;&amp; temp-&gt;next-&gt;node-&gt;status == <span class="number">0</span>) &#123;</span><br><span class="line">				List* front = temp-&gt;front;</span><br><span class="line">				List* next = temp-&gt;next;</span><br><span class="line">				front-&gt;node-&gt;size = front-&gt;node-&gt;size + temp-&gt;node-&gt;size + next-&gt;node-&gt;size;</span><br><span class="line">				front-&gt;next = next-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (next-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">					<span class="built_in">free</span>(temp);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line"></span><br><span class="line">					next-&gt;next-&gt;front = front;</span><br><span class="line">					<span class="built_in">free</span>(temp);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp-&gt;front-&gt;node-&gt;id == <span class="number">-1</span> &amp;&amp; temp-&gt;front-&gt;node-&gt;status == <span class="number">0</span>) &#123;</span><br><span class="line">				List* front = temp-&gt;front;</span><br><span class="line">				front-&gt;next = temp-&gt;next;</span><br><span class="line">				temp-&gt;next-&gt;front = front;</span><br><span class="line">				front-&gt;node-&gt;size += temp-&gt;node-&gt;size;</span><br><span class="line">				<span class="built_in">free</span>(temp);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (temp-&gt;next-&gt;node-&gt;id == <span class="number">-1</span> &amp;&amp; temp-&gt;next-&gt;node-&gt;status == <span class="number">0</span>) &#123;</span><br><span class="line">				List* next = temp-&gt;next;</span><br><span class="line">				temp-&gt;node-&gt;size = temp-&gt;node-&gt;size + next-&gt;node-&gt;size;</span><br><span class="line">				temp-&gt;node-&gt;status = <span class="number">0</span>;</span><br><span class="line">				temp-&gt;node-&gt;id = <span class="number">-1</span>;</span><br><span class="line">				temp-&gt;next = next-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (next-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">					<span class="built_in">free</span>(next);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					next-&gt;next-&gt;front = temp;</span><br><span class="line">					<span class="built_in">free</span>(next);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Best_fit</span><span class="params">(List *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> min = <span class="number">0</span>;      </span><br><span class="line">	<span class="keyword">int</span> base_min = <span class="number">0</span>;      </span><br><span class="line">	List* temp = <span class="built_in">list</span>;</span><br><span class="line">	datatype* item = input();             </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (temp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (temp-&gt;node-&gt;status == <span class="number">0</span> &amp;&amp; temp-&gt;node-&gt;id == <span class="number">-1</span> &amp;&amp; temp-&gt;node-&gt;size &gt; item-&gt;size) &#123;</span><br><span class="line">			<span class="keyword">if</span> (min == <span class="number">0</span>) &#123;          </span><br><span class="line">				min = temp-&gt;node-&gt;size;</span><br><span class="line">				base_min = temp-&gt;node-&gt;base;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (temp-&gt;node-&gt;size &lt; min) &#123;     </span><br><span class="line">					min = temp-&gt;node-&gt;size;</span><br><span class="line">					base_min = temp-&gt;node-&gt;base;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (temp-&gt;node-&gt;status == <span class="number">0</span> &amp;&amp; temp-&gt;node-&gt;id == <span class="number">-1</span> &amp;&amp; temp-&gt;node-&gt;size == item-&gt;size) &#123;</span><br><span class="line">			<span class="keyword">int</span> base = temp-&gt;node-&gt;base;</span><br><span class="line">			temp-&gt;node = item;</span><br><span class="line">			temp-&gt;node-&gt;status = <span class="number">1</span>;</span><br><span class="line">			temp-&gt;node-&gt;base = base;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125; </span><br><span class="line">	temp = <span class="built_in">list</span>;</span><br><span class="line">	<span class="keyword">while</span> (temp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (temp-&gt;node-&gt;base == base_min) &#123;</span><br><span class="line"></span><br><span class="line">			datatype* temp_node = (datatype*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(datatype));      </span><br><span class="line">			temp_node-&gt;id = <span class="number">-1</span>;</span><br><span class="line">			temp_node-&gt;status = <span class="number">0</span>;</span><br><span class="line">			temp_node-&gt;base = base_min + item-&gt;size;</span><br><span class="line">			temp_node-&gt;size = temp-&gt;node-&gt;size - item-&gt;size;</span><br><span class="line"></span><br><span class="line">			temp-&gt;node = item;                    </span><br><span class="line">			temp-&gt;node-&gt;base = base_min;</span><br><span class="line">			temp-&gt;node-&gt;status = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			List* temp_list_node = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));         </span><br><span class="line">			temp_list_node-&gt;node = temp_node;</span><br><span class="line">			temp_list_node-&gt;front = temp;</span><br><span class="line">			temp_list_node-&gt;next = temp-&gt;next;</span><br><span class="line">			<span class="keyword">if</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				temp-&gt;next-&gt;front = temp_list_node;</span><br><span class="line">			&#125;</span><br><span class="line">			temp-&gt;next = temp_list_node;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Worst_fit</span><span class="params">(List *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> max = <span class="number">0</span>;       </span><br><span class="line">	<span class="keyword">int</span> base_max = <span class="number">0</span>;      </span><br><span class="line">	List* temp = <span class="built_in">list</span>;</span><br><span class="line">	datatype* item = input();            </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (temp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (temp-&gt;node-&gt;status == <span class="number">0</span> &amp;&amp; temp-&gt;node-&gt;id == <span class="number">-1</span> &amp;&amp; temp-&gt;node-&gt;size &gt; item-&gt;size) &#123;</span><br><span class="line">			<span class="keyword">if</span> (max == <span class="number">0</span>) &#123;         </span><br><span class="line">				max = temp-&gt;node-&gt;size;</span><br><span class="line">				base_max = temp-&gt;node-&gt;base;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (temp-&gt;node-&gt;size &gt; max) &#123;      </span><br><span class="line">					max = temp-&gt;node-&gt;size;</span><br><span class="line">					base_max = temp-&gt;node-&gt;base;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (temp-&gt;node-&gt;status == <span class="number">0</span> &amp;&amp; temp-&gt;node-&gt;id == <span class="number">-1</span> &amp;&amp; temp-&gt;node-&gt;size == item-&gt;size) &#123;</span><br><span class="line">			<span class="keyword">int</span> base = temp-&gt;node-&gt;base;</span><br><span class="line">			temp-&gt;node = item;</span><br><span class="line">			temp-&gt;node-&gt;status = <span class="number">1</span>;</span><br><span class="line">			temp-&gt;node-&gt;base = base;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	temp = <span class="built_in">list</span>;</span><br><span class="line">	<span class="keyword">while</span> (temp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (temp-&gt;node-&gt;base == base_max) &#123;</span><br><span class="line"></span><br><span class="line">			datatype* temp_node = (datatype*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(datatype));     </span><br><span class="line">			temp_node-&gt;id = <span class="number">-1</span>;</span><br><span class="line">			temp_node-&gt;status = <span class="number">0</span>;</span><br><span class="line">			temp_node-&gt;base = base_max + item-&gt;size;</span><br><span class="line">			temp_node-&gt;size = temp-&gt;node-&gt;size - item-&gt;size;</span><br><span class="line"></span><br><span class="line">			temp-&gt;node = item;                         </span><br><span class="line">			temp-&gt;node-&gt;base = base_max;</span><br><span class="line">			temp-&gt;node-&gt;status = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			List* temp_list_node = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));         </span><br><span class="line">			temp_list_node-&gt;node = temp_node;</span><br><span class="line">			temp_list_node-&gt;front = temp;</span><br><span class="line">			temp_list_node-&gt;next = temp-&gt;next;</span><br><span class="line">			<span class="keyword">if</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				temp-&gt;next-&gt;front = temp_list_node;</span><br><span class="line">			&#125;</span><br><span class="line">			temp-&gt;next = temp_list_node;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;分区模拟\n&quot;</span>);</span><br><span class="line">	List <span class="built_in">list</span> = init();</span><br><span class="line">	<span class="keyword">int</span> select;</span><br><span class="line">	<span class="keyword">int</span> insert_state, recycle_state;</span><br><span class="line">	<span class="keyword">int</span> insert_state_best;</span><br><span class="line">	<span class="keyword">int</span> insert_state_worst;</span><br><span class="line">	<span class="keyword">int</span> insert_state_next;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入要进行的操作\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;1-首次适应算法\n2-最佳适应算法\n3-最坏适应算法\n4-循环首次适应算法\n5-内存回收\n6-退出\n&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;select);</span><br><span class="line">		<span class="keyword">switch</span> (select)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:              </span><br><span class="line">			insert_state = First_fit(&amp;<span class="built_in">list</span>);</span><br><span class="line">			<span class="keyword">if</span> (insert_state == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;分配失败\n&quot;</span>);</span><br><span class="line">				Momery_state(&amp;<span class="built_in">list</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;分配成功！\n&quot;</span>);</span><br><span class="line">				Momery_state(&amp;<span class="built_in">list</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;首次适应算法\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:             </span><br><span class="line">			insert_state_best = Best_fit(&amp;<span class="built_in">list</span>);</span><br><span class="line">			<span class="keyword">if</span> (insert_state_best == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;分配成功\n&quot;</span>);</span><br><span class="line">				Momery_state(&amp;<span class="built_in">list</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;最佳适应算法\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;分配失败\n&quot;</span>);</span><br><span class="line">				Momery_state(&amp;<span class="built_in">list</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			insert_state_worst = Worst_fit(&amp;<span class="built_in">list</span>);</span><br><span class="line">			<span class="keyword">if</span> (insert_state_worst == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;分配成功\n&quot;</span>);</span><br><span class="line">				Momery_state(&amp;<span class="built_in">list</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;最坏适应算法\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;分配失败\n&quot;</span>);</span><br><span class="line">				Momery_state(&amp;<span class="built_in">list</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			insert_state_next = next_fit(&amp;<span class="built_in">list</span>);</span><br><span class="line">			<span class="keyword">if</span> (insert_state_next == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;分配成功\n&quot;</span>);</span><br><span class="line">				Momery_state(&amp;<span class="built_in">list</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;循环首次适应算法\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;分配失败\n&quot;</span>);</span><br><span class="line">				Momery_state(&amp;<span class="built_in">list</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:             </span><br><span class="line">			recycle_state = Momory_recycle(&amp;<span class="built_in">list</span>);</span><br><span class="line">			<span class="keyword">if</span> (recycle_state == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;回收成功！\n&quot;</span>);</span><br><span class="line">				Momery_state(&amp;<span class="built_in">list</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;回收失败\n&quot;</span>);</span><br><span class="line">				Momery_state(&amp;<span class="built_in">list</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (select != <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>实验课作业</tag>
      </tags>
  </entry>
  <entry>
    <title>2023一战上岸华中科技大学计算机专硕经验分享</title>
    <url>/2023/04/07/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&ensp;&ensp;&ensp;&ensp;2023考研顺利一战上岸，在此记录一下自己的心得和一些经验。欢迎大家在评论区留下自己的问题，我看到后会回答，或者可以直接通过左边一栏的qq按钮获取我的联系方式。</p>
<span id="more"></span>

<p>&ensp;&ensp;&ensp;&ensp;复试结果已出，我可以安心回顾这一年的考研历程，希望我的经验对大家的学习能有所裨益，也希望大家可以在我的基础之上去糟粕、留精华，做到具体问题具体分析，做到实事求是。简要介绍下我的情况，我考的是华中科技大学计算机专硕，各科成绩和拟录取名单如下表所示，初试专业排名29/211，最后总成绩是排名19/125。</p>
<table>
<thead>
<tr>
<th align="center">101|思想政治理论</th>
<th align="center">204|英语（二）</th>
<th align="center">301|数学（一）</th>
<th align="center">408|计算机学科专业基础</th>
<th>总分</th>
</tr>
</thead>
<tbody><tr>
<td align="center">66</td>
<td align="center">80</td>
<td align="center">113</td>
<td align="center">131</td>
<td>390</td>
</tr>
</tbody></table>
<img src="/2023/04/07/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E6%8B%9F%E5%BD%95%E5%8F%96%E5%90%8D%E5%8D%95.png" class>

<h1 id="择校方面"><a href="#择校方面" class="headerlink" title="择校方面"></a>择校方面</h1><p>&ensp;&ensp;&ensp;&ensp;首先讲一下择校，我的考研目标是华中科技大学计算机专硕，考计算机的大方向是我很早就确定好的，但是院校是几经斟酌后在大概去年的5月份才定下来的。这个决策的原因有以下几方面：首先是专业选择，我本科的专业就是计算机科学与技术，在四年的学习过程中，也愈发加深了我对计算机的兴趣，希望能够在这一领域继续深造。其次是院校的选择，在本科四年的学习中，我觉得我还是保持了相对不错的学习状态，因此我觉得选择一个985的院校是在我的能力范围内的。然后华中科技大学的计算机在学科评估中是A等级，属于比较上游的计算机院校，并且根据历年的分数线来说，难度没有那么大，复试也相对公平。不过根据今年的结果来看，华科今年还是稍微有点炸，特别是专硕，复试线比去年高了10分，复录比也高达1.7，不过院校的火爆与否都是我们在择校时期无法预测到的。这里要提醒各位同学，在择校时固然需要求稳，不能冒进，但是也不要低估自己的潜力和心理预期的力量，选择一个难度较高的目标虽然意味着更高的风险和更艰苦的过程，但同时也会时刻鞭策你抓紧时间、提高效率，使你在备考过程中不自觉地成长为一个全新高度的自己，猛得令自己都陌生。</p>
<h1 id="各科备考"><a href="#各科备考" class="headerlink" title="各科备考"></a>各科备考</h1><p>&ensp;&ensp;&ensp;&ensp;其次讲一下具体的各科备考。</p>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p>&ensp;&ensp;&ensp;&ensp;首先是数学，我自认我的数学学习能力还是可以的，本科期间主要的几门数学课包括高数上下、线代和概率论得分都在98分及以上，并且在大一就获得了江苏省高等数学竞赛的一等奖。但是一方面考场状况频发，另一方面自己的心态没有保持好，在考场上很多简单题都着急的没有做出来，因此最后的成绩也不是很理想。但是我在学习期间，包括做真题和做模拟卷时，得分都有130、140，因此我认为我的学习方法和一些经验教训还是可以给同学们做一个参考。  </p>
<p>&ensp;&ensp;&ensp;&ensp;我的数学全程是以武忠祥、李永乐、余炳森老师的课程为主线，辅助以汤家凤、李林等老师的资料。每个阶段都是按照先听课程做讲义，之后做题集，最后整理错题这样的方式进行的，以下用表格来呈现每个阶段的情况。  </p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">讲义</th>
<th align="center">课程</th>
<th align="center">题集</th>
<th align="center">其他</th>
</tr>
</thead>
<tbody><tr>
<td align="center">基础阶段（3-6月）   上午 10:00-12:00  晚上 6:00-8:00</td>
<td align="center">武忠祥高数基础讲义、李永乐数学基础全书的线代部分、余炳森概率论讲义的基础部分</td>
<td align="center">武忠祥高数基础课、李永乐线性代数基础课、余炳森概率论基础课</td>
<td align="center">1800基础部分的高数和线代部分、660一阶全科、李永乐历年真题基础篇、三大计算</td>
<td align="center">李正元数学全书的高数部分</td>
</tr>
<tr>
<td align="center">强化阶段（7-10月） 上午8:30-12:00</td>
<td align="center">武忠祥高数辅导讲义、李永乐线代辅导讲义、余炳森概率论讲义的强化部分</td>
<td align="center">武忠祥高数强化课程、李永乐线代强化课程、余炳森概率论强化课程</td>
<td align="center">严选题、660二阶、880、108</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">冲刺阶段（10-12月）</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">历年真题18套，模拟卷30套（李4、李6、张4、张8、李永乐3、余炳森5）</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>&ensp;&ensp;&ensp;&ensp;以下做一些详细说明。我没有看指定教材，因为考研数学的市场已经很完善了，围绕应试要求去学就可以了。边看课程边做讲义的时候，要注意概念也要好好听讲，老师开始讲题之前先暂停，自己不看解析做一遍这个题目再听讲。一章结束可以把一章的内容包括概念和题目都好好回顾一下，不要赶进度。题集是一章听完做一章还是一科一做看自己的掌握情况，前期可以一章一做，后期的题集可以整体刷一遍。题集的错题和不太会的题标注出来，最好可以整理一遍，不需要抄题干，标注好哪本中的哪道题即可，自己独立地做一遍，把此前的错误和重要的技巧、方法、公式什么的写出来，加深印象，建立自己的解题模式。做好的错题也不要晾着，时不时拿出来滚动刷一刷，以上提到的题集，除了早期比较基础的题目，大部分我都刷过2-3遍。此外还要注意的一点是，由于数学有三科，全部过完一遍的时间较长，容易发生学了前面的忘记后面的这种情况出现，所以建议在学高数时抽一点时间刷线代和概率论的讲义或者错题，同样在学后两门时也可以刷一下高数的内容，这两部分的时间应该是差不多的。到考前一两个礼拜可以再度回顾一下三本讲义。总结一下，要能够学好应试的数学，关键还是在反复反复反复，不停刷题、思考、总结、提高。</p>
<h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><p>&ensp;&ensp;&ensp;&ensp;接着是英语。我英语的功底算中等偏上，四六级都是一次过，分别得分573分和539分。考研中，我英语客观题部分只扣了1分，不过可能是因为今年英语二客观偏简单，再加上湖北公共课压分比较严重，所以大家的主观题得分都不是很高，我最后得分也只有堪堪80。英语的备考过程比数学简单多了，就围绕着单词和真题两个板块进行，每天大概学1-2小时。</p>
<p>&ensp;&ensp;&ensp;&ensp;单词的背诵从决定考研到备考前一天都不能停。我是使用的墨墨背单词这个app（没有打广告的意思），一开始背诵的时候是每天100个左右，随着需要复习量的增加，慢慢加到300个左右。最初开始背单词时需要花大量时间是很正常的现象，万事开头难嘛。我大概在6月份左右完成了第一轮的背诵。从第二轮开始，我每天设定背诵的单词是500个（复习+新学），差不多一个月能过一次，虽然看上去每天的任务量很大，但是由于已经对单词非常熟悉了，所以每天花费的时间反而不多，一般是在30min-45min，考试前所有大纲的单词我过了6-7遍。如果后期时间紧张，可以适当少背一些，但千万不要不背，会失去英语的感觉。此外，有些单词的意思特别多，我的建议是不用去记住所有的意思，我的方法是去记住每个单词的大方向，一些生僻的意思再额外记忆一下。</p>
<p>&ensp;&ensp;&ensp;&ensp;另一个重要的板块是真题。众所周知，考研英语是不需要做模拟题的，所以真题就变成了唯一的训练素材，并且需要留下3-4套用于后期的模拟，所以数量有限需要好好利用，切忌浪费。我开始做阅读的时间差不多是五月份，那时候我已经把单词背过了大概75%，建议大家对单词有一定的熟悉程度之后再进行阅读，否则就是浪费。我从04年的卷子开始，一天一篇阅读理解，做完之后会根据错题的多少和对文章的理解程度来决定要不要看唐迟老师对该篇文章的讲解。另外，做阅读时记得给自己记个时间，争取在20min内写完。具体的阅读方法就不在此赘述了，有很多优秀的老师都有讲解到。另外像一些长难句之类的视频我是没有看过的，因为对我自己的英语基本功还算比较自信，而且除非你英语的基础非常差，否则我是不建议观看的，因为所花费的时间太多了。至于英语二要不要做英语一的题目或者英语一要不要做英语二的题目，我个人是把英语一的阅读做了一遍，英语二的阅读做了两遍，这主要是因为我一开始的目标是考华科的学硕（11408），所以是按照英语一复习的，后来想改考专硕的时候卷子都做了一半了，想着不能浪费之类的，就把英语一的阅读写完了。但是，我个人并不推荐考英二的同学去写英一的阅读，英二的阅读相对来说比较简单，而且思路和英一还是有点差别的，考英一的同学也许可以把英二的题目作为保持题感的手段。</p>
<p>&ensp;&ensp;&ensp;&ensp;从10月份开始，我开始练习作文和小三门。作文是看的石雷鹏老师的课程，模仿他的思路写过十几篇大小作文，然后每天写一篇真题的大作文或者小作文。后期买了一本王江涛的作文书，借此弥补一下语言和内容。小三门方面还是实践出真知，早年真题的完形填空确实很难，我经常会错得怀疑人生，但是最近几年的真题其实没有那么难，做到全对也是完全有可能的，所以不用管早年的题目，就当练练手。英二的新题型还算比较简单，做个两套就能上手了。至于翻译，我个人没花太多功夫，把真题练完即可，提升空间有限。总结一下英语的学习，仍然是需要反复去做题、思考、总结，思考使人进步。</p>
<h2 id="政治"><a href="#政治" class="headerlink" title="政治"></a>政治</h2><p>&ensp;&ensp;&ensp;&ensp;接着讲政治学习。政治的最终分数与努力程度的相关性相比较于其他学科而言会低很多，但这并不意味着可以放松对于政治的学习，同样也不意味着花过多时间去提升这门学科，这两种做法都是不可取的。我在这次难度较大的政治考试中成绩中规中矩，比上线所有人的平均分高了1-2分。政治的学习我是采取边听课边看书，配套刷客观题来进行的，后期加入高强度主观题背诵，用表格形式来呈现。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">用书</th>
<th align="center">课程</th>
<th align="center">题集</th>
</tr>
</thead>
<tbody><tr>
<td align="center">基础阶段（7-10月）晚上9:00-10:00</td>
<td align="center">肖秀荣精讲精练</td>
<td align="center">徐涛政治强化课程</td>
<td align="center">肖秀荣1000题</td>
</tr>
<tr>
<td align="center">强化阶段（10-11月）晚上9:00-10:30</td>
<td align="center">腿姐背诵手册</td>
<td align="center">腿姐技巧班</td>
<td align="center">小程序二刷肖1000</td>
</tr>
<tr>
<td align="center">冲刺阶段（11-12月）下午1:00-2:00</td>
<td align="center">腿姐背诵手册（针对客观题）、腿姐9页纸（针对时政）、肖四（针对大题）</td>
<td align="center">腿姐冲刺班的主观题部分（大概就一两节课）</td>
<td align="center">小程序各类模拟题（腿4，肖4，肖8，徐6，米3，米6……）</td>
</tr>
</tbody></table>
<p>&ensp;&ensp;&ensp;&ensp;以下做一些详细说明。基础阶段不需要从基础课开始看起，强化课已经做到知识点覆盖全面、讲解细致有助理解，强化课老师的选择，我个人只看过徐涛，他的风格比较稳健又不失风趣，大家可以自行选择适合的老师。选择肖老师的精讲精练是因为这本书在市场上较为权威且广受好评，我没有去做额外的笔记，只是跟着老师在精讲精练上圈圈划划，每一章节听完之后会整体去回顾一遍大致的脉络框架。徐涛的课和肖秀荣的书在整体内容上的差异可以忽略不计，但是局部内容的顺序可能需要大家做一些调整。各阶段题集的选择仍然是因人而异的，我认为肖老师的1000题数量和质量都属上乘，在基础阶段用这本题集可以有效覆盖全部知识点，全面查漏补缺。腿姐的技巧班最好听完了基础课再去看，因为技巧是建立在基础知识之上的，她在传授做题技巧的同时也串讲了各章节重要的知识点，帮助同学不停地重复所学内容。</p>
<p>&ensp;&ensp;&ensp;&ensp;在后期主要就是专注于腿姐背诵手册（选择题），腿姐的时政讲义（时政）和肖四的大题（主观），今年肖大大基本是把大题都压的七七八八，我写的很爽，全程笔都没停过，但一方面是湖北的压分，另一方面是今年选择偏难，我自己复习的可能不是很充分，所以确实做的有些差。大家可以根据自己的情况去选择课程，但是我个人建议是少听课多背书多总结，不需要太过依赖老师的讲解。</p>
<h2 id="专业课（408）"><a href="#专业课（408）" class="headerlink" title="专业课（408）"></a>专业课（408）</h2><p>&ensp;&ensp;&ensp;&ensp;最后是专业课的学习，想报考专业课408的同学可以看一下。我对我专业课的成绩还算比较满意，但是也有两三道回想起来不应该错的选择题，犯了些比较愚蠢的错误。408的卷子构成是40道选择题，7道大题（数据结构、计组、操作系统各两道，计网一道）。从总的分值上来看，数据结构和计组各占45分，操作系统占35分，计网占25分，因此在复习时要有所轻重。以下是我各阶段的学习情况。</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>用书</th>
<th>课程</th>
<th>题目</th>
</tr>
</thead>
<tbody><tr>
<td>数据结构（基础）(4-5月) 下午 2:00-5:30</td>
<td>王道数据结构</td>
<td>王道配套课程（看课时做笔记）</td>
<td>王道课后习题（选择+编程）</td>
</tr>
<tr>
<td>计算机组成原理（基础）(5-6月) 下午 2:00-5:30</td>
<td>王道计算机组成原理</td>
<td>王道配套课程（看课时做笔记）</td>
<td>王道课后习题（选择）</td>
</tr>
<tr>
<td>操作系统（基础）(6-7月) 下午 2:00-5:30</td>
<td>王道操作系统</td>
<td>王道配套课程（看课时做笔记）</td>
<td>王道课后习题（选择）</td>
</tr>
<tr>
<td>计算机网络（基础）(7-8月) 下午 2:00-5:30</td>
<td>王道计算机网络</td>
<td>王道配套课程（看课时做笔记）</td>
<td>王道课后习题（选择）</td>
</tr>
<tr>
<td>强化阶段（8-10月）下午2:00-5:30</td>
<td>王道四本书</td>
<td>无</td>
<td>王道全部课后题</td>
</tr>
<tr>
<td>冲刺阶段（11-12月）下午2:00-5:30</td>
<td>笔记、王道四本书</td>
<td>无</td>
<td>408真题卷（2009-2022）、王道8套模拟卷</td>
</tr>
<tr>
<td>最后阶段（12月-考试）下午2:00-5:30</td>
<td>笔记、王道四本书</td>
<td>无</td>
<td>二刷、三刷真题和王道书</td>
</tr>
</tbody></table>
<p>&ensp;&ensp;&ensp;&ensp;以下做一些详细说明。因为408+数一的内容非常多，所以建议四月份就差不多该开始专业课了，否则后面可能会有些来不及。第一遍学习的时候我是全程使用的王道的四本书及王道的课程，没有看过参考的教科书。在学习过程中，一边听课要一边做笔记，可能网上有现成的笔记可以参考，但是我觉得自己做的笔记能让你对知识的结构体系更加熟练，也能注意到一些听课时没在意的细节。我是听完一节课的内容后做相应的课后习题，第一遍除了数据结构之外只做了选择，第二遍重新看书做题的时候才把选择和大题都写完了。本科基础一般的同学在第一遍学习的时候可能会觉得比较困难，这个不用担心，因为像我本科基础还行的，过第一遍的时候也觉得比较困难。毕竟课程学习已经比较久远，而且考研的要求还是要远大于期末考试的要求，如果有什么地方搞不懂或者题目没有头绪，耐心多看几遍视频或答案讲解，或者找找学的比较好的同学请教一下。此外由于408的内容比较多，学了忘是很正常的现象，忘记了不要着急，及时翻笔记或书想起来就可以了。同样也是这个原因，过一两遍书是肯定不够的，我是在基础和强化阶段各过了一遍王道教材，之后在冲刺阶段的时间安排是一天做卷子一天订正和过第三遍，在这个阶段之后我主要翻看的就是笔记了，因为内容比书本浓缩很多，所以看的速度是很快的，最后大概一共过了6遍所有的内容。此外，<strong>408的真题非常非常重要</strong>，特别是大题，除了数据结构可能会灵活一些外（大多数年份都是中规中矩），计组操作系统和计网每年的方法和考点都比较相近，我第一遍模拟考408，每张卷子都在130上下，最后得分也是131，408命题组出的卷子可以说是相当稳定了，第一遍练习的得分和你最后的得分很有可能具有非常高的相关性，所以对于真题我的建议是至少要过3遍。当然，如果一开始分数比较低也不要灰心，这也只是阶段性的成果，通过真题也还可以有很大的提升空间。</p>
<p>&ensp;&ensp;&ensp;&ensp;接着讲一下每门课程我的一些经验和心得。</p>
<p>&ensp;&ensp;&ensp;&ensp;首先是数据结构。数据结构在408中的考核不算太难，选择题大多是一些简单的计算题或者考核对某一数据结构（一般是队列、栈、树等）或算法的基础应用的考核，涉及到代码的都很少，所以好好熟悉每一种数据结构，选择题是不会出什么大问题的。我在练习过程中，数据结构的选择题基本都能全对，可惜的是最后考试的时候大意做错了两题，熟悉了之后也务必要细心。大题是一道编程题和一道应用题，应用题往年都比较常规和简单，但是今年考了一个比较偏的置换-选择排序，这是外部排序中的内容，从来没有在大题中考察过，考完之后网上很多同学反映这一部分看都没看过，或者没有太在意看过了就忘了，导致10分的大题全空着了。这就告诉我们在复习时一定要全面，搞懂每一个知识点，我因为看书的遍数比较多，最后阶段查漏补缺的时候也特意多花了点时间在外部排序上，也算运气比较好拿到了满分。然后就是一道编程题，很多同学对代码有一种恐惧心理，其实不用太害怕，能比较好的掌握排序、置换等基础算法、空间换时间等简单的优化思想，代码题往往就迎刃而解了。不过也有几年考过递归的算法，主要是树那边一块的，相对来说也比较简单。编程题绝对不能空着，虽然他题目可能要求最优的时间，但是如果你时间不是最优而是次优，甚至是暴力算出来的，也可以得到绝大部分的分数，哪怕你想到的最好算法复杂度是O(n^6)，你也要把它写上去。有的同学可能会疑惑，只有一道代码题，还需要做这么多代码题的练习吗？我的观点是需要的，因为练习代码、学习代码的过程不仅仅是为了这一道代码题，它同样也服务于选择题中可能出现的代码，也能加深你对一些算法实现方式的了解。</p>
<p>&ensp;&ensp;&ensp;&ensp;接着是计算机组成原理。计组和数据结构一样占了45分，但是在408的考核中难度相对来说要大一点。计组的选择题的知识点繁多，主要是有计算题和概念题。选择中计算题其实和计组大题计算题的套路差不多，都是可以相互转化的，因此我觉得能否很好的掌握计组中计算方面的技巧和原理是计组部分拿高分的重要方法，若有时候忘记某种题目该怎么计算了，自己先想想原理，看看能否推出来，如果不行的话，再看答案，看答案的时候也要搞懂为什么是这么算的，涉及到了哪方面的知识。至于概念题，我个人是没有死记硬背过任何书上的东西，理工科还是要靠理解性记忆，只有你真正理解了某个硬件是用来干嘛的，它是怎么实现这个功能的，也就自然能记住它的好处是什么，缺点是什么等看上去需要背诵的问题。计组的大题刚上手时可能会觉得很困难，因为大题综合性很高，而一开始我们不能把前后的知识很好联系起来，甚至往往都看不懂题目在说啥，不过不要气馁，哪怕是一下午只做出了、理解了一道计组大题，也是一个融汇贯通的过程，是有收获的过程。经过大量的练习后，把前后知识都联系起来之后，再做计组大题就很简单了。</p>
<p>&ensp;&ensp;&ensp;&ensp;然后是操作系统和计算机网络，这两门课初次接触时可能会觉得知识点相当琐碎，我的练习结果也告诉我操作系统的选择题是最容易失分的，涉及到很多概念，看书时一定不能放过每一个知识点。但当你实际深入了解后，会发现其实他们都有一个很清晰的逻辑结构在内，操作系统的各章分别对应操作系统所需要做的进程管理、内存管理、文件管理和输入输出，像是一棵树不同的分支，彼此之间联系较少，显得知识比较多而杂；而计算机网络始终是以物理层-链路层-网络层-传输层-应用层这么一个线性逻辑来连接的，尽管每一层各司其职，但相互之间其实是有上下层的联系，如果能够捋顺从应用层到物理层各层的职责、协议和相互之间的联系，计算机网络学习起来就会轻松不少。这两门的选择题主要都涉及一些应用或概念，会有计算题但是不会很多，主要还是要熟悉书上的内容。操作系统的大题主要还是计算题，复习思路和计组的题目是一样的；计组就涉及到综合性的应用了，这要求同学们对每一层的职责、协议等都具有非常深刻的理解。</p>
<p>&ensp;&ensp;&ensp;&ensp;最后总结一下，408的学习就是不断学习遗忘的反复过程，要点还是多看多练，后期重点一定要放在真题和笔记（书本）上。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&ensp;&ensp;&ensp;&ensp;我最后总的学习时间大概是2000小时，学习时我会用软件记录，当然主要是因为我自制力不够，防止自己去碰手机。</p>
<img src="/2023/04/07/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E5%AD%A6%E4%B9%A0%E6%97%B6%E9%97%B4.png" class>

<p>&ensp;&ensp;&ensp;&ensp;前期大概是9小时左右一天，周末会休息；10月、11月以后每天学大概11小时左右，大概是两周给自己放一个假。当然，就算是考研也不要把自己逼的太紧，考研是一场马拉松，用力太早后期容易续不上力气。我还是建议大家每天留点时间给自己放松一下。说来惭愧，我考研复习期间仍会每天玩2-4h小时（有时候算上午休就是4h），就算是11月份，也还在玩宝可梦的新作（11月18号发售），稍微统计了一下自己考研期间玩的游戏，发现总时长是真的很惊人，如下：</p>
<img src="/2023/04/07/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E6%B8%B8%E6%88%8F.png" class>

<p>&ensp;&ensp;&ensp;&ensp;当然我不是鼓励大家去玩游戏，只是想告诉大家放松和娱乐是可以兼得的，在努力学习的同时也要努力的去放松。另外暑假期间同学们也要早做打算，在学校时，图书馆或者教室都能有一个比较好的学习氛围，但是回家之后很多同学就容易松懈下来。我个人建议离校前找一个比较稳定的学习环境而不是回家，我当时是和同班同学3个人一起租了个房子在南京学习，虽然偶尔会白兰，但总的来说学习效率也还算可以，并且也会相互交流问题，加油鼓励。</p>
<p>&ensp;&ensp;&ensp;&ensp;以上就是我的全部分享了，希望大家都能得偿所愿，顺利上岸！</p>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>经验分享</tag>
      </tags>
  </entry>
</search>
