<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>操作系统笔记——第一章（绝赞更新中）</title>
    <url>/2021/04/18/OS-1/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>个人操作系统笔记整理，欢迎参考，时不时更新。  </p>
<span id="more"></span>

<h1 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章  操作系统引论"></a>第一章  操作系统引论</h1><h2 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h2><h3 id="一、计算机系统的组成"><a href="#一、计算机系统的组成" class="headerlink" title="一、计算机系统的组成"></a>一、计算机系统的组成</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1．计算机系统是由硬件和软件两部分组成</strong></p>
<p><img src="/2021/04/18/OS-1/gainian.jpg" alt="计算机系统的组成">  </p>
<p>&ensp;&ensp;&ensp;&ensp;硬件部分：构成了系统本身和用户作业赖以活动的物质基础和环境。<br>&ensp;&ensp;&ensp;&ensp;系统软件：主要管理计算机系统本身的操作；<br>&ensp;&ensp;&ensp;&ensp;应用软件: 主要解决用户的问题。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2．操作系统在计算机系统中的地位和作用</strong> </p>
<p><img src="/2021/04/18/OS-1/diwei.png" alt="操作系统的地位">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>计算机的层次结构</strong></p>
<p><img src="/2021/04/18/OS-1/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="层次结构">  </p>
<p>&ensp;&ensp;&ensp;&ensp;操作系统的地位：是系统硬件之上的第一层软件，为其他软件提供单向支撑作用。<br>&ensp;&ensp;&ensp;&ensp;裸机：没有任何软件支持的计算机。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3．操作系统的定义</strong>  </p>
<ul>
<li>计算机系统中的一个大型的<font color="#FF0000">系统软件</font>   </li>
<li>它用来<font color="#FF0000">管理和控制</font>计算机系统中的全部软、硬件<font color="#FF0000">资源</font>  </li>
<li>合理地组织计算机的工作流程  </li>
<li>为用户应用程序的运行提供一个<font color="#FF0000">友好的界面和良好的工作环境。</font>  </li>
</ul>
<h2 id="操作系统的目标和作用"><a href="#操作系统的目标和作用" class="headerlink" title="操作系统的目标和作用"></a>操作系统的目标和作用</h2><h3 id="一、操作系统的目标"><a href="#一、操作系统的目标" class="headerlink" title="一、操作系统的目标"></a>一、操作系统的目标</h3><ul>
<li>有效性(系统管理人员的观点)：合理地组织计算机系统的工作流程，管理和分配各种硬件和软件资源，提高计算机系统资源利用率和系统吞吐量。</li>
<li>方便性(用户的观点)：提供良好的、一致的用户接口。无需了解许多有关硬件和系统软件的细节。</li>
<li>可扩充性：指OS应采用层次化、模块化结构，给计算机系统的功能的扩展提供开放式的支撑平台。</li>
<li>开放性：指系统遵循世界标准规范，特别是遵循开放系统互联0SI国际标准。</li>
</ul>
<h3 id="二、操作系统的作用"><a href="#二、操作系统的作用" class="headerlink" title="二、操作系统的作用"></a>二、操作系统的作用</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.OS作为用户与计算机硬件系统之间的接口</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;OS处于用户与计算机硬件系统之间，用户通过OS来使用计算机系统。<br><img src="/2021/04/18/OS-1/%E6%8E%A5%E5%8F%A3%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="OS作为接口示意图"><br>&ensp;&ensp;&ensp;&ensp;使用方式：<br>&ensp;&ensp;&ensp;&ensp;（1）命令方式。这是指由OS提供了一组联机命令(语言)， 用户可通过键盘输入有关命令，来直接操纵计算机系统<br>&ensp;&ensp;&ensp;&ensp;（2）系统调用方式。OS提供了一组系统调用，用户可在自己的应用程序中通过相应的系统调用，来操纵计算机。<br>&ensp;&ensp;&ensp;&ensp;（3）图形、窗口方式。用户通过屏幕上的窗口和图标来操纵计算机系统和运行自己的程序。<br>&ensp;&ensp;&ensp;&ensp;<strong>2.OS作为计算机系统资源的管理者</strong><br><img src="/2021/04/18/OS-1/%E6%B5%81%E7%A8%8B%E5%9B%BE1.png" alt="资源的管理者">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.OS实现了对计算机资源的抽象</strong></p>
<ul>
<li>在裸机上添加：处理机管理(针对CPU)、存储管理(针对内存和外存)、设备管理 、文件管理</li>
<li>把覆盖了软件的机器称为扩充机或虚拟机器</li>
<li>合理组织工作流程：作业管理、进程管理  </li>
</ul>
<p><img src="/2021/04/18/OS-1/detail.png" alt="细节">  </p>
<h3 id="三、推动操作系统发展的动力"><a href="#三、推动操作系统发展的动力" class="headerlink" title="三、推动操作系统发展的动力"></a>三、推动操作系统发展的动力</h3><ul>
<li>不断提高计算机资源利用率</li>
<li>方便用户</li>
<li>器件的不断更新换代</li>
<li>计算机体系结构的不断发展</li>
<li>不断提出新的应用需求  </li>
</ul>
<h2 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h2><h3 id="无操作系统的计算机系统"><a href="#无操作系统的计算机系统" class="headerlink" title="无操作系统的计算机系统"></a>无操作系统的计算机系统</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1、人工操作阶段</strong><br>&ensp;&ensp;&ensp;&ensp;电子管时代，1945-50年代:<br>&ensp;&ensp;&ensp;&ensp;手工操作计算机，用机器语言编写程序，操作繁琐、易出错，效率低，CPU等待人工操作、利用率低<br><img src="/2021/04/18/OS-1/%E6%89%8B%E5%B7%A5%E6%93%8D%E4%BD%9C.png" alt="手工操作计算机"><br>&ensp;&ensp;&ensp;&ensp;手工操作的缺点：<br>&ensp;&ensp;&ensp;&ensp;（1）易出错、操作繁琐、难于掌握<br>&ensp;&ensp;&ensp;&ensp;（2）CPU的利用率低<br>&ensp;&ensp;&ensp;&ensp;提高效率低途径：<br>&ensp;&ensp;&ensp;&ensp;（1）专门的操作员/批量处理<br>&ensp;&ensp;&ensp;&ensp;（2）脱机I/O<br>&ensp;&ensp;&ensp;&ensp;（3）通道技术、中断技术、缓冲技术<br>&ensp;&ensp;&ensp;&ensp;<strong>2. 脱机输入/输出(Off-Line I/O)方式</strong><br>&ensp;&ensp;&ensp;&ensp;这种脱机I/O方式的主要优点如下：<br>&ensp;&ensp;&ensp;&ensp;（1）减少了CPU的空闲时间。<br>&ensp;&ensp;&ensp;&ensp;（2）提高I/O速度。<br><img src="/2021/04/18/OS-1/%E8%84%B1%E6%9C%BA.png" alt="I/O脱机">  </p>
<h3 id="成批处理阶段"><a href="#成批处理阶段" class="headerlink" title="成批处理阶段"></a>成批处理阶段</h3><p>&ensp;&ensp;&ensp;&ensp;晶体管时代，50年代末-60年代中，随着中央处理机速度的大幅度提高，人工操作的慢速度和中央处理机运算的高速度之间出现了矛盾，即所谓人机矛盾。为解决这一矛盾，只有设法去掉人工操作，实现作业的自动过渡，这样就出现了成批处理。<br>&ensp;&ensp;&ensp;&ensp;监督程序：是一个常驻内存的小的核心代码，用于实现各作业之间的自动转接，提高了系统效率。<br>&ensp;&ensp;&ensp;&ensp;<strong>1.单道批处理:</strong>    </p>
<ul>
<li>利用磁带把若干作用分类编成作业执行序列  </li>
<li>每批作业由一个专门的监督程序自动依次处理  </li>
<li>可使用汇编语言开发<br><img src="/2021/04/18/OS-1/%E5%8D%95%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86.png" alt="单道批处理"><br>&ensp;&ensp;&ensp;&ensp;单道批处理系统特点：自动性、顺序性、单道性<br>&ensp;&ensp;&ensp;&ensp;成批处理经历了两个阶段：<br>&ensp;&ensp;&ensp;&ensp;联机批处理阶段和脱机批处理阶段。</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;联机批处理系统：作业的I/O和计算全部由CPU直接控制。<br><img src="/2021/04/18/OS-1/%E8%81%94%E6%9C%BA%E6%89%B9%E5%A4%84%E7%90%86.png" alt="联机批处理">  </p>
<p>&ensp;&ensp;&ensp;&ensp;脱机批处理系统：由主机和外围计算机（卫星机）组成，外围计算机负责I/O处理，主机和外围计算机可以并行工作。<br><img src="/2021/04/18/OS-1/%E8%84%B1%E6%9C%BA%E6%89%B9%E5%A4%84%E7%90%86.png" alt="脱机批处理"><br> &ensp;&ensp;&ensp;&ensp;<strong>2.多道批处理系统</strong><br>&ensp;&ensp;&ensp;&ensp;多道程序设计技术是指在计算机内存中同时存放多个作业，它们在管理程序控制之下交替执行，共享系统中的各种资源。60年代中-70年代中(集成电路)<br>多道程序运行的特征：<br> &ensp;&ensp;&ensp;&ensp;（1）主存中存放多道程序；<br> &ensp;&ensp;&ensp;&ensp;（2）宏观上并行；<br> &ensp;&ensp;&ensp;&ensp;（3）微观上串行。<br><img src="/2021/04/18/OS-1/%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86.jpg" alt="多道批处理">  </p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>于是开始写第一篇博客</title>
    <url>/2021/04/09/my-first-blog/</url>
    <content><![CDATA[<p>从零开始的学习生活</p>
<span id="more"></span>!
<h1 id="以下是代码测试"><a href="#以下是代码测试" class="headerlink" title="以下是代码测试"></a>以下是代码测试</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">print(&quot;Hello</span> <span class="string">World&quot;);</span></span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>操作系统实验课作业二——进程调度</title>
    <url>/2021/04/19/processtest/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&ensp;&ensp;&ensp;&ensp;用JAVA模拟进程调度过程。个人实验报告使用，如果想参考，不得保留原文40%以上，谢谢配合。</p>
<span id="more"></span>

<h1 id="一、实验目的及要求"><a href="#一、实验目的及要求" class="headerlink" title="一、实验目的及要求"></a>一、实验目的及要求</h1><p>&ensp;&ensp;&ensp;&ensp;进程调度是处理机管理的核心内容。本实验要求用高级语言编写模拟进程调度程序，以便加深理解有关进程控制块、进程队列等概念，并体会和了解先来先服务（FCFS算法）、短进程优先（SJF算法），优先权（PSA算法）、高响应比优先（HRN算法）等调度算法的具体实现。</p>
<h1 id="二、基本理论介绍"><a href="#二、基本理论介绍" class="headerlink" title="二、基本理论介绍"></a>二、基本理论介绍</h1><h2 id="2-1-处理机调度的基本概念"><a href="#2-1-处理机调度的基本概念" class="headerlink" title="2.1 处理机调度的基本概念"></a>2.1 处理机调度的基本概念</h2><p>&ensp;&ensp;&ensp;&ensp;处理机是计算机系统中的重要资源，处理机调度算法不仅对处理器的利用效率和用户进程的执行有影响，同时还与内存等其他资源的使用密切相关，对整个计算机系统的综合性能指标也有重要影响。</p>
<h2 id="2-2-进程调度方式"><a href="#2-2-进程调度方式" class="headerlink" title="2.2 进程调度方式"></a>2.2 进程调度方式</h2><h3 id="1）抢占式（剥夺式）"><a href="#1）抢占式（剥夺式）" class="headerlink" title="1）抢占式（剥夺式）"></a>1）抢占式（剥夺式）</h3><p>&ensp;&ensp;&ensp;&ensp;当一个进程正在处理器上运行时，系统可以根据规定的原则剥夺分配给它的处理器，而把处理器分配给其它进程使用</p>
<h3 id="2）非抢占式（非剥夺式）"><a href="#2）非抢占式（非剥夺式）" class="headerlink" title="2）非抢占式（非剥夺式）"></a>2）非抢占式（非剥夺式）</h3><p>&ensp;&ensp;&ensp;&ensp;一旦某个进程开始执行后便不再出让处理器，除非该进程运行结束或发生了某个事件不能继续执行。</p>
<h2 id="2-3-本实验所使用的调度算法"><a href="#2-3-本实验所使用的调度算法" class="headerlink" title="2.3 本实验所使用的调度算法"></a>2.3 本实验所使用的调度算法</h2><h3 id="1）先来先服务（FCFS）"><a href="#1）先来先服务（FCFS）" class="headerlink" title="1）先来先服务（FCFS）"></a>1）先来先服务（FCFS）</h3><p>&ensp;&ensp;&ensp;&ensp; 按照进程进入就绪队列的先后顺序调度并分配处理机执行。先来先服务调度算法是一种非抢占式的算法，先进入就绪队列的进程，先分配处理机运行。一旦一个进程占有了处理机，它就一直运行下去，直到该进程完成工作或者因为等待某事件发生而不能运行时才释放处理机。<br>&ensp;&ensp;&ensp;&ensp;（1）系统只有按FIFO规则建立的后备作业队列或就绪进程队列即可，就是一个作业控制快JCB或进程控制块PCB加入队列时加在相应队列末尾。<br>&ensp;&ensp;&ensp;&ensp;（2）调度退出队列时从相应队列首开始顺序扫描，将相关的JCB或PCB调度移出相应队列。<br>&ensp;&ensp;&ensp;&ensp;（3）优缺点：有利于长作业（进程）而不利于短作业（进程）；有利于CPU繁忙型作业（进程），而不利于I/O繁忙型作业（进程）。  </p>
<h3 id="2）非剥夺式的短作业优先算法（SJF）"><a href="#2）非剥夺式的短作业优先算法（SJF）" class="headerlink" title="2）非剥夺式的短作业优先算法（SJF）"></a>2）非剥夺式的短作业优先算法（SJF）</h3><p>&ensp;&ensp;&ensp;&ensp;短进程优先算法是以作业的长短来计算优先级，作业越短，其优先级越高。作业的长短是以作业所要求的运行时间来衡量的。在把短作业优先调度算法用于作业调度时，它将从外存的作业后备队列中选择若干个估计运行时间最短的作业，优先将它们调入内存运行。<br>&ensp;&ensp;&ensp;&ensp;(1)比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；<br>&ensp;&ensp;&ensp;&ensp;(2)对长作业非常不利，可能长时间得不到执行；未能依据作业的紧迫程度来划分执行的优先级；难以准确估计作业（进程）的执行时间，从而影响调度性能。</p>
<h3 id="3）非剥夺式的优先级算法（PSA）"><a href="#3）非剥夺式的优先级算法（PSA）" class="headerlink" title="3）非剥夺式的优先级算法（PSA）"></a>3）非剥夺式的优先级算法（PSA）</h3><p>&ensp;&ensp;&ensp;&ensp;优先级算法是多级队列算法的改进，平衡各进程对响应时间的要求。适用于作业调度和进程调度，可分成抢先式和非抢先式。<br>&ensp;&ensp;&ensp;&ensp;作业调度中的静态优先级大多按以下原则确定：<br>&ensp;&ensp;&ensp;&ensp;（1）由用户自己根据作业的紧急程度输入一个适当的优先级。<br>&ensp;&ensp;&ensp;&ensp;（2）由系统或操作员根据作业类型指定优先级。<br>&ensp;&ensp;&ensp;&ensp;（3）系统根据作业要求资源情况确定优先级。  </p>
<h3 id="4）最高响应比优先法（HRN）"><a href="#4）最高响应比优先法（HRN）" class="headerlink" title="4）最高响应比优先法（HRN）"></a>4）最高响应比优先法（HRN）</h3><p>&ensp;&ensp;&ensp;&ensp;最高响应比优先法(HRN，Highest Response_ratio Next)是对FCFS方式和SJF方式的一种综合平衡。FCFS方式只考虑每个作业的等待时间而未考虑执行时间的长短，而SJF方式只考虑执行时间而未考虑等待时间的长短。因此，这两种调度算法在某些极端情况下会带来某些不便。HRN调度策略同时考虑每个作业的等待时间长短和估计需要的执行时间长短，从中选出响应比最高的作业投入执行。<br>&ensp;&ensp;&ensp;&ensp;响应比R定义如下：<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;R =(W+T)/T = 1+W/T<br>&ensp;&ensp;&ensp;&ensp;其中T为该作业估计需要的执行时间，W为作业在后备状态队列中的等待时间。每当要进行作业调度时，系统计算每个作业的响应比，选择其中R最大者投入执行。这样，即使是长作业，随着它等待时间的增加，W / T也就随着增加，也就有机会获得调度执行。这种算法是介于FCFS和SJF之间的一种折中算法。由于长作业也有机会投入运行，在同一时间内处理的作业数显然要少于SJF法，从而采用HRN方式时其吞吐量将小于采用SJF法时的吞吐量。另外，由于每次调度前要计算响应比，系统开销也要相应增加。</p>
<h1 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h1><p>1.设计进程控制块PCB的结构，通常应包括如下信息：<br>&ensp;&ensp;&ensp;&ensp;进程名、进程优先数、进程的到达时间、服务时间、进程的状态等<br>2.编写四种调度算法程序：<br>&ensp;&ensp;&ensp;&ensp;FCFS&ensp;&ensp;&ensp;&ensp;非抢占SJF&ensp;&ensp;&ensp;&ensp; 非抢占PSA &ensp;&ensp;&ensp;&ensp;HRRN<br>3.输入参数。<br>&ensp;&ensp;&ensp;&ensp;输入进程数目<br>&ensp;&ensp;&ensp;&ensp;各进程的相关数据（进程ID,到达时间，服务时间，优先级等）<br>4.选择调度算法<br>5.按要求输出结果（界面简洁美观）<br>&ensp;&ensp;&ensp;&ensp;1）要求输出调度过程<br>&ensp;&ensp;&ensp;&ensp;2）要求输出各进程在不同的算法下的完成时间，周转时间，带权周转时间，平均周转时间，平均带权周转时间，以及调度顺序。</p>
<h1 id="四、功能实现"><a href="#四、功能实现" class="headerlink" title="四、功能实现"></a>四、功能实现</h1><p>代码部分参考：<a href="https://blog.csdn.net/qq_37373250/article/details/85526518">https://blog.csdn.net/qq_37373250/article/details/85526518</a></p>
<h2 id="4-1-定义JCB（或PCB）"><a href="#4-1-定义JCB（或PCB）" class="headerlink" title="4.1 定义JCB（或PCB）"></a>4.1 定义JCB（或PCB）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JCB</span> </span>&#123;</span><br><span class="line">	String name;<span class="comment">//进程名</span></span><br><span class="line">	<span class="keyword">int</span> arriveTime;<span class="comment">//到达时间</span></span><br><span class="line">	<span class="keyword">int</span> serveTime;<span class="comment">//服务时间</span></span><br><span class="line">	<span class="keyword">int</span> beginTime;<span class="comment">//开始时间</span></span><br><span class="line">	<span class="keyword">int</span> finshTime;<span class="comment">//结束时间</span></span><br><span class="line">	<span class="keyword">int</span> roundTime;<span class="comment">//周转时间</span></span><br><span class="line">	<span class="keyword">double</span> aveRoundTime;<span class="comment">//带权周转时间</span></span><br><span class="line">	<span class="keyword">int</span> waitTime;<span class="comment">//记录每个进程到达后的等待时间，只用于最高响应比优先调度算法中</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">JCB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">JCB</span><span class="params">(String name, <span class="keyword">int</span> arriveTime, <span class="keyword">int</span> serveTime,<span class="keyword">double</span> priority)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.arriveTime = arriveTime;</span><br><span class="line">		<span class="keyword">this</span>.serveTime = serveTime;</span><br><span class="line">		<span class="keyword">this</span>.waitTime = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String info = <span class="keyword">new</span> String(<span class="string">&quot;进程名：&quot;</span>+<span class="keyword">this</span>.name);</span><br><span class="line">		<span class="keyword">return</span> info;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;JCB类的代码如上所示，为方便JCB实例的创建，构造函数使用相关数据作为参数（进程名、到达时间、服务时间、优先级）。</p>
<h2 id="4-2-四种算法的实现"><a href="#4-2-四种算法的实现" class="headerlink" title="4.2 四种算法的实现"></a>4.2 四种算法的实现</h2><p>&ensp;&ensp;&ensp;&ensp;基本思想是通过各种算法来定义不同的排序方式，然后用队列一一加载排好序的进程，之后逐个进行工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">processMenu</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	ArrayList&lt;JCB&gt; jcb;<span class="comment">// 存放所有进程</span></span><br><span class="line">	LinkedList&lt;JCB&gt; link;<span class="comment">// 存放已经进入队列的进程</span></span><br><span class="line">	ArrayList&lt;JCB&gt; new_jcb;<span class="comment">// 存放按指定调度算法排序后的进程</span></span><br><span class="line">	JCB nowProess;<span class="comment">// 当前应执行进程</span></span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="comment">//初始化</span></span><br><span class="line">		jcb = <span class="keyword">new</span> ArrayList&lt;JCB&gt;();</span><br><span class="line">		link = <span class="keyword">new</span> LinkedList&lt;JCB&gt;();</span><br><span class="line">		new_jcb = <span class="keyword">new</span> ArrayList&lt;JCB&gt;();</span><br><span class="line">		JCB p1 = <span class="keyword">new</span> JCB(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">		JCB p2 = <span class="keyword">new</span> JCB(<span class="string">&quot;B&quot;</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">		JCB p3 = <span class="keyword">new</span> JCB(<span class="string">&quot;C&quot;</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">		JCB p4 = <span class="keyword">new</span> JCB(<span class="string">&quot;D&quot;</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">		JCB p5 = <span class="keyword">new</span> JCB(<span class="string">&quot;E&quot;</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">		jcb.add(p1);jcb.add(p2);jcb.add(p3);jcb.add(p4);jcb.add(p5);</span><br><span class="line">		<span class="comment">//先将jcb排序，便于下面的算法实现，就不需要再定义一个标识进程是否已到达的boolean,即无需每次都从头开始扫描jcb容器，</span></span><br><span class="line">		<span class="comment">//而是用一个K记录下当前已经扫描到的位置，一次遍历即可，提高了算法效率。</span></span><br><span class="line">		Collections.sort(jcb, <span class="keyword">new</span> compareAt_St());</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FCFS</span><span class="params">()</span></span>&#123;<span class="comment">//先来先服务算法</span></span><br><span class="line">		ProcessQueue pq=<span class="keyword">new</span> ProcessQueue();<span class="comment">//调用内部类</span></span><br><span class="line">		pq.EnqueueLast();<span class="comment">//让最先到达的进程先入队</span></span><br><span class="line">		System.out.println(<span class="string">&quot;*****************************************************&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span>(!link.isEmpty()) &#123;<span class="comment">//while(new_jcb.size()!=jcb.size())</span></span><br><span class="line">			pq.DisplayQueue();<span class="comment">//打印当前队列中的进程</span></span><br><span class="line">			pq.Dequeue();<span class="comment">//出队，一次一个</span></span><br><span class="line">			pq.EnqueueLast();<span class="comment">//已到达的进程入队</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SJF</span><span class="params">()</span> </span>&#123;<span class="comment">// 短作业优先算法</span></span><br><span class="line">		ProcessQueue pq=<span class="keyword">new</span> ProcessQueue();</span><br><span class="line">		pq.EnqueueLast();</span><br><span class="line">		System.out.println(<span class="string">&quot;*****************************************************&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span>(!link.isEmpty()) &#123;</span><br><span class="line">			pq.DisplayQueue();<span class="comment">//打印当前队列中的进程</span></span><br><span class="line">			pq.Dequeue();<span class="comment">//出队，一次一个</span></span><br><span class="line">			pq.EnqueueLast();<span class="comment">//已到达的进程入队</span></span><br><span class="line">			Collections.sort(link, <span class="keyword">new</span> compareSt());<span class="comment">//队列中的进程还需按服务时间长度进行排序</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RR</span><span class="params">()</span> </span>&#123;<span class="comment">//时间片轮转调度算法</span></span><br><span class="line">		ProcessQueue pq=<span class="keyword">new</span> ProcessQueue();</span><br><span class="line">		pq.EnqueueLast();</span><br><span class="line">		System.out.println(<span class="string">&quot;*****************************************************&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span>(!link.isEmpty()) &#123;</span><br><span class="line">			pq.DisplayQueue();<span class="comment">//打印当前队列中的进程</span></span><br><span class="line">			pq.Dequeue(<span class="number">1</span>);<span class="comment">//出队，一次一个，因为上一轮出的得让刚到达的进程先进队列，所以没办法，进队操作只能也放在这个函数里了</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HRN</span><span class="params">()</span> </span>&#123;<span class="comment">//最高响应比优先调度算法</span></span><br><span class="line">		ProcessQueue pq=<span class="keyword">new</span> ProcessQueue();</span><br><span class="line">		pq.EnqueueLast();</span><br><span class="line">		System.out.println(<span class="string">&quot;*****************************************************&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span>(!link.isEmpty()) &#123;</span><br><span class="line">			pq.DisplayQueue();<span class="comment">//打印当前队列中的进程</span></span><br><span class="line">			pq.Dequeue();<span class="comment">//出队，一次一个</span></span><br><span class="line">			pq.EnqueueLast();<span class="comment">//已到达的进程入队</span></span><br><span class="line">			Collections.sort(link, <span class="keyword">new</span> comparePriority());<span class="comment">//队列中的进程还需按响应比进行排序</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">ProcessQueue</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">// jcb中的进程遍历时的下标</span></span><br><span class="line">		<span class="keyword">int</span> nowTime = <span class="number">0</span>;<span class="comment">// 当前时间</span></span><br><span class="line">		<span class="keyword">double</span> sliceTime;<span class="comment">//轮转调度时间片</span></span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//记录当前出入队列的次数</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EnqueueLast</span><span class="params">()</span> </span>&#123;<span class="comment">//进程首次入队，可一次进多个,从队尾进入</span></span><br><span class="line">			<span class="keyword">while</span> (k &lt; jcb.size()) &#123;<span class="comment">//当遍历完jcb中的所有进程时结束</span></span><br><span class="line">				<span class="keyword">if</span> (jcb.get(k).arriveTime &lt;= nowTime) &#123;<span class="comment">//已经到达的进程按到达时间先后进入队列</span></span><br><span class="line">					link.addLast(jcb.get(k));</span><br><span class="line">					k++;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">break</span>;<span class="comment">//如果该进程还未入队，即先结束遍历，保留当前下标k值，注意：此处不要k--；</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">EnqueueFirst</span><span class="params">()</span> </span>&#123;<span class="comment">//进程首次入队，可一次进多个,从队首进入</span></span><br><span class="line">			<span class="keyword">while</span> (k &lt; jcb.size()) &#123;<span class="comment">//当遍历完jcb中的所有进程时结束</span></span><br><span class="line">				<span class="keyword">if</span> (jcb.get(k).arriveTime &lt;= nowTime) &#123;<span class="comment">//已经到达的进程按到达时间先后进入队列</span></span><br><span class="line">					link.addFirst(jcb.get(k));</span><br><span class="line">					k++;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">break</span>;<span class="comment">//如果该进程还未入队，即先结束遍历，保留当前下标k值，注意：此处不要k--；</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dequeue</span><span class="params">()</span> </span>&#123;<span class="comment">//进程出队，一次只出一个</span></span><br><span class="line">			nowProess = link.removeFirst();<span class="comment">//移除队列的队首元素并且返回该对象元素</span></span><br><span class="line">			nowProess.beginTime = nowTime;<span class="comment">//计算开始时间，即为上一个进程的结束时间</span></span><br><span class="line">			nowProess.finshTime = nowProess.beginTime + nowProess.serveTime;<span class="comment">//计算结束时间，该进程开始时间+服务时间</span></span><br><span class="line">			nowProess.roundTime = nowProess.finshTime - nowProess.arriveTime;<span class="comment">//计算周转时间</span></span><br><span class="line">			nowProess.aveRoundTime = (<span class="keyword">double</span>) nowProess.roundTime / nowProess.serveTime;<span class="comment">//计算平均周转时间</span></span><br><span class="line">			nowTime = nowProess.finshTime;<span class="comment">//获得结束时间，即当前时间，方便判断剩下的进程是否已到达</span></span><br><span class="line">			new_jcb.add(nowProess);<span class="comment">//经处理过数据后加入new_jcb容器</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;link.size();++i) &#123;</span><br><span class="line">				link.get(i).waitTime++;<span class="comment">//所有进入等待队列的进程等待时间+1,此处只为最高响应比算法所用</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dequeue</span><span class="params">(<span class="keyword">double</span> sliceTime)</span> </span>&#123;<span class="comment">//重载Dequeue方法，实现轮转调度算法的出队</span></span><br><span class="line">			nowProess = link.removeFirst();<span class="comment">//移除队列的队首元素并且返回该对象元素</span></span><br><span class="line">			<span class="keyword">if</span>(nowProess.firstTimeTag==<span class="keyword">false</span>) &#123;</span><br><span class="line">				<span class="comment">/*轮转调度进程可能会多次反复进出队列，不像FCFS和SJF的进程只会进出一次，所以计算开始时间可以设个标志位，让每个进程在</span></span><br><span class="line"><span class="comment">				 * 第一次执行时记录一遍即可*/</span></span><br><span class="line">				nowProess.beginTime=nowTime;<span class="comment">//进程开始执行的时间</span></span><br><span class="line">				nowProess.firstTimeTag=<span class="keyword">true</span>;<span class="comment">//计算第一次即可，下次无需更新计算</span></span><br><span class="line">			&#125;</span><br><span class="line">			nowTime+=sliceTime;<span class="comment">//每次出队，用时一个时间片，更新当前时间</span></span><br><span class="line">			nowProess.clock+=sliceTime;<span class="comment">//更新当前出队列的进程已服务时间</span></span><br><span class="line">			<span class="keyword">if</span>(nowProess.clock&gt;=nowProess.serveTime) &#123;</span><br><span class="line">				nowProess.finshTime=nowTime;<span class="comment">//计算该进程完成时间</span></span><br><span class="line">				nowProess.roundTime = nowProess.finshTime - nowProess.arriveTime;<span class="comment">//计算周转时间</span></span><br><span class="line">				nowProess.aveRoundTime = (<span class="keyword">double</span>) nowProess.roundTime / nowProess.serveTime;<span class="comment">//计算平均周转时间</span></span><br><span class="line">				new_jcb.add(nowProess);<span class="comment">//经处理过数据后加入new_jcb容器</span></span><br><span class="line">				EnqueueFirst();<span class="comment">//已到达的进程先入队</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				EnqueueFirst();<span class="comment">//已到达的进程先入队</span></span><br><span class="line">				link.addLast(nowProess);<span class="comment">//上一轮出的再紧接着进入队尾</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisplayQueue</span><span class="params">()</span></span>&#123;<span class="comment">//队列中等候的进程</span></span><br><span class="line">			i++;</span><br><span class="line">			System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;次队列中排队的进程：&quot;</span>+link);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;进程名 到达时间  服务时间   开始时间  完成时间  周转时间  带权周转时间&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; new_jcb.size(); ++i) &#123;</span><br><span class="line">			System.out.println(new_jcb.get(i).name + <span class="string">&quot;        &quot;</span> + new_jcb.get(i).arriveTime + <span class="string">&quot;          &quot;</span> +</span><br><span class="line">		new_jcb.get(i).serveTime+ <span class="string">&quot;         &quot;</span> + new_jcb.get(i).beginTime + <span class="string">&quot;         &quot;</span> + new_jcb.get(i).finshTime +</span><br><span class="line">		<span class="string">&quot;         &quot;</span>+ new_jcb.get(i).roundTime + <span class="string">&quot;        &quot;</span> + new_jcb.get(i).aveRoundTime);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">float</span> avg_zhouzhuan,avg_daiquan;</span><br><span class="line">        <span class="keyword">float</span> sum1 = <span class="number">0</span>, sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; new_jcb.size(); ++i)&#123;</span><br><span class="line">            sum1 += new_jcb.get(i).roundTime;</span><br><span class="line">            sum2 += new_jcb.get(i).aveRoundTime;</span><br><span class="line">        &#125;</span><br><span class="line">        avg_zhouzhuan = sum1/<span class="number">5</span>;</span><br><span class="line">        avg_daiquan = sum2/<span class="number">5</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;平均周转时间是：&quot;</span>+avg_zhouzhuan);</span><br><span class="line">        System.out.println(<span class="string">&quot;平均带权周转时间是：&quot;</span>+avg_daiquan);</span><br><span class="line">		new_jcb.clear();<span class="comment">//清空new_jcb容器内的内容，方便存储各种算法的结果并展示</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">compareSt</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">JCB</span>&gt; </span>&#123;<span class="comment">// 按服务时间升序</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(JCB arg0, JCB arg1)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> arg0.serveTime - arg1.serveTime;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">compareAt_St</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">JCB</span>&gt; </span>&#123;<span class="comment">// 按到达时间升序，若到达时间相同，按服务时间升序</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(JCB o1, JCB o2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = o1.arriveTime - o2.arriveTime;</span><br><span class="line">		<span class="keyword">if</span> (a &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> o1.serveTime &gt; o2.serveTime ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">comparePriority</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">JCB</span>&gt;</span>&#123;<span class="comment">//按响应比升序排序</span></span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(JCB o1, JCB o2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">double</span> r1=(<span class="keyword">double</span>)o1.waitTime/o1.serveTime;</span><br><span class="line">		<span class="keyword">double</span> r2=(<span class="keyword">double</span>)o2.waitTime/o2.serveTime;</span><br><span class="line">		<span class="keyword">return</span> r1&gt;r2?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProcess</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		processMenu pm=<span class="keyword">new</span> processMenu();</span><br><span class="line">		pm.init();<span class="comment">//初始化容器</span></span><br><span class="line">		pm.FCFS();pm.printProcess();</span><br><span class="line">        System.out.println(<span class="string">&quot;FCFS&quot;</span>);</span><br><span class="line">		pm.SJF();pm.printProcess();</span><br><span class="line">        System.out.println(<span class="string">&quot;SJF&quot;</span>);</span><br><span class="line">		pm.HRN();pm.printProcess();</span><br><span class="line">        System.out.println(<span class="string">&quot;HRN&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="五、结果测试与分析"><a href="#五、结果测试与分析" class="headerlink" title="五、结果测试与分析"></a>五、结果测试与分析</h1><p>以下为运行结果（因为还没搞定上传图片的功能，先复制文字替代了)</p>
<hr>
<p>第1次队列中排队的进程：[进程名：A]<br>第2次队列中排队的进程：[进程名：B, 进程名：C, 进程名：D, 进程名：E]<br>第3次队列中排队的进程：[进程名：C, 进程名：D, 进程名：E]<br>第4次队列中排队的进程：[进程名：D, 进程名：E]<br>第5次队列中排队的进程：[进程名：E]<br>进程名 到达时间  服务时间   开始时间  完成时间  周转时间  带权周转时间<br>A        0          4         0         4         4        1.0<br>B        1          3         4         7         6        2.0<br>C        2          5         7         12         10        2.0<br>D        3          2         12         14         11        5.5<br>E        4          4         14         18         14        3.5<br>平均周转时间是：9.0<br>平均带权周转时间是：2.8<br>FCFS  </p>
<hr>
<p>第1次队列中排队的进程：[进程名：A]<br>第2次队列中排队的进程：[进程名：D, 进程名：B, 进程名：E, 进程名：C]<br>第3次队列中排队的进程：[进程名：B, 进程名：E, 进程名：C]<br>第4次队列中排队的进程：[进程名：E, 进程名：C]<br>第5次队列中排队的进程：[进程名：C]<br>进程名 到达时间  服务时间   开始时间  完成时间  周转时间  带权周转时间<br>A        0          4         0         4         4        1.0<br>D        3          2         4         6         3        1.5<br>B        1          3         6         9         8        2.6666666666666665<br>E        4          4         9         13         9        2.25<br>C        2          5         13         18         16        3.2<br>平均周转时间是：8.0<br>平均带权周转时间是：2.1233335<br>SJF  </p>
<hr>
<p>第1次队列中排队的进程：[进程名：A]<br>第2次队列中排队的进程：[进程名：B, 进程名：C, 进程名：D, 进程名：E]<br>第3次队列中排队的进程：[进程名：C, 进程名：E, 进程名：D]<br>第4次队列中排队的进程：[进程名：E, 进程名：D]<br>第5次队列中排队的进程：[进程名：D]<br>进程名 到达时间  服务时间   开始时间  完成时间  周转时间  带权周转时间<br>A        0          4         0         4         4        1.0<br>B        1          3         4         7         6        2.0<br>C        2          5         7         12         10        2.0<br>E        4          4         12         16         12        3.0<br>D        3          2         16         18         15        7.5<br>平均周转时间是：9.4<br>平均带权周转时间是：3.1<br>HRN  </p>
<h1 id="六、心得体会"><a href="#六、心得体会" class="headerlink" title="六、心得体会"></a>六、心得体会</h1><p>&ensp;&ensp;&ensp;&ensp;以上文字和代码仅供参考，请勿直接复制用于完成作业。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>实验课作业</tag>
      </tags>
  </entry>
  <entry>
    <title>二维矩阵前缀和计算方法</title>
    <url>/2021/05/06/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<p>&ensp;&ensp;&ensp;&ensp;二维矩阵前缀和的思考与实现。</p>
<span id="more"></span>

<h1 id="一、一维数组前缀和"><a href="#一、一维数组前缀和" class="headerlink" title="一、一维数组前缀和"></a>一、一维数组前缀和</h1><p>&ensp;&ensp;&ensp;&ensp;首先在解答二维矩阵的前缀和的问题之前，先复习一下一维的前缀和</p>
<h2 id="1-1-前缀和的介绍"><a href="#1-1-前缀和的介绍" class="headerlink" title="1.1 前缀和的介绍"></a>1.1 前缀和的介绍</h2><p>&ensp;&ensp;&ensp;&ensp;假设我们有一个字符串ABCDE，什么是这个单词的前缀，A、AB、ABC、ABCD、ABCDE就是这个单词的前缀，就是从第一个字母开始，依次往后拼接。E、ED、EDC、EDCB、EDCBA被称为这个单词的后缀。<br>&ensp;&ensp;&ensp;&ensp;那么对于一个数组的前缀，例如数组a = [1,2,3,4,5]，我们维护一个由前缀的和组成的数组sum，sum[i]表示数组中a[0]~ a[i] 的和。<br>&ensp;&ensp;&ensp;&ensp;sum[0] = a[0]<br>&ensp;&ensp;&ensp;&ensp;sum[1] = a[0] + a[1]<br>&ensp;&ensp;&ensp;&ensp;sum[2] = a[0] + a[1] + a[2]<br>&ensp;&ensp;&ensp;&ensp;sum[3] = a[0] + a[1] + a[2] + a[3]<br>&ensp;&ensp;&ensp;&ensp;sum[4] = a[0] + a[1] + a[2] + a[3] + a[4]<br>&ensp;&ensp;&ensp;&ensp;sum数组就被称为前缀和数组。<br>&ensp;&ensp;&ensp;&ensp;用在整数数组中，sum数组即为前n个整数的和。  </p>
<h2 id="1-2-前缀和的作用"><a href="#1-2-前缀和的作用" class="headerlink" title="1.2 前缀和的作用"></a>1.2 前缀和的作用</h2><p>&ensp;&ensp;&ensp;&ensp;前缀和的最主要目的是求子数组的和的大小。例如元素a[1]到a[3]的和。可以用sum[3] - sum[0]表示。<br>&ensp;&ensp;&ensp;&ensp;用此法求多个子数组的和，因为只需要遍历一遍数组，记录下sum数组，所以复杂度为O(n)，计算sum[r] - sum[l]的复杂度为O(1)，可以忽略不计，大大提升了需要计算多个子数组和时的效率。<br>&ensp;&ensp;&ensp;&ensp;注意：这里sum中的i表示的是前i个数的和，不是下标，因为题目中需要用到前0个数的和。</p>
<h2 id="1-3-一维前缀和举例"><a href="#1-3-一维前缀和举例" class="headerlink" title="1.3 一维前缀和举例"></a>1.3 一维前缀和举例</h2><p><strong>例题1：</strong>   </p>
<p>输入一个长度为 n 的整数序列。</p>
<p>接下来再输入 m 个询问，每个询问输入一对 l,r。</p>
<p>对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。</p>
<p><strong>输入格式</strong><br>第一行包含两个整数 n 和 m。</p>
<p>第二行包含 n 个整数，表示整数数列。</p>
<p>接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。</p>
<p><strong>输出格式</strong><br>共 m 行，每行输出一个询问的结果。</p>
<p><strong>数据范围</strong><br>1≤l≤r≤n,<br>1≤n,m≤100000,<br>−1000≤数列中元素的值≤1000  </p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 3  </span><br><span class="line">2 1 3 6 4  </span><br><span class="line">1 2  </span><br><span class="line">1 3  </span><br><span class="line">2 4  </span><br></pre></td></tr></table></figure>
<p><strong>输出样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3  </span><br><span class="line">6  </span><br><span class="line">10 </span><br></pre></td></tr></table></figure>

<p><strong>代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> a[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> s[n+<span class="number">1</span>];</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        s[i] = s[i<span class="number">-1</span>] + a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s[y] - s[x<span class="number">-1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;思想和相关代码的实现都非常简单，但是如果简单对给出的每一组数据都采用从a[l]到a[r]累加求和的方式，复杂度会由O(m+n)上升为O(mn)，导致部分样例超时无法通过。</p>
<h1 id="二、二维矩阵前缀和"><a href="#二、二维矩阵前缀和" class="headerlink" title="二、二维矩阵前缀和"></a>二、二维矩阵前缀和</h1><h2 id="2-1-问题提出"><a href="#2-1-问题提出" class="headerlink" title="2.1 问题提出"></a>2.1 问题提出</h2><p><strong>例题二：</strong><br>输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。</p>
<p>对于每个询问输出子矩阵中所有数的和。</p>
<p><strong>输入格式</strong><br>第一行包含三个整数 n，m，q。</p>
<p>接下来 n 行，每行包含 m 个整数，表示整数矩阵。</p>
<p>接下来 q 行，每行包含四个整数 x1,y1,x2,y2，表示一组询问。</p>
<p><strong>输出格式</strong><br>共 q 行，每行输出一个询问的结果。</p>
<p><strong>数据范围</strong><br>1≤n,m≤1000,<br>1≤q≤200000,<br>1≤x1≤x2≤n,<br>1≤y1≤y2≤m,<br>−1000≤矩阵内元素的值≤1000  </p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4 3  </span><br><span class="line">1 7 2 4  </span><br><span class="line">3 6 2 8  </span><br><span class="line">2 1 2 3  </span><br><span class="line">1 1 2 2   </span><br><span class="line">2 1 3 4  </span><br><span class="line">1 3 3 4  </span><br></pre></td></tr></table></figure>
<p><strong>输出样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">17</span><br><span class="line">27</span><br><span class="line">21</span><br></pre></td></tr></table></figure>

<h2 id="2-2-问题思考"><a href="#2-2-问题思考" class="headerlink" title="2.2 问题思考"></a>2.2 问题思考</h2><p>&ensp;&ensp;&ensp;&ensp;要求子矩阵的和，很容易想到类比到一维数组的前缀和，使用相同的方式解决。在使用前缀和解决求子矩阵和的过程中，需要解决两个问题：<br>&ensp;&ensp;&ensp;&ensp;1）如何计算前缀和矩阵；<br>&ensp;&ensp;&ensp;&ensp;2）如何利用前缀和矩阵，计算某一个子矩阵的和。<br>&ensp;&ensp;&ensp;&ensp;通过解决这两个问题，便可以得到一个关于s[x][y]的递推式和答案的递推式，通过这两个递推式便能够以一个较低的复杂度解决相关问题。<br>&ensp;&ensp;&ensp;&ensp;下面依次来解决这两个问题。 </p>
<h2 id="2-3-使用容斥原理解决二维矩阵前缀和问题"><a href="#2-3-使用容斥原理解决二维矩阵前缀和问题" class="headerlink" title="2.3 使用容斥原理解决二维矩阵前缀和问题"></a>2.3 使用容斥原理解决二维矩阵前缀和问题</h2><h3 id="1）计算前缀和矩阵"><a href="#1）计算前缀和矩阵" class="headerlink" title="1）计算前缀和矩阵"></a>1）计算前缀和矩阵</h3><p>&ensp;&ensp;&ensp;&ensp;为了便于观察，首先画出样例给出的前缀和矩阵和原矩阵的示意图,如下：<br><img src="/2021/05/06/%E5%89%8D%E7%BC%80%E5%92%8C/%E5%89%8D%E7%BC%80%E5%92%8C%E7%9F%A9%E9%98%B5%E5%92%8C%E5%8E%9F%E7%9F%A9%E9%98%B5.png" alt="前缀和和原矩阵">  </p>
<p>&ensp;&ensp;&ensp;&ensp;对于这样的问题，想到用容斥原理来计算s[x][y]的值。  </p>
<p>&ensp;&ensp;&ensp;&ensp;容斥原理的简单介绍如下：<br>&ensp;&ensp;&ensp;&ensp;如果被计数的事物有A、B、C三类，那么，A类和B类和C类元素个数总和= A类元素个数+ B类元素个数+C类元素个数—既是A类又是B类的元素个数—既是A类又是C类的元素个数—既是B类又是C类的元素个数+既是A类又是B类而且是C类的元素个数。（A∪B∪C = A+B+C - A∩B - B∩C - C∩A + A∩B∩C）  </p>
<p>&ensp;&ensp;&ensp;&ensp;以求得s[2][3]为例，用s[1][3]加上s[2][2],得到的和的区域范围如下所示：  </p>
<p><img src="/2021/05/06/%E5%89%8D%E7%BC%80%E5%92%8C/%E5%AE%B9%E6%96%A51.png" alt="容斥1"><br>&ensp;&ensp;&ensp;&ensp;黄色标出的区域进行了一次求和，蓝色区域进行了两次求和，为了保证该2x3的范围内每个区域都只进行了一次运算，根据容斥原理，减去这两个区域的交集，即s[1][2]，再加上a[2][3]，便得到了s[2][3]的值。所以s[x][y]的值可由以下递推式得到：<br>&ensp;&ensp;&ensp;&ensp;s[x][y] = s[x - 1][y] + s[x][y - 1] - s[x - 1][y - 1] + a[x][y]  </p>
<h3 id="2）利用前缀和矩阵，计算子矩阵的和"><a href="#2）利用前缀和矩阵，计算子矩阵的和" class="headerlink" title="2）利用前缀和矩阵，计算子矩阵的和"></a>2）利用前缀和矩阵，计算子矩阵的和</h3><p>&ensp;&ensp;&ensp;&ensp;以图中红色所标出的子矩阵为例:<br><img src="/2021/05/06/%E5%89%8D%E7%BC%80%E5%92%8C/%E5%AE%B9%E6%96%A52.png" alt="容斥2"><br>&ensp;&ensp;&ensp;&ensp;首先明确一下，对于任何一个s[x][y]表示的是从(0,0)的点到(x,y)点所有元素的和，所以要解决的问题便是如何在9x9的黄色区域中扣除掉倒“7”字型的区域。<br>&ensp;&ensp;&ensp;&ensp;同样是利用容斥原理，首先扣除上方区域，即s[1][3]，接着扣除左边区域，即s[3][1]，最后加上重复扣除的这两个区域的交集，即s[1][1]。推广开来，对于求(x1,y1)到(x2,y2)的子矩阵的和的递推公式可写为：<br>&ensp;&ensp;&ensp;&ensp;sum = s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1]  </p>
<h2 id="2-4-代码实现"><a href="#2-4-代码实现" class="headerlink" title="2.4 代码实现"></a>2.4 代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">            s[i][j] = s[i<span class="number">-1</span>][j] + s[i][j<span class="number">-1</span>] - s[i<span class="number">-1</span>][j<span class="number">-1</span>] + a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i ++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x1, x2, y1, y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>&ensp;&ensp;&ensp;&ensp;对于二维矩阵的前缀和，通过容斥原理得到相关递推公式后便可轻松得出。部分范围的复杂度从O(mn)降低到了O(1)。</p>
]]></content>
      <categories>
        <category>practise</category>
      </categories>
      <tags>
        <tag>算法练习</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实验课作业一——进程同步</title>
    <url>/2021/04/11/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&ensp;&ensp;&ensp;&ensp;linux模拟进程同步问题。</p>
<span id="more"></span>
<h1 id="一、实验概述"><a href="#一、实验概述" class="headerlink" title="一、实验概述"></a>一、实验概述</h1><h2 id="1、实验目的及要求"><a href="#1、实验目的及要求" class="headerlink" title="1、实验目的及要求"></a>1、实验目的及要求</h2><p>（1）了解进程同步和互斥的含义<br>（2）掌握操作系统进程同步的基本原理<br>（3）理解基本进程同步模型，学会使用进程同步机制<br>（4）能够编码实现进程同步问题  </p>
<h2 id="2、实验内容"><a href="#2、实验内容" class="headerlink" title="2、实验内容"></a>2、实验内容</h2><p>&ensp;&ensp;&ensp;&ensp;阅览室读书问题：假定一个阅览室最多可容纳10人，读者进入和离开阅览室时都必须在阅览室门口的一个登记表上进行登记，而且每次只允许一人进行登记操作。请用信号量实现上述进程的同步问题。（假设读者有20个每个读者阅读时间是随机的）。<br>(在ubuntu/windows环境下，编码实现）</p>
<h2 id="3、基本理论介绍"><a href="#3、基本理论介绍" class="headerlink" title="3、基本理论介绍"></a>3、基本理论介绍</h2><p>（1）P、V操作<br>&ensp;&ensp;&ensp;&ensp;PV操作由P操作原语和V操作原语组成（原语是不可中断的过程），对信号量进行操作，具体定义如下：<br>&ensp;&ensp;&ensp;&ensp;P（S）：①将信号量S的值减1，即S=S-1；<br>②如果S&gt;0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。<br>&ensp;&ensp;&ensp;&ensp;V（S）：①将信号量S的值加1，即S=S+1；<br>&ensp;&ensp;&ensp;&ensp;②如果S&gt;0，则该进程继续执行；否则释放队列中第一个等待信号量的进程。<br>（2）信号量<br>&ensp;&ensp;&ensp;&ensp;信号量（semaphore）的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程。信号量的值与相应资源的使用情况有关。当它的值大于0时，表示当前可用资源的数量；当它的值小于0时，其绝对值表示等待使用该资源的进程个数。注意，信号量的值仅能由PV操作来改变。<br>&ensp;&ensp;&ensp;&ensp;一般来说，信号量S&gt;0时，S表示可用资源的数量。执行一次P操作意味着请求分配一个单位资源，因此S的值减1；当S&lt;0时，表示已经没有可用资源，请求者必须等待别的进程释放该类资源，它才能运行下去。而执行一个V操作意味着释放一个单位资源，因此S的值加1；若S&lt;0，表示有某些进程正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去。  </p>
<h1 id="二、实验过程"><a href="#二、实验过程" class="headerlink" title="二、实验过程"></a>二、实验过程</h1><h2 id="1、分析题目"><a href="#1、分析题目" class="headerlink" title="1、分析题目"></a>1、分析题目</h2><p>&ensp;&ensp;&ensp;&ensp;由题知：阅览室的座位数代表资源数，登记区为临界资源mutex，出和入用信号量empty和full来记录，其中empty的初始值为10，full的初始值为0。<br>&ensp;&ensp;&ensp;&ensp;进入时：<br>&ensp;&ensp;&ensp;&ensp;①等待阅览室有空座位，即empty&gt;0，分配资源<br>&ensp;&ensp;&ensp;&ensp;②进入登记区，等待临界资源mutex<br>&ensp;&ensp;&ensp;&ensp;③进行登记，进入阅览室，阅览室座位减少，即释放一个full<br>&ensp;&ensp;&ensp;&ensp;退出时：<br>&ensp;&ensp;&ensp;&ensp;①首先确保阅览室内有人正在阅读，即等待full（读者先阅读若干时间）<br>&ensp;&ensp;&ensp;&ensp;②读者想要退出，进入登记区，等待临界资源mutex<br>&ensp;&ensp;&ensp;&ensp;③进行登记，退出阅览室，阅览室座位增加，即释放一个empty  </p>
<h2 id="2、代码结构"><a href="#2、代码结构" class="headerlink" title="2、代码结构"></a>2、代码结构</h2><p>&ensp;&ensp;&ensp;&ensp;①void IN_fun(void* arg)进入的函数<br>&ensp;&ensp;&ensp;&ensp;②void OUT_fun(void* arg)退出的函数<br>&ensp;&ensp;&ensp;&ensp;③int main()主函数  </p>
<h2 id="3、程序伪代码"><a href="#3、程序伪代码" class="headerlink" title="3、程序伪代码"></a>3、程序伪代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Void IN_fun()&#123;</span><br><span class="line">Wait(empty);</span><br><span class="line">Wait(mutex);</span><br><span class="line">登记</span><br><span class="line">Signal(mutex);</span><br><span class="line">Signal(full);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Void OUT_fun()&#123;</span><br><span class="line">阅读</span><br><span class="line">Wait(full);</span><br><span class="line">Wait(mutex);</span><br><span class="line">Signal(mutex);</span><br><span class="line">Signal(empty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、实验结果"><a href="#三、实验结果" class="headerlink" title="三、实验结果"></a>三、实验结果</h1><h2 id="1、功能实现"><a href="#1、功能实现" class="headerlink" title="1、功能实现"></a>1、功能实现</h2><p>&ensp;&ensp;&ensp;&ensp;该程序用进程同步模拟了阅览室的人员进出问题。</p>
<h2 id="2、结果测试"><a href="#2、结果测试" class="headerlink" title="2、结果测试"></a>2、结果测试</h2><p><img src="/2021/04/11/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/1.png" alt="1"><br><img src="/2021/04/11/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/2.png" alt="2"></p>
<h2 id="3、结果分析"><a href="#3、结果分析" class="headerlink" title="3、结果分析"></a>3、结果分析</h2><p>&ensp;&ensp;&ensp;&ensp;实验结果如上图所示，剩余资源和读者进出都能够正确提示。实现了进程同步。</p>
<h1 id="四、心得体会"><a href="#四、心得体会" class="headerlink" title="四、心得体会"></a>四、心得体会</h1><p>&ensp;&ensp;&ensp;&ensp;略。</p>
<h1 id="五、代码附录"><a href="#五、代码附录" class="headerlink" title="五、代码附录"></a>五、代码附录</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READERS_NUM 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_SIZE 11</span></span><br><span class="line"><span class="keyword">int</span> pool[POOL_SIZE];</span><br><span class="line"><span class="keyword">int</span> out = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> in = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">sem_t</span> empty;</span><br><span class="line"><span class="keyword">sem_t</span> full;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IN_fun</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		sem_wait(&amp;empty);</span><br><span class="line">		pthread_mutex_lock(&amp;mutex);</span><br><span class="line">		in = (in+<span class="number">1</span>)%POOL_SIZE;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;READERS %d entered the reading room\n&quot;</span>,(<span class="keyword">int</span>)(<span class="keyword">long</span>)arg);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d seats are empty\n&quot;</span>,(out-in+POOL_SIZE<span class="number">-1</span>)%POOL_SIZE);</span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">		sem_post(&amp;full);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OUT_fun</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		sleep(<span class="number">10</span>);</span><br><span class="line">		sem_wait(&amp;full);</span><br><span class="line">		pthread_mutex_lock(&amp;mutex);</span><br><span class="line">		out = (out + <span class="number">1</span>)%POOL_SIZE;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;READER %d quited the room\n&quot;</span>,(<span class="keyword">int</span>)(<span class="keyword">long</span>)arg);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d seats are empty\n&quot;</span>,(out-in+POOL_SIZE<span class="number">-1</span>)%POOL_SIZE);</span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">		sem_post(&amp;empty);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">pthread_t</span> IN_id[READERS_NUM];</span><br><span class="line">	<span class="keyword">pthread_t</span> OUT_id[READERS_NUM];</span><br><span class="line">	pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">int</span> ret = sem_init(&amp;empty,<span class="number">0</span>,POOL_SIZE<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;sem_init error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ret = sem_init(&amp;full,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;sem_init error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; READERS_NUM;i++)&#123;</span><br><span class="line">		ret = pthread_create(&amp;IN_id[i],<span class="literal">NULL</span>,(<span class="keyword">void</span>*)IN_fun,(<span class="keyword">void</span>*)(<span class="keyword">long</span>)i);</span><br><span class="line">		<span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;IN_id error&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		ret = pthread_create(&amp;OUT_id[i],<span class="literal">NULL</span>,(<span class="keyword">void</span>*)OUT_fun,(<span class="keyword">void</span>*)(<span class="keyword">long</span>)i);</span><br><span class="line">		<span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;OUT_id error&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; READERS_NUM;i++)&#123;</span><br><span class="line">		pthread_join(IN_id[i],<span class="literal">NULL</span>);</span><br><span class="line">		pthread_join(OUT_id[i],<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>实验课作业</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记——第四章（绝赞完结）</title>
    <url>/2021/05/10/os-4/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>个人操作系统笔记整理，欢迎参考，时不时更新。  </p>
<span id="more"></span>

<h1 id="第四章-存储器管理"><a href="#第四章-存储器管理" class="headerlink" title="第四章 存储器管理"></a>第四章 存储器管理</h1><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><ul>
<li>多道程序环境中,多个进程如何划分内存空间？</li>
<li>每个进程是否占用独立的空间？</li>
<li>多大的空间？</li>
<li>固定分配还是按需分配空间？</li>
<li>进程所需数据是一次性地装入内存？还是临时多次装入？该如何进行相应的管理。</li>
<li>内存中的进程如何自我保护？</li>
<li>进程之间如何共享数据</li>
</ul>
<h2 id="4-1-存储器的层次结构"><a href="#4-1-存储器的层次结构" class="headerlink" title="4.1 存储器的层次结构"></a>4.1 存储器的层次结构</h2><p>&ensp;&ensp;&ensp;&ensp;在计算机执行时，几乎每一条指令都涉及对存储器的访问，因此存储器的速度必须非常快，能与处理机的速度相匹配。<br>&ensp;&ensp;&ensp;&ensp;此外还要求存储器的具有非常大的容量，而且存储器的价格还应很便宜。<br>&ensp;&ensp;&ensp;&ensp;这样三个条件，目前是无法同时满足的，因而采取<font color="#FF0000">多层结构</font>的存储器系统。</p>
<h3 id="4-1-1-层次结构"><a href="#4-1-1-层次结构" class="headerlink" title="4.1.1 层次结构"></a>4.1.1 层次结构</h3><p><strong>一、存储器的多层结构</strong><br>&ensp;&ensp;&ensp;&ensp;1）系统管理：寄存器、高速缓存、主存储器和磁盘缓存<br>&ensp;&ensp;&ensp;&ensp;2）设备管理：固定磁盘和可移动存储介质<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%871.png"><br><strong>二、可执行存储器：寄存器、主存</strong>  </p>
<ul>
<li>对于存放在可执行存储器和辅存中的信息访问机制不同</li>
<li>OS的存储管理负责对可执行存储器进行分配、回收、及管理</li>
<li>OS的设备和文件管理，根据用户的需要对辅存提供管理</li>
</ul>
<h3 id="4-1-2-主存储器与寄存器"><a href="#4-1-2-主存储器与寄存器" class="headerlink" title="4.1.2 主存储器与寄存器"></a>4.1.2 主存储器与寄存器</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>主存储器</strong>：  </p>
<ul>
<li>几十MB到数GB，<font color="#FF0000">用于存放进程运行时的程序和数据</font>  </li>
<li>CPU都是从主存中取指令和数据</li>
<li>CPU与外设交换信息时也依靠主存</li>
<li>主存与CPU的速度矛盾,引入寄存器和高速缓存  </li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;<strong>寄存器</strong>：  </p>
<ul>
<li>寄存器具有与处理机相同的速度，完全能与CPU协调工作，但价格十分昂贵，因此容量不可能很大</li>
<li>用于加速存储器的访问速度</li>
<li>存放处理机运行时的数据</li>
</ul>
<h3 id="4-1-3-高速缓存和磁盘缓存"><a href="#4-1-3-高速缓存和磁盘缓存" class="headerlink" title="4.1.3 高速缓存和磁盘缓存"></a>4.1.3 高速缓存和磁盘缓存</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>高速缓存</strong>：  </p>
<ul>
<li>从几十KB到几MB，访问速度快于主存。</li>
<li>将主存中一些经常访问的信息存放在高速缓存中，可提高程序执行速度。</li>
<li>它是介于寄存器和存储器之间的存储器件</li>
<li>其容量大于寄存器，速度快于主存。  </li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;<strong>磁盘缓存</strong>：  </p>
<ul>
<li>将频繁使用的一部分磁盘数据和信息，暂时存放在磁盘缓存中，可减少访问磁盘的次数。</li>
<li>提供对主存储器存储空间的扩充</li>
<li>一个文件的数据可能出现在不同存储器层次中</li>
</ul>
<h3 id="4-1-4-内存管理的功能目标"><a href="#4-1-4-内存管理的功能目标" class="headerlink" title="4.1.4 内存管理的功能目标"></a>4.1.4 内存管理的功能目标</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>内存分配</strong>：  </p>
<ul>
<li>使得各得其所、提高利用率及适应动态增长的需求</li>
<li>连续分配/离散分配  </li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;<strong>地址映射</strong>：  </p>
<ul>
<li>逻辑地址转换为物理地址，与分配方式有关</li>
<li>内存保护</li>
<li>基于地址的保护、存取访问控制保护</li>
<li>内存扩充</li>
<li>对换技术、虚拟技术</li>
</ul>
<h2 id="4-2-程序的装入和连接"><a href="#4-2-程序的装入和连接" class="headerlink" title="4.2 程序的装入和连接"></a>4.2 程序的装入和连接</h2><p>需要了解的几个重要概念：  </p>
<ul>
<li>物理地址及物理地址空间</li>
<li>逻辑地址及逻辑地址空间</li>
<li>为何要进行地址转换？</li>
<li>什么是重定位</li>
<li>可执行程序的生成步骤</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1、内存的物理组织</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;物理地址：<br>&ensp;&ensp;&ensp;&ensp;把内存分成若干个大小相等的存储单元(字节),每字节给一个编号，称为内存地址,(物理地址、绝对地址、实地址) 。  </p>
<p>&ensp;&ensp;&ensp;&ensp;物理地址空间：<br>&ensp;&ensp;&ensp;&ensp;即物理地址的集合（也叫主存空间），它是一维的线性空间。  </p>
<p><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%872.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2、程序的逻辑结构</strong><br>&ensp;&ensp;&ensp;&ensp;逻辑地址：<br>&ensp;&ensp;&ensp;&ensp;用户程序经过汇编或编译后形成的目标代码，通常采用相对地址形式，首地址为0，其余指令中的地址都相对于首地址而编址<br>&ensp;&ensp;&ensp;&ensp;逻辑地址空间：<br>&ensp;&ensp;&ensp;&ensp;用户的程序地址的集合（或程序地址空间、虚地址空间，用户地址空间）.<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%873.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3、重定位（地址映射）</strong><br>&ensp;&ensp;&ensp;&ensp;为何要进行地址转换？<br>&ensp;&ensp;&ensp;&ensp;1）程序装入内存时,OS要为其分配合适内存空间。<br>&ensp;&ensp;&ensp;&ensp;2）程序使用逻辑地址, 而CPU执行指令时，是按物理地址进行？<br>&ensp;&ensp;&ensp;&ensp;3）程序的逻辑地址与分配到内存物理地址不一定一致, 所以要进行地址转换。  </p>
<p>&ensp;&ensp;&ensp;&ensp;重定位：<br>&ensp;&ensp;&ensp;&ensp;即是将可执行文件中逻辑地址变换成主存中物理地址的过程，称为地址重定位（或地址映射）。<br>&ensp;&ensp;&ensp;&ensp;这一过程由OS的装入程序loader来完成。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4、可执行程序的生成步骤</strong><br>&ensp;&ensp;&ensp;&ensp;程序成为进程前所需的准备工作：<br>&ensp;&ensp;&ensp;&ensp;编译：形成目标模块(形成逻辑地址)<br>&ensp;&ensp;&ensp;&ensp;链接：由多个目标模块或程序库生成可执行装入模块(更新逻辑地址)<br>&ensp;&ensp;&ensp;&ensp;装入：构造PCB，形成进程(使用物理地址).<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%874.png">  </p>
<h3 id="4-2-1-程序的装入"><a href="#4-2-1-程序的装入" class="headerlink" title="4.2.1 程序的装入"></a>4.2.1 程序的装入</h3><p>&ensp;&ensp;&ensp;&ensp;可执行程序装入内存需要解决的问题：</p>
<p>&ensp;&ensp;&ensp;&ensp;1、如何装入待执行的程序及其所需的数据？<br>&ensp;&ensp;&ensp;&ensp;2、何时将程序的逻辑地址转换为物理地址？  </p>
<p>&ensp;&ensp;&ensp;&ensp;三种装入方式：  </p>
<ul>
<li>绝对装入方式       </li>
<li>静态重定位装入方式   </li>
<li>动态重定位装入方式  </li>
</ul>
<h4 id="1、绝对装入方式"><a href="#1、绝对装入方式" class="headerlink" title="1、绝对装入方式"></a>1、绝对装入方式</h4><ul>
<li><p>当计算机系统很小，仅能运行单道程序时，完全有可能知道程序驻留在内存的地址，此时可以采用绝对装入方式。</p>
</li>
<li><p>用户程序经编译后，将产生绝对地址的目标代码。程序可按照装入模块的地址将程序和数据装入内存。</p>
</li>
<li><p>程序中的相对地址与实际内存地址完全相同，故不需对程序和数据的地址进行修改。  </p>
</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;<strong>优点</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;1）按程序逻辑地址将程序和数据装入内存。逻辑地址即物理地址。<br>&ensp;&ensp;&ensp;&ensp;2）实现简单，无需进行地址变换。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>缺点</strong><br>&ensp;&ensp;&ensp;&ensp;1）程序中使用绝对地址<br>&ensp;&ensp;&ensp;&ensp;2）程序装入内存指定地址段<br>&ensp;&ensp;&ensp;&ensp;3）程序员熟悉内存的使用情况<br>&ensp;&ensp;&ensp;&ensp;4）程序动态修改或装入困难  </p>
<h4 id="2、可重定位装入方式"><a href="#2、可重定位装入方式" class="headerlink" title="2、可重定位装入方式"></a>2、可重定位装入方式</h4><p>&ensp;&ensp;&ensp;&ensp;装入程序把目标模块中的逻辑地址与本程序在内存中的起始地址相加得到正确的物理地址。<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%875.png">   </p>
<ul>
<li><p>允许程序装入与逻辑地址不同的物理地址空间。用户程序被装入内存时，需进行地址转换。</p>
</li>
<li><p>地址映射在装入时一次性完成，以后不再更改程序地址，故也称<strong>静态重定位</strong>。  </p>
</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;优点：实现简单，不要硬件的支持。<br>&ensp;&ensp;&ensp;&ensp;缺点：程序装入内存后，移动就比较困难。  </p>
<h4 id="3、动态运行时装入方式"><a href="#3、动态运行时装入方式" class="headerlink" title="3、动态运行时装入方式"></a>3、动态运行时装入方式</h4><p>&ensp;&ensp;&ensp;&ensp;可重定位装入方式的优点是不需硬件支持，可以装入多道程序；缺点是一个程序通常需要占用连续的内存空间，程序装入内存后不能移动。<br>&ensp;&ensp;&ensp;&ensp;把<strong>相对地址到绝对地址的转换</strong>推迟到程序真正执行时才进行。也称为动态重定位。  </p>
<ul>
<li><p>地址转换在程序<strong>运行时动态</strong>进行。需要硬件支持，即<strong>重定位寄存器</strong>。把相对地址和绝对地址的转换推迟到程序真正执行时才进行。</p>
</li>
<li><p>程序被执行时，通过<strong>重定位寄存器</strong>内的起始物理地址和指令或数据的逻辑地址计算其物理地址。</p>
</li>
<li><p>程序中不执行的部分就不做地址映射的工作，这样节省了CPU的时间。</p>
</li>
<li><p>现代计算机系统中都采用<strong>动态重定位</strong>技术</p>
</li>
</ul>
<p><strong>动态地址映射示意图：</strong><br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%876.png"></p>
<h3 id="4-2-2-程序的链接"><a href="#4-2-2-程序的链接" class="headerlink" title="4.2.2 程序的链接"></a>4.2.2 程序的链接</h3><p>&ensp;&ensp;&ensp;&ensp;链接：用于它将分别在不同的目标文件中编译或汇编的代码收集到一个可直接执行的文件中。<br>&ensp;&ensp;&ensp;&ensp;链接需要解决的问题：<br>&ensp;&ensp;&ensp;&ensp;1）如何将多个目标模块链接成一个装入模块？<br>&ensp;&ensp;&ensp;&ensp;2）如何将多组逻辑地址更新为一组逻辑地址？<br>&ensp;&ensp;&ensp;&ensp;3种链接方式： </p>
<ul>
<li>静态链接</li>
<li>装入时动态链接</li>
<li>运行时动态链接</li>
</ul>
<h4 id="1、静态链接方式"><a href="#1、静态链接方式" class="headerlink" title="1、静态链接方式"></a>1、静态链接方式</h4><p>&ensp;&ensp;&ensp;&ensp;静态链接：在程序运行之前，将所有目标模块及所需库函数，完全链接成一个装入模块，以后不再拆开。<br>&ensp;&ensp;&ensp;&ensp;①<strong>对逻辑地址进行更新</strong>：相对于整个模块第一条语句的起始地址重新计算。<br>&ensp;&ensp;&ensp;&ensp;②<strong>变换外部调用符号</strong>：程序被装入内存之前，将其中的外部调用符号全部转换为相对地址跳转语句。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>缺点</strong>：静态链接需要花费大量的处理机时间。而其中的很多模块将不会运行，浪费存储空间和处理机时间。  </p>
<h4 id="2、装入时动态链接方式"><a href="#2、装入时动态链接方式" class="headerlink" title="2、装入时动态链接方式"></a>2、装入时动态链接方式</h4><p>&ensp;&ensp;&ensp;&ensp;装入时动态链接：不用事先进行链接，系统装入可执行模块时，才进行链接。  </p>
<ul>
<li><p>生成的装入模块，含有未被链接的外部模块引用。这些外部模块可以在装入时链接。</p>
</li>
<li><p>在装入时，遇到未链接的外部模块引用，则查找并将其装入内存。同时更新模块内的指令地址。</p>
</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;通常被链接的共享代码称为动态链接库(DLL, Dynamic-Link Library)或共享库(shared library)。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>优点</strong>：<br>&ensp;&ensp;&ensp;&ensp;1）有便于目标模块的更新与升级；<br>&ensp;&ensp;&ensp;&ensp;2）有利于代码共享；<br>&ensp;&ensp;&ensp;&ensp;3）有利于扩充软件的功能，可以将扩充部分作为动态链接模块。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>缺点</strong>：<br>&ensp;&ensp;&ensp;&ensp;可能会链接一些不会执行的模块，浪费存储空间和处理机时间。</p>
<h4 id="3、运行时动态链接方式"><a href="#3、运行时动态链接方式" class="headerlink" title="3、运行时动态链接方式"></a>3、运行时动态链接方式</h4><p>&ensp;&ensp;&ensp;&ensp;运行时动态链接：外部模块引用直到程序执行时才装入内存，并连接到装入模块中，进行地址转换。<br>&ensp;&ensp;&ensp;&ensp;<strong>优点</strong>：<br>&ensp;&ensp;&ensp;&ensp;1）可以解决静态链接和装入时动态链接都面临的存储空间和处理机时间浪费问题，不需要执行的模块不会装入内存。<br>&ensp;&ensp;&ensp;&ensp;2）广泛用于事务处理系统，如银行管理系统，航空售票系统等。<br>&ensp;&ensp;&ensp;&ensp;3）操作系统自身的一些特殊处理例程，如错误处理例程，也无需实现全部装入内存。  </p>
<h2 id="4-3-连续分配存储管理方式"><a href="#4-3-连续分配存储管理方式" class="headerlink" title="4.3 连续分配存储管理方式"></a>4.3 连续分配存储管理方式</h2><p>&ensp;&ensp;&ensp;&ensp;<strong>一、连续分配的基本思想</strong><br>&ensp;&ensp;&ensp;&ensp; 连续分配是指为一个用户程序分配一个连续的内存空间，有两种方式。<br> &ensp;&ensp;&ensp;&ensp;把内存分成若干个大小不等的连续区域，称作分区，每个作业一般占用一个分区。<br>&ensp;&ensp;&ensp;&ensp;<strong>二、分类</strong><br>  &ensp;&ensp;&ensp;&ensp;1、单一连续分配<br>  &ensp;&ensp;&ensp;&ensp;2、固定分区分配<br>  &ensp;&ensp;&ensp;&ensp;3、动态分区分配<br>  &ensp;&ensp;&ensp;&ensp;4、动态重定位分区分配  </p>
<h3 id="4-3-1-单一连续分配方式"><a href="#4-3-1-单一连续分配方式" class="headerlink" title="4.3.1 单一连续分配方式"></a>4.3.1 单一连续分配方式</h3><p>&ensp;&ensp;&ensp;&ensp;内存分为两个区域：<strong>系统区</strong>，<strong>用户区</strong><br>&ensp;&ensp;&ensp;&ensp;最简单，适用于单用户、单任务的OS<br>&ensp;&ensp;&ensp;&ensp;优点：易管理,(因单任务)不设置存储保护<br>&ensp;&ensp;&ensp;&ensp;缺点：程序全部装入，对要求内存空间少的程序，造成内存浪费<br>&ensp;&ensp;&ensp;&ensp;地址重定位时，只要将指令或数据的逻辑地址加上用户区基地址，就可以形成物理地址    </p>
<p><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%877.png">  </p>
<h3 id="4-3-2-固定分区分配"><a href="#4-3-2-固定分区分配" class="headerlink" title="4.3.2 固定分区分配"></a>4.3.2 固定分区分配</h3><p>&ensp;&ensp;&ensp;&ensp;固定式分区是在作业装入之前，将内存空间划分为若干个固定大小的区域，每个分区中可以装入一道作业。<br>&ensp;&ensp;&ensp;&ensp;特点：有n个分区，则可同时装入n个作业/任务。  </p>
<p>&ensp;&ensp;&ensp;&ensp;分区大小相等：<br>&ensp;&ensp;&ensp;&ensp;简单但缺乏灵活性</p>
<p>&ensp;&ensp;&ensp;&ensp;分区大小不相等：<br>&ensp;&ensp;&ensp;&ensp;内存利用率更高  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 划分分区的方法</strong><br>&ensp;&ensp;&ensp;&ensp;1）分区大小相等</p>
<ul>
<li>当程序太大时，会造成内存空间的浪费；</li>
<li>当程序太小时，可能不足以装入程序，而使程序无法运行；</li>
<li>只适合于多个相同程序的并发执行（处理多个类型相同的对象）。  </li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;2）分区大小不等  </p>
<ul>
<li>将内存的用户区域划分成大小不等的分区，以适应不同大小的作业的需要。  </li>
<li>多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。  </li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.固定分区的数据结构</strong>    &ensp;&ensp;&ensp;&ensp;分区使用表(内存分配表):记录分区的区号、起始地址、大小、占用情况<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%878.png">  <img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%879.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.固定分区的内存分配</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;1）固定分区分配过程：  </p>
<ul>
<li><p>装入时，由内存分配程序检索内存分配表，找出能满足要求的空闲分区分配给用户  </p>
</li>
<li><p>修改内存分配表中该分区对应表项的状态；  </p>
</li>
<li><p>若找不到大小足够的分区，则拒绝分配内存。  </p>
</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;2）固定分区回收过程：  </p>
<ul>
<li><p>程序执行完毕，释放占用分区  </p>
</li>
<li><p>内存管理程序将改分区的状态置为未分配。  </p>
</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.固定分区特点</strong></p>
<ul>
<li>管理简单，最早的多道程序存储管理方式</li>
<li>内存利用率较低，存在“内碎片”。</li>
</ul>
<p><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8710.png"><br>内碎片(内零头)：  </p>
<p>分区内部不可使用的存储空间</p>
<h3 id="4-3-3-动态分区分配"><a href="#4-3-3-动态分区分配" class="headerlink" title="4.3.3 动态分区分配"></a>4.3.3 动态分区分配</h3><p>&ensp;&ensp;&ensp;&ensp;动态分区是指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。<br>&ensp;&ensp;&ensp;&ensp;动态分区中<strong>分区的大小和分区的个数</strong>都是可变的，而且是根据作业的大小和多少动态地划分。<br>&ensp;&ensp;&ensp;&ensp;这种存储管理技术是固定式分区的改进，既可以获得<strong>较大的灵活性</strong>，又能<strong>提高内存的利用率</strong>。</p>
<p>&ensp;&ensp;&ensp;&ensp;动态分区分配方式又称可变分区分配根据作业大小动态地建立分区，并使分区的大小正好适应作业的需要。<br>&ensp;&ensp;&ensp;&ensp;特点：分区的大小是可变的，分区的数目也是可变的。   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.动态分区分配中的数据结构</strong><br>&ensp;&ensp;&ensp;&ensp;1）空闲分区表<br>&ensp;&ensp;&ensp;&ensp;空闲分区表为每个尚未分配的分区设置一个表项，包括分区的序号、大小、始址和状态。<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8712.png"><br>&ensp;&ensp;&ensp;&ensp;2）空闲分区链<br>&ensp;&ensp;&ensp;&ensp;为了实现对空闲分区的分配和链接，在每个分区的起始部分，设置一些用于控制分区分配的信息以及用于链接其它分区的前向指针；在分区尾部，则设置了一个后向指针。通过前、后向指针将所有的分区链接成一个双向链表。<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8713.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 动态分区分配算法</strong><br>&ensp;&ensp;&ensp;&ensp;分区内存分配过程：  </p>
<ul>
<li>寻找适当容量的空闲分区  </li>
<li>将该分区分割成两个分区，其中一个分区为作业要求的大小，分配给申请者  </li>
<li>另一分区(余下部分)仍为“空闲”。</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;分区内存回收过程：  </p>
<ul>
<li>释放占用分区，在空闲分区表增加对应表项。  </li>
<li>相邻的空闲分区，合并成一个空闲分区。 </li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;需要解决的问题是：<strong>能否合并和何时合并</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>顺序搜索法：</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;1）首次适应算法(first fit)<br>&ensp;&ensp;&ensp;&ensp;2）循环首次适应算法(next fit)<br>&ensp;&ensp;&ensp;&ensp;3）最佳适应算法(best fit)<br>&ensp;&ensp;&ensp;&ensp;4）最坏适应算法(worst fit)  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>索引搜索法</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;1）快速适应算法(quick fit)<br>&ensp;&ensp;&ensp;&ensp;2）伙伴系统<br>&ensp;&ensp;&ensp;&ensp;3）哈希算法  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 分区分配操作</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在动态分区存储管理方式中，主要的操作是分配内存和回收内存。<br>&ensp;&ensp;&ensp;&ensp;（1） 分配内存<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8714.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4. 动态分区分配的缺点</strong><br>&ensp;&ensp;&ensp;&ensp;1）系统运行过程中，形成多个空闲的不连续的存储区，称为空闲区<br>&ensp;&ensp;&ensp;&ensp;2）<strong>外碎片</strong>：分区之间无法利用的存储空间，通常是小空闲区  </p>
<p>&ensp;&ensp;&ensp;&ensp;解决办法：<br>&ensp;&ensp;&ensp;&ensp;拼接或紧凑技术，把分散的多个小空闲区合并为一个大的空闲分区。  </p>
<h3 id="4-3-4-基于顺序搜索的动态分区分配算法"><a href="#4-3-4-基于顺序搜索的动态分区分配算法" class="headerlink" title="4.3.4 基于顺序搜索的动态分区分配算法"></a>4.3.4 基于顺序搜索的动态分区分配算法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 首次适应算法FF (first-fit)</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;要求：</p>
<ul>
<li>空闲分区表(链)按低址―&gt;高址链接；  </li>
<li>从表首顺序查找，找到第一个适合的空闲区  </li>
<li>从该分区划出适当空间分配给请求者；  </li>
<li>余下的空闲分区更新数据后，仍然留空闲分区表(链)中。<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8715.png">   </li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;<strong>回收过程</strong>：</p>
<p>&ensp;&ensp;&ensp;&ensp;1）若有相邻空闲区，则合并<br>&ensp;&ensp;&ensp;&ensp;2）否则，将释放区按首地址升序的规则插入到空闲区表适当的位置。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>优点</strong>： </p>
<p>&ensp;&ensp;&ensp;&ensp;保留高地址大空闲区，利于<strong>大作业</strong>。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>缺点</strong>：  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）容易产生碎片<br>&ensp;&ensp;&ensp;&ensp;2）低地址端过多小空闲区，增加查找开销  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2．循环首次适应算法NF (next fit)</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）按地址递增的顺序链接<br>&ensp;&ensp;&ensp;&ensp;2）从上一次分配的下一个地址开始查找，找到第一个适合的空闲区。<br>&ensp;&ensp;&ensp;&ensp;3）划出适当空间分配给请求者，余下的空闲分区更新数据后，仍然留空闲分区表(链)中。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>优点</strong>：使存储空间更均衡，便于查找<br>&ensp;&ensp;&ensp;&ensp;<strong>缺点</strong>：缺乏大的空闲分区，不利于大作业。<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8716.png">      </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3．最佳适应算法BF (best-fit)</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）以容量递增的次序链接<br>&ensp;&ensp;&ensp;&ensp;2）从表(链)首开始顺序查找，直到找到第一个适合的空闲分区。<br>&ensp;&ensp;&ensp;&ensp;3）若该空闲区大于作业，则划出适当空间分配出去，剩余空闲区仍留在空闲分区表(链)中。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>优点</strong>：找到的空闲区总既满足要求又是最小的。<br>&ensp;&ensp;&ensp;&ensp;<strong>缺点</strong>：留下较小的无法利用的外碎片。<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8717.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4．最坏适应算法WF (worst-fit)</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;1）要求空闲分区按容量递减排列。<br>&ensp;&ensp;&ensp;&ensp;2）从表(链)首开始顺序查找，若第一个表目都不能满足要求，分配失败；<br>&ensp;&ensp;&ensp;&ensp;3）否则，划出适当分区给申请者，剩余空闲区插入空闲区表适当位置。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>优点</strong>：基本不留小分区<br>&ensp;&ensp;&ensp;&ensp;<strong>缺点</strong>：较大的空闲分区不被保留。<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8718.png">  </p>
<h3 id="4-3-5-基于索引搜索的动态分区分配算法"><a href="#4-3-5-基于索引搜索的动态分区分配算法" class="headerlink" title="4.3.5 基于索引搜索的动态分区分配算法"></a>4.3.5 基于索引搜索的动态分区分配算法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 快速适应算法（Quick Fit, QF）</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）空闲分区根据其容量大小进行分类，系统中存在多个空闲分区链表<br>&ensp;&ensp;&ensp;&ensp;2）内存中设立一张管理索引表<br>&ensp;&ensp;&ensp;&ensp;3）每个索引表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头指针  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>特点</strong>：节省空间，但算法复杂  </p>
<p>&ensp;&ensp;&ensp;&ensp;该算法分为两步：第一步根据进程长度，从索引表中寻找到能容纳它的最小空闲区链表；第二步是从链表中取下第一块进行分配即可。<br>&ensp;&ensp;&ensp;&ensp;<strong>优点</strong>：不会产生内存分割，能保留大的分区。也不会产生内存碎片；<br>&ensp;&ensp;&ensp;&ensp;<strong>缺点</strong>：为了有效合并分区，在分区归还时的算法复杂，且分配存在一定的浪费。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 伙伴系统（Buddy System）</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;该算法规定，无论已分配分区或空闲分区，其大小均为2的k次幂（1&lt;=k&lt;=m）。<br>&ensp;&ensp;&ensp;&ensp;对空闲分区按大小进行分类，为具有相同大小的所有空闲分区，设立一个双向链表。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>分配</strong>：单位进程分配一个大小为n的空间时，先计算一个i值（2i-1&lt;n&lt;=2i），然后在大小为2i的分区链表中查找。若找到，则分配成功。<br>&ensp;&ensp;&ensp;&ensp;若找不到，表明长度为2i的分区已经耗尽，则在分区2i+1的空闲链表中寻找。如果找到，则将其分为两个大小为2i的分区，这两个分区称为一对伙伴。一个用于分配，另一个加入大小为2i的空闲分区链表。<br>&ensp;&ensp;&ensp;&ensp;若找不到，继续在2i+2的空闲链表中寻找，找到后进行两次分割。  </p>
<p>&ensp;&ensp;&ensp;&ensp;回收时可能要进行多次合并，如回收大小为2i的空闲分区时，若已经存在2i的空闲分区，则应将其与伙伴分区进行合并为大小为2i+1的空闲分区，依此类推。<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8719.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;伙伴系统的宗旨就是用最小的内存块来满足内核的对于内存的请求。在最初，只有一个块，也就是整个内存，假如为1M大小，而允许的最小块为64K，那么当我们申请一块200K大小的内存时，就要先将1M的块分裂成两等分，各为512K，这两分之间的关系就称为伙伴，然后再将第一个512K的内存块分裂成两等分，各位256K，将第一个256K的内存块分配给内存，这样就是一个分配的过程。下面我们结合示意图来了解伙伴系统分配和回收内存块的过程。<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8720.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 哈希算法</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;分类搜索、伙伴系统算法，空闲区按大小分类链接，多个链，如果分类细，链表多，搜索索引表找适合的链表开销大，可能导致性能下降。  </p>
<p>&ensp;&ensp;&ensp;&ensp;哈希算法是利用哈希快速查找的优点，在分类索引表中快速查找空闲分区链。  </p>
<h3 id="4-3-6-动态可重定位分区分配"><a href="#4-3-6-动态可重定位分区分配" class="headerlink" title="4.3.6 动态可重定位分区分配"></a>4.3.6 动态可重定位分区分配</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 紧凑</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;如果系统中只有若干空闲小分区，即使<strong>总容量和大于要装入的程序</strong>，由于连<strong>续分配方式要求连续</strong>，所以还是<strong>不能装入新的程序</strong>。  </p>
<p>&ensp;&ensp;&ensp;&ensp;如果可以将所有程序进行移动，可以将原来分散的空闲的小分区挪成一个大分区。就可以装入新程序。这种方式叫<strong>“拼接”或“紧凑”</strong>。  </p>
<p>&ensp;&ensp;&ensp;&ensp;每次“紧凑”后原来程序的物理地址都发生了变化，需要通过<strong>相对地址进行重定位</strong>。<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8722.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 可重定位分区分配</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;动态运行时装入方式，程序装入内存后，所有地址都是相对地址，只有程序指令在执行的时候才将其转换为物理地址。</p>
<p>&ensp;&ensp;&ensp;&ensp;需要设置重定位寄存器，保存当前正在执行程序在内存中的起始地址。</p>
<p>&ensp;&ensp;&ensp;&ensp;执行程序时，将程序内的相对地址与重定位寄存器中保存起始地址相加得到物理地址。</p>
<h2 id="4-4-对换（swapping）"><a href="#4-4-对换（swapping）" class="headerlink" title="4.4 对换（swapping）"></a>4.4 对换（swapping）</h2><p>&ensp;&ensp;&ensp;&ensp;对换技术最早用在麻省理工学院的<strong>兼容分时系统</strong>CTSS中，该系统是单用户系统，所有用户都驻留在外存的后备队列中，<strong>每次只调入一个作业进入内存运行，此作业的时间的时间片用完时，又将该作业调至外存，再将后备队列中的一个作业调入内存运行一个时间片。</strong>这是早期的简单分时系统，它采用早期的交换（调进／调出）来满足多个程序共享主存的需要。</p>
<h3 id="4-4-1-多道环境下的对换技术"><a href="#4-4-1-多道环境下的对换技术" class="headerlink" title="4.4.1 多道环境下的对换技术"></a>4.4.1 多道环境下的对换技术</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 对换的引入</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;在多道程序环境下为了提高内存和CPU的利用率，增加<br>系统吞吐量，系统中增设了对换，<strong>把内存中暂不能运行的进程调出到外存上，以腾出足够的内存空间，把已具备运行条件的进程换入内存</strong>。  </p>
<p>&ensp;&ensp;&ensp;&ensp;UNIX早期已引入对换功能并一直保留至今，UNIX系统<br>设置一个对换进程完成以上功能。Windows OS 中也具有对换功能。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 对换的类型</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）整体对换。处理机中的中级调度实际上就是存储器的对换功能，其目的是为了解决内存紧张问题，进一步提高内存利用率和系统吞吐量。中级调度是以进程为单位的对换。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）页面（分段）对换。对换是以进程的一个“页面”或“分段”为单位进行的，则称之为“页面对换”或“分段对换”，又统称为“部分对换”。  </p>
<p>&ensp;&ensp;&ensp;&ensp;为了实现进程对换，系统必须实现对<strong>对换空间的管理</strong>，<strong>进程换入</strong>和<strong>进程换出</strong>等三项功能。  </p>
<h3 id="4-4-2-对换空间的管理"><a href="#4-4-2-对换空间的管理" class="headerlink" title="4.4.2 对换空间的管理"></a>4.4.2 对换空间的管理</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 对换空间管理的主要目标</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;在具有对换功能的OS中，通常把磁盘空间分为文件区和对换区两部分。<br>&ensp;&ensp;&ensp;&ensp;1）对文件区管理的主要目标<br>&ensp;&ensp;&ensp;&ensp;文件区用于存放文件，对文件区管理目标是提高文件存储空间的利用率，为此系统采用离散分配方式；<br>&ensp;&ensp;&ensp;&ensp;2）对对换空间管理的主要目标<br>&ensp;&ensp;&ensp;&ensp;对换区用于存放从内存频繁换出的进程，它的管理目标是提高进程换入换出速度，为此系统采用连续分配方式。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 对换区空闲盘块管理中的数据结构</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;其数据结构的形式与内存在动态分区分配方式中所用的数据结构类似，即同样可以用空闲分区表和空闲分区链。<br>&ensp;&ensp;&ensp;&ensp;其中，每个表目包含：对换区的首地址和大小，分别用盘块号和盘块数表示。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 对换空间的分配与回收</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;与内存中分配与回收方法类似</p>
<h3 id="4-4-3-进程的换出与换入"><a href="#4-4-3-进程的换出与换入" class="headerlink" title="4.4.3 进程的换出与换入"></a>4.4.3 进程的换出与换入</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 进程的换出</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;对换进程在实现进程换出时，是将内存中的某些进程调出至对换区，可分为以下两步：  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）选择被换出的进程。<strong>首先选择阻塞进程</strong>，存在多个时，<strong>优先选择优先级低的</strong>，同时还要考虑进程在内存中的贮存时间。<strong>如无阻塞，则选择优先级低的就绪进程换出</strong>。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）进程换出过程。<strong>只能换出非共享的程序和数据段</strong>。换出时，先申请对换空间，成功换出后修改进程控制块和内存分配表等数据结构。</p>
<h2 id="4-5-分页存储管理方式"><a href="#4-5-分页存储管理方式" class="headerlink" title="4.5 分页存储管理方式"></a>4.5 分页存储管理方式</h2><p>&ensp;&ensp;&ensp;&ensp;<strong>提出分页存储的原因</strong>：  </p>
<p>&ensp;&ensp;&ensp;&ensp;分区存储管理的主要问题是碎片问题。<br>&ensp;&ensp;&ensp;&ensp;小分区不能被系统中的任何用户（程序）利用<br>&ensp;&ensp;&ensp;&ensp;碎片问题的解决：紧凑方式消耗系统开销。<br>&ensp;&ensp;&ensp;&ensp;造成碎片的主要原因是程序整体连续装入内  存。<br>&ensp;&ensp;&ensp;&ensp;若取消作业对存储区的连续性要求，则能较好地解决碎片问题。<br>&ensp;&ensp;&ensp;&ensp;基于这一思想提出的<strong>离散分配</strong><br>&ensp;&ensp;&ensp;&ensp;分页、分段、段页  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>分页存储的基本原理</strong>：  </p>
<p>&ensp;&ensp;&ensp;&ensp;将进程的逻辑地址空间划分成若干大小相等的页(或页面),各页加以编号，从0开始。<br>&ensp;&ensp;&ensp;&ensp;主存空间也划分成与页大小相等的块（或物理块，存储块或页框）。<br>&ensp;&ensp;&ensp;&ensp;在为进程分配存储空间时，总是以块为单位来分配<br>&ensp;&ensp;&ensp;&ensp;页内碎片：由于进程最后一页装不满一个物理块而形成的碎片。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>分页存储的特点</strong>:  </p>
<p>&ensp;&ensp;&ensp;&ensp;将连续的逻辑地址空间的页面，通过页面地址转换机构，映射到不连续的内存块中，实现内存离散分配，节省空间。<br>&ensp;&ensp;&ensp;&ensp;在分页存储管理方式中，若不具备页面对换功能，则称为基本的分页存储管理方式，或称为纯分页存储管理方式。<br>&ensp;&ensp;&ensp;&ensp;基本的分页存储管理方式<strong>不支持虚拟存储器</strong>，要求把每个作业<strong>全部装入内存</strong>后方可运行。</p>
<h3 id="4-5-1-分页存储管理的基本方法"><a href="#4-5-1-分页存储管理的基本方法" class="headerlink" title="4.5.1 分页存储管理的基本方法"></a>4.5.1 分页存储管理的基本方法</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 页面和物理块</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）页面。</p>
<p>&ensp;&ensp;&ensp;&ensp;将进程的逻辑地址空间分成若干个页，并为<br>各页加以编号。相应的，将内存物理地址分为若干个块，同时加以编号。</p>
<p>&ensp;&ensp;&ensp;&ensp;2）页面大小适中<br>&ensp;&ensp;&ensp;&ensp;若页面太大：以至和进程大小相差无几，则退化为分区分配，同时页内碎片也较大。<br>&ensp;&ensp;&ensp;&ensp;若页面太小：虽然可减少页内碎片，但会导致页表增长，换入/出效率低。<br>因此页面大小应适中，与计算机的物理内存大小有关：通常为2的幂，一般在1KB到8KB。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 地址结构</strong>    </p>
<p><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8723.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;它由两部分组成：<br>&ensp;&ensp;&ensp;&ensp;前部分为页号P；后一部分为位移量W，即页内地址d。图中的地址长度为32位，其中0～11位为页内地址（每页的大小为4KB），12～31位为页号，所以允许地址空间的大小最多为1M个页。  </p>
<p>&ensp;&ensp;&ensp;&ensp;逻辑地址:由页号和页内位移量（页内地址）两部分组成<br>&ensp;&ensp;&ensp;&ensp;物理地址:由块号和块内位移量（块内地址）两部分组成</p>
<p>&ensp;&ensp;&ensp;&ensp;由页表实现逻辑地址到物理地址的转换。  </p>
<p>&ensp;&ensp;&ensp;&ensp;逻辑地址A；页大小L(1024)；<br>&ensp;&ensp;&ensp;&ensp;页号：    P=int(A/L)<br>&ensp;&ensp;&ensp;&ensp;页内偏移：d=A mod L  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 页表</strong>    </p>
<p><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8724.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;在将进程的每一页离散地分配到内存的多个物理块中后，系统应能保证能在内存中找到每个页面所对应的物理块。为此，系统为每个进程建立了一张页面映射表，简称页表。<br>&ensp;&ensp;&ensp;&ensp;<strong>每个页在页表中占一个表项</strong>，记录该页在内存中对应的物理块号。进程在执行时，通过查找页表，就可以找到每页所对应的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>页表首地址一般用寄存器记录，其中包含页表在内存的始地址和长度</strong>。<br>&ensp;&ensp;&ensp;&ensp;页表的表项中设置一存取控制字段，用于对该存储块中的内容加以保护。当存取控制字段仅有一位时，可用来规定该存储块中的内容是允许读/写还是只读；若存取控制字段为两位时，则可规定为读/写，只读和只执行等存取方式。如果有进程试图去写一个只允许读的存储块时，将引起操作系统的一次中断。  </p>
<h3 id="4-5-2-地址变换机构"><a href="#4-5-2-地址变换机构" class="headerlink" title="4.5.2 地址变换机构"></a>4.5.2 地址变换机构</h3><p>&ensp;&ensp;&ensp;&ensp;地址变换机构完成：<br>&ensp;&ensp;&ensp;&ensp;逻辑页号—物理块号的映射，由页表完成。<br>&ensp;&ensp;&ensp;&ensp;页表驻留内存中，在系统中只设置一个页表寄存器PTR，其中存放页表在内存的始址和页表的长度。<br>&ensp;&ensp;&ensp;&ensp;进程未执行时，页表的起始地址和页表长度都存储在进程PCB中。进程被调度时，两数据被装入页表寄存器PTR中。  </p>
<p>&ensp;&ensp;&ensp;&ensp;地址变换机构的基本任务是利用页表把用户程序中的逻辑地址变换成内存中的物理地址，实际上就是将用户程序中的页号变换成内存中的物理块号。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 基本的地址变换机构</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）<strong>进程访问某个逻辑地址时</strong>，地址变换机构自动地把有效地址/相对地址分为两部分：页号与页内地址；<br>&ensp;&ensp;&ensp;&ensp;2）页内地址（0<del>1023，页面大小为1KB）与块内地址/页框内地址（0</del>1023）一 一对应，无须转换。<br>&ensp;&ensp;&ensp;&ensp;3）页表<strong>通常</strong>存放于内存中，在系统中设置页表寄存器，用来存放页表在内存的起始地址和页表的长度。在进程未执行时，每个进程对应的页表的始址和长度存放在进程的PCB中，当该进程被调度时，就将它们装入页表寄存器。<br>&ensp;&ensp;&ensp;&ensp;4）将物理地址放入物理地址寄存器中  </p>
<p>&ensp;&ensp;&ensp;&ensp;基本地址变换机构工作流程：<br>&ensp;&ensp;&ensp;&ensp;1）当进程访问某个逻辑地址中的数据时，分页地址变换机构根据PTR找到页表。<br>&ensp;&ensp;&ensp;&ensp;2）分页地址变换机构自动把逻辑地址分化为页号和页内地址。并把页号与页表寄存器中页表的大小比较,确定访问的合法性。<br>&ensp;&ensp;&ensp;&ensp;3）如果访问合法，则以页号为索引去检索页表。得到该页的物理块号，将之装入物理地址寄存器中。<br>&ensp;&ensp;&ensp;&ensp;4）页内地址送入物理地址寄存器的块内地址字段中，完成从逻辑地址到物理地址的变换。<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8725.png">    </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 具有快表的地址变换机构</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;因页表放在主存中，故存取数据时CPU至少要访问两次主存。降低了内存访问速度。<br>&ensp;&ensp;&ensp;&ensp;（1）访页表,得到绝对地址<br>&ensp;&ensp;&ensp;&ensp;（2）访问内存内容<br>&ensp;&ensp;&ensp;&ensp;增设一个具有并行查找能力的特殊高速缓冲寄存器，又称“联想寄存器”，或称“快表”。用它存放当前访问过的那些页表项。有快表，速度提高。  </p>
<p>&ensp;&ensp;&ensp;&ensp;具有快表的地址变换过程如下：</p>
<ul>
<li>在CPU给出有效地址后，由地址变换机构自动地将页号送入快表中。</li>
<li>若快表中有此页号，则直接从快表中读出该页对应的物理块号，送到物理地址寄存器。否则，再访问内存中的页表，从页表项中读出物理块号送到地址寄存器，</li>
<li>同时，将此页表项放入快表中。若快表已满，OS找到一个被认为不再需要的表项，将它换出。<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8726.png">  </li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;（1）由于成本的原因，快表不可能做得很大，通常只能存放16~512个页表项。这对中、小型作业来说，已可能把全部页表项放入快表中；但对于大型作业来说，则只能将一部分页表放入快表中。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）由于对程序和数据的访问往往带有局限性，所以快表的命中率可以达到90%。这样，由于增加了地址变换机构的速度损失可以降低到10%以下。达到了可以接受的程度</p>
<h3 id="4-5-3-访问内存的有效时间"><a href="#4-5-3-访问内存的有效时间" class="headerlink" title="4.5.3 访问内存的有效时间"></a>4.5.3 访问内存的有效时间</h3><p>&ensp;&ensp;&ensp;&ensp;从进程发出指定逻辑地址的访问请求，到在内存中找到对应的实际物理地址单元并取出数据，所需花费的总时间，内存的有效访问时间(Effective Access Time EAT)。  </p>
<p>&ensp;&ensp;&ensp;&ensp;无快表的分页管理系统<br>&ensp;&ensp;&ensp;&ensp;EAT=t+t=2t</p>
<p>&ensp;&ensp;&ensp;&ensp;有快表的分页管理系统<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8727.png">  </p>
<p>（t为访问一次内存的时间，a为访问快表的命中率，λ为访问一次快表的时间）  </p>
<h3 id="4-5-4-两级页表和多级页表"><a href="#4-5-4-两级页表和多级页表" class="headerlink" title="4.5.4 两级页表和多级页表"></a>4.5.4 两级页表和多级页表</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 两级页表</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;现代计算机系统都支持非常大的逻辑地址空间，致使页表很大，用连续空间存放页表显然不现实。<br>&ensp;&ensp;&ensp;&ensp;如逻辑地址32位，页面大小4KB，则页表项为1M，若每个页表项占4字节，则页表共需要4MB的连续内存空间。<br>&ensp;&ensp;&ensp;&ensp;解决方案：<br>&ensp;&ensp;&ensp;&ensp;用离散方式存储页表<br>&ensp;&ensp;&ensp;&ensp;仅将当前需要的部分页表项放在内存，其余放在磁盘上，需要时调入（请求调入）。  </p>
<p>&ensp;&ensp;&ensp;&ensp;逻辑地址结构：<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8728.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;两级页表系统将32位逻辑地址空间的地址分成三段：其中，页表目录号和页号各占10位，页内地址d占12位。每页的大小为4KB。由于物理块号和页表的物理地址都占4个字节，使每页中包含1024个页表项，所以页表目录和页表页面的大小也都是4KB，即一页。<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8729.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;在地址变换机构中，增设一个外层页表寄存器，用于存放外层页表的始址。使用外层页号，作为外层页表的索引，从中找到指定页表分页的始址，再利用p2作为指定页表分页的索引，找到指定的页表项，其中有该页在内存的物理块号，用该块号和页内地址既可构成访问的内存物理地址。<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8730.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;上述对页表施行离散分配的方法，虽然解决了对于大页表无需大片连续存储空间的问题，但并未解决用较少的内存空间去存放大页表的问题。<br>&ensp;&ensp;&ensp;&ensp;能够用较少的内存空间存放页表的唯一方法是，仅把当前需要的一批页表项调入内存，以后再根据所需要陆续调入。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 多级页表</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;对两级页表进行扩充，便可得到三级、四级或更多级的页表。<br>&ensp;&ensp;&ensp;&ensp;多级页表的实现方式与两级页表类似。<br>&ensp;&ensp;&ensp;&ensp;64位机器页表一般&gt;3级，最外层页表常驻内存。  </p>
<h3 id="4-5-5-反置页表"><a href="#4-5-5-反置页表" class="headerlink" title="4.5.5 反置页表"></a>4.5.5 反置页表</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 多级页表</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;为了减少页表所占用的内存空间，引入了反置页表。<br>&ensp;&ensp;&ensp;&ensp;反置页表是为每一个物理块设置一个页表项，并将它们按物理块的编号排序，其中的内容则是页号和其所隶属进程的标识符。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 地址变换</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;根据进程标识符和页号，检索反置页表，如果检索到与之匹配的页表项，则该页表项的序号即为该页所在的物理块号。反之则说明该页尚未装入内存。<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8731.png"></p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>基本的分页存储管理优点</strong>：<br>&ensp;&ensp;&ensp;&ensp;1）没有外碎片，每个内碎片不超过页大小。<br>&ensp;&ensp;&ensp;&ensp;2）一个程序不必连续存放。<br>&ensp;&ensp;&ensp;&ensp;3）便于内存扩充，随着程序运行而动态生成的数据增多，地址空间可相应增长。<br>&ensp;&ensp;&ensp;&ensp;<strong>缺点</strong>：<br>&ensp;&ensp;&ensp;&ensp;程序需全部装入内存。  </p>
<h2 id="4-6-分段存储管理方式"><a href="#4-6-分段存储管理方式" class="headerlink" title="4.6 分段存储管理方式"></a>4.6 分段存储管理方式</h2><h3 id="4-6-1-分段存储管理方式的引入"><a href="#4-6-1-分段存储管理方式的引入" class="headerlink" title="4.6.1 分段存储管理方式的引入"></a>4.6.1 分段存储管理方式的引入</h3><p>&ensp;&ensp;&ensp;&ensp;段式存储方式的引入<br>&ensp;&ensp;&ensp;&ensp;1）分页通常不是一个完整的程序或数据逻辑段。<br>&ensp;&ensp;&ensp;&ensp;2）分区和页式管理只能采用静态链接，花费大量cpu时间。<br>&ensp;&ensp;&ensp;&ensp;3）用户的作业可以按逻辑上完整的段来划分。<br>&ensp;&ensp;&ensp;&ensp;4）段式存储管理利用动态链接的方式有效节省时间和空间。<br>&ensp;&ensp;&ensp;&ensp;故可以将用户作业地址空间,按逻辑意义分段，以段作为内外存交换的单位。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 方便编程</strong>  </p>
<p>若将逻辑地址分为段名和段内偏移量，则有：  </p>
<pre><code>LOAD 1, [A]|&lt;D&gt;
STORE 1, [B]|&lt;C&gt;
</code></pre>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 信息共享</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;在实现对程序和数据共享时，是以信息的逻辑单位为基础的。比如共享某个过程，函数或文件。而分页系统中的“页”只是存放信息的单位，并无完整的逻辑意义，因而实现共享比较困难。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 信息保护</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;信息保护是以信息的逻辑单位为基础的，而且通常是以一个过程，函数或文件为基本单位进行保护的。而在分页中，一个函数可能占用多个页，而第一页和最后一页还会装入其他内容。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4. 动态增长</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;实际应用中，有些段，尤其是数据段，在它们的使用过程中，会不断的增加，相应的所需存储空间也会动态增加。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>5. 动态链接</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在程序运行时，先将主程序和立即需要用到的目标程序装入内存，即启动运行。在程序运行过程中，需要调用某个目标程序时，才将该段调入内存并进行链接。  </p>
<p>&ensp;&ensp;&ensp;&ensp;作业的地址空间分为多段，每段都从0开始编址，故地址是二维的。<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8732.png">  </p>
<h3 id="4-6-2-分段系统的基本原理"><a href="#4-6-2-分段系统的基本原理" class="headerlink" title="4.6.2 分段系统的基本原理"></a>4.6.2 分段系统的基本原理</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 分段</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;分段系统的逻辑地址结构<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8733.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 段表</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在分段存储管理中，系统为每个分段分配一个连续的分区，进程的各个段可以离散地移入内存的不同分区中。  </p>
<p>&ensp;&ensp;&ensp;&ensp;每个进程建立一个段表，用来记录每段在内存的起始地址及相关信息。  </p>
<p>&ensp;&ensp;&ensp;&ensp;其中每个表项描述一个分段的信息，至少包含：<br>&ensp;&ensp;&ensp;&ensp;段号，段长，段在内存的起始地址，其他信息<br>&ensp;&ensp;&ensp;&ensp;段表一般存放在内存。<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8734.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 地址变换机构</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;为了实现从逻辑地址到物理地址的变换功能，系统中设置了段表寄存器，用于存放段表始址和段表长度。在进行地址变换时，系统将逻辑地址中的段号S与段表长度TL进行比较。  </p>
<ul>
<li>若 S≥TL，表示段号太大，访问越界，于是产生越界中断信号；  </li>
<li>若未越界，则根据段表的始址和该段的段号，计算出该段对应段表项的位置，从中读出该段在内存中的起始址。  </li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;然后再检查段内地址d是否超过该段的段长SL。  </p>
<ul>
<li>若超过，即 d≥SL，同样发出越界中断信号；</li>
<li>若未越界，则将该段的基址与段内地址d相加，得要访问的内存物理地址。<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8735.png">  </li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;和分页系统一样，当段表放在内存时，每访问一个数据，需要访问两次内存，从而降低了计算机的速率。解决的方法和分页类似，也增设一个联想存储器，用于保存最近的分段表项。一般，由于段比页大，因而段表项数据比页表项数目少，所需联想存储器相当较小，所以可以显著减少存取数据的时间。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4. 分页和分段的主要区别</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）页是信息的物理单位，段是信息的逻辑单位。<br>&ensp;&ensp;&ensp;&ensp;2）页大小是系统固定的，而段大小则通常不固定。<br>&ensp;&ensp;&ensp;&ensp;3）逻辑地址表示：<br>&ensp;&ensp;&ensp;&ensp;分页的程序地址空间是一维的，各个模块在链接时必须组织成同一个地址空间；<br>&ensp;&ensp;&ensp;&ensp;分段的程序地址空间是二维的，各个模块在链接时可以每个段组织成一个地址空间。  </p>
<h3 id="4-6-3-信息共享"><a href="#4-6-3-信息共享" class="headerlink" title="4.6.3 信息共享"></a>4.6.3 信息共享</h3><p>&ensp;&ensp;&ensp;&ensp;段是信息的逻辑单位,因此分段系统的一个突出的优点是易于实现段的共享。即允许若干个进程共享一个或多个段，而且对段的保护也十分简单。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 分页系统中对程序和数据的共享</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;在分页系统中，虽然也能实现对程序和数据的共享，但远不如分段系统来得方便。  </p>
<p>&ensp;&ensp;&ensp;&ensp;可重入代码：又称为“纯代码”(Pure Code),在实现共享时，需要用到可重入代码(Reentrant Code) 。它是一种允许多个进程同时访问的代码，是一种不允许任何进程对其进行修改的代码。<br>&ensp;&ensp;&ensp;&ensp;在每个进程中，配以局部数据区，将在执行中可能改变的部分，拷贝到该数据区，这样，程序在执行时，只对该数据区(属于该进程私有)中的内容进行修改，而不去改变共享的代码，这时的可共享代码即成为可重入代码。   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 分段系统中对程序和数据的共享</strong>  </p>
<p><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8736.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;在分页存储管理系统中，信息的共享是通过使多个进程页表项指向同一个物理块来实现的。<br>&ensp;&ensp;&ensp;&ensp;分段是信息的逻辑单位，因而实现共享比分页系统方便。  </p>
<p>&ensp;&ensp;&ensp;&ensp;分段保护方法有：  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>地址越界保护</strong>：段号与段表长度的比较，段内位移与段长的比较,利用界限寄存器。<br>&ensp;&ensp;&ensp;&ensp;<strong>存取控制保护</strong>：设置存取权限，访问段时判断访问类型与存取权限是否相符  </p>
<h3 id="4-6-4-段页式存储方式"><a href="#4-6-4-段页式存储方式" class="headerlink" title="4.6.4 段页式存储方式"></a>4.6.4 段页式存储方式</h3><p>&ensp;&ensp;&ensp;&ensp;分页优点：提高内存利用率<br>&ensp;&ensp;&ensp;&ensp;分段优点：方便用户，易共享保护，动态链接  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 段页式存储管理的引入</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;分页式存储管理对存储空间（内存）的利用率较高，但需要静态链接。<br>&ensp;&ensp;&ensp;&ensp;分段存储管理的分段须占用主存的连续区域，内存空间利用率不高，易产生碎片（外零头）。<br>&ensp;&ensp;&ensp;&ensp;段页式存储管理将分页管理和分段管理结合起来，发挥各自优点。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 基本原理</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;作业的地址空间首先被分成若干个逻辑分段，然后再将每一段分成若干个大小固定的页面，并为每个段赋予一个段名。<br>&ensp;&ensp;&ensp;&ensp;将主存空间分成若干个和页面大小相同的物理块，对主存的分配以物理块为单位。<br>&ensp;&ensp;&ensp;&ensp;逻辑地址结构：<br>&ensp;&ensp;&ensp;&ensp;V=(s,p,d)=(段号，页号，页内地址)  </p>
<p>&ensp;&ensp;&ensp;&ensp;作业的逻辑地址结构:<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8737.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;1、在段页式存储管理系统中，页表不再属于进程而是属于某个段，因此段表中应有专项指出该段对应页表的页表始地址和页表长度。  </p>
<p>&ensp;&ensp;&ensp;&ensp;2、段页式管理中、段表、页表及内存的关系如下图所示：为了实现地址变换，系统中需要设立段表及页表。<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8738.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;3、段表：每个作业一个段表，段表项为页表地址。<br>&ensp;&ensp;&ensp;&ensp;页表：每段一张页表，页表项为块号。<br>&ensp;&ensp;&ensp;&ensp;段表控制寄存器：存放正运行的作业的段表始址及大小。<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8739.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 地址变换过程</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;先将段号S与段表寄存器中的段表长度进行比较，若小于段表长度则表示未越界；<br>&ensp;&ensp;&ensp;&ensp;利用段表始址和段号求出该段对应段表项的位置，从中得到该段的页表始址；<br>&ensp;&ensp;&ensp;&ensp;再利用逻辑地址中的段内页号P获得对应页表项的位置，从中读出该页所在的物理块号，再与页内地址拼接成物理地址。<br><img src="/2021/05/10/os-4/%E5%9B%BE%E7%89%8740.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;在段页式系统中，为了获得一条指令或数据，需三次访问内存<br>&ensp;&ensp;&ensp;&ensp;第一次访问内存中的段表，从中取得页表始址；  </p>
<p>&ensp;&ensp;&ensp;&ensp;第二次访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理  地址；  </p>
<p>&ensp;&ensp;&ensp;&ensp;第三次访问是真正根据所得的物理地址取出指令或数据。  </p>
<p>&ensp;&ensp;&ensp;&ensp;显然，这使访问内存的次数增加了近两倍。为了提高执行的速度，在地址变换机构中增设一高速缓冲寄存器。每次访问它时，都同时利用段号和页号去检索高速缓存。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实验课作业三——银行家算法</title>
    <url>/2021/05/06/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&ensp;&ensp;&ensp;&ensp;用C语言模拟银行家算法。个人实验报告使用，如果想参考，不得保留原文40%以上，谢谢配合。</p>
<span id="more"></span>

<h1 id="一、实验目的及要求"><a href="#一、实验目的及要求" class="headerlink" title="一、实验目的及要求"></a>一、实验目的及要求</h1><ul>
<li><p>通过编写和调试一个系统动态分配资源的简单模拟程序；  </p>
</li>
<li><p>观察死锁产生的条件 ； </p>
</li>
<li><p>模拟死锁避免的实现  ；</p>
</li>
<li><p>加深对死锁避免 ；</p>
</li>
<li><p>系统安全状态的理解；  </p>
</li>
<li><p>体会和了解死锁以及避免死锁的具体实现方法。  </p>
</li>
</ul>
<h1 id="二、基本理论介绍"><a href="#二、基本理论介绍" class="headerlink" title="二、基本理论介绍"></a>二、基本理论介绍</h1><h2 id="2-1-银行家算法"><a href="#2-1-银行家算法" class="headerlink" title="2.1 银行家算法"></a>2.1 银行家算法</h2><p>&ensp;&ensp;&ensp;&ensp;银行家算法（Banker’s Algorithm）是一个避免死锁（Deadlock）的著名算法，是由艾兹格·迪杰斯特拉在1965年为T.H.E系统设计的一种避免死锁产生的算法。<br>&ensp;&ensp;&ensp;&ensp;它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。</p>
<h2 id="2-2-安全状态"><a href="#2-2-安全状态" class="headerlink" title="2.2 安全状态"></a>2.2 安全状态</h2><p>&ensp;&ensp;&ensp;&ensp;如果存在一个由系统中所有进程构成的安全序列P1，…，Pn，则系统处于安全状态。安全状态一定是没有死锁发生。</p>
<h2 id="2-3-不安全状态"><a href="#2-3-不安全状态" class="headerlink" title="2.3 不安全状态"></a>2.3 不安全状态</h2><p>&ensp;&ensp;&ensp;&ensp;不存在一个安全序列。不安全状态不一定导致死锁。</p>
<h2 id="2-4-银行家算法所涉及的数据结构"><a href="#2-4-银行家算法所涉及的数据结构" class="headerlink" title="2.4 银行家算法所涉及的数据结构"></a>2.4 银行家算法所涉及的数据结构</h2><h3 id="1）可利用资源向量Available"><a href="#1）可利用资源向量Available" class="headerlink" title="1）可利用资源向量Available"></a>1）可利用资源向量Available</h3><p>&ensp;&ensp;&ensp;&ensp;是个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果Available[j]=K，则表示系统中现有Rj类资源K个。</p>
<h3 id="2）最大需求矩阵Max"><a href="#2）最大需求矩阵Max" class="headerlink" title="2）最大需求矩阵Max"></a>2）最大需求矩阵Max</h3><p>&ensp;&ensp;&ensp;&ensp;这是一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K，则表示进程i需要Rj类资源的最大数目为K。</p>
<h3 id="3）分配矩阵Allocation"><a href="#3）分配矩阵Allocation" class="headerlink" title="3）分配矩阵Allocation"></a>3）分配矩阵Allocation</h3><p>&ensp;&ensp;&ensp;&ensp;这也是一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得Rj类资源的 数目为K。</p>
<h3 id="4）需求矩阵Need。"><a href="#4）需求矩阵Need。" class="headerlink" title="4）需求矩阵Need。"></a>4）需求矩阵Need。</h3><p>&ensp;&ensp;&ensp;&ensp;这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K，则表示进程i还需要Rj类资源K个，方能完成其任务。<br>Need[i,j]=Max[i,j]-Allocation[i,j]</p>
<h1 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h1><ol>
<li>设计进程管理数据结构</li>
<li>输入系统资源当前的使用情况，如：系统当前的进程数、各进程的资源信息等</li>
<li>设计安全性检查算法检查系统状态是否安全</li>
<li>动态申请资源，设计银行家算法，在银行家算法中调用安全性检查算法，判断本次申请是否能够满足，进行资源分配</li>
<li>输出每次分配后的安全序列，及系统当前资源分配信息</li>
</ol>
<h1 id="四、功能实现"><a href="#四、功能实现" class="headerlink" title="四、功能实现"></a>四、功能实现</h1><h2 id="4-1-银行家算法实现"><a href="#4-1-银行家算法实现" class="headerlink" title="4.1 银行家算法实现"></a>4.1 银行家算法实现</h2><p>&ensp;&ensp;&ensp;&ensp;在避免死锁的方法中，所施加的限制条件较弱，有可能获得令人满意的系统性能。在该方法中把系统的状态分为安全状态和不安全状态，只要能使系统始终都处于安全状态，便可以避免发生死锁。<br>&ensp;&ensp;&ensp;&ensp;银行家算法的基本思想是分配资源之前，判断系统是否是安全的；若是，才分配。它是最具有代表性的避免死锁的算法。<br>&ensp;&ensp;&ensp;&ensp;设进程cusneed提出请求REQUEST [i]，则银行家算法按如下规则进行判断。<br>&ensp;&ensp;&ensp;&ensp;(1)如果REQUEST [cusneed] [i]&lt;= NEED[cusneed][i]，则转(2)；否则，出错。<br>&ensp;&ensp;&ensp;&ensp;(2)如果REQUEST [cusneed] [i]&lt;= AVAILABLE[i]，则转(3)；否则，等待。<br>&ensp;&ensp;&ensp;&ensp;(3)系统试探分配资源，修改相关数据：<br>&ensp;&ensp;&ensp;&ensp;AVAILABLE[i]-=REQUEST[cusneed][i];<br>&ensp;&ensp;&ensp;&ensp;ALLOCATION[cusneed][i]+=REQUEST[cusneed][i];<br>&ensp;&ensp;&ensp;&ensp;NEED[cusneed][i]-=REQUEST[cusneed][i];<br>&ensp;&ensp;&ensp;&ensp;(4)系统执行安全性检查，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待。  </p>
<h2 id="4-2-安全性检查算法"><a href="#4-2-安全性检查算法" class="headerlink" title="4.2 安全性检查算法"></a>4.2 安全性检查算法</h2><p>&ensp;&ensp;&ensp;&ensp;(1)设置两个工作向量Work=AVAILABLE;FINISH<br>&ensp;&ensp;&ensp;&ensp;(2)从进程集合中找到一个满足下述条件的进程，<br>&ensp;&ensp;&ensp;&ensp;FINISH==false;<br>&ensp;&ensp;&ensp;&ensp;NEED&lt;=Work;<br>&ensp;&ensp;&ensp;&ensp;如找到，执行（3)；否则，执行（4)<br>&ensp;&ensp;&ensp;&ensp;(3)设进程获得资源，可顺利执行，直至完成，从而释放资源。<br>&ensp;&ensp;&ensp;&ensp;Work=Work+ALLOCATION;<br>&ensp;&ensp;&ensp;&ensp;Finish=true;<br>&ensp;&ensp;&ensp;&ensp;转到（2）<br>&ensp;&ensp;&ensp;&ensp;(4)如所有的进程Finish= true，则表示安全；否则系统不安全。  </p>
<h2 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> processNum 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> resourceNum 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXINT 9999</span></span><br><span class="line"><span class="keyword">int</span> avaliable[resourceNum] = &#123; <span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> max[processNum][resourceNum] = &#123;<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> allocation[processNum][resourceNum] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> need[processNum][resourceNum] = &#123;<span class="number">7</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> finish[processNum];</span><br><span class="line"><span class="keyword">int</span> request[resourceNum];</span><br><span class="line"><span class="keyword">int</span> safeSeries[processNum] = &#123; MAXINT, MAXINT , MAXINT , MAXINT , MAXINT &#125;;</span><br><span class="line"><span class="comment">//int processNum, resourceNum;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入进程和资源数量，用空格分开\n&quot;</span>);</span><br><span class="line">	<span class="comment">//scanf(&quot;%d%d&quot;, &amp;processNum, &amp;resourceNum);</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入当前可用资源数\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; resourceNum; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;avaliable[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入最大需求矩阵\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; processNum; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;max[i][j]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入分配矩阵\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; processNum; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;allocation[i][j]);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; processNum; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++)</span><br><span class="line">			need[i][j] = max[i][j] - allocation[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;当前资源剩余:&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, avaliable[j]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;进程名\t Max\t \tAllocation\tNeed\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; processNum; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; P%d\t&quot;</span>, i);</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, max[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\t\t&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, allocation[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\t\t&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, need[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Safeinfo</span><span class="params">(<span class="keyword">int</span>* work, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isSafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> truefinished = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> work[resourceNum];</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; resourceNum; i++)</span><br><span class="line">		work[i] = avaliable[i];</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; processNum; i++)</span><br><span class="line">		finish[i] = <span class="literal">false</span>;</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> temp0;</span><br><span class="line">	<span class="keyword">while</span> (truefinished != processNum) &#123;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (finish[i] != <span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++)</span><br><span class="line">				<span class="keyword">if</span> (need[i][j] &gt; work[j]) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (j == resourceNum) &#123;</span><br><span class="line">			finish[i] = <span class="literal">true</span>;</span><br><span class="line">			<span class="built_in">Safeinfo</span>(work, i);</span><br><span class="line">			<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; resourceNum; k++) &#123;</span><br><span class="line">				work[k] += allocation[i][k];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> k2;</span><br><span class="line">			safeSeries[truefinished++] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= processNum) &#123;</span><br><span class="line">			<span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">				temp = truefinished;</span><br><span class="line">				temp0 = truefinished;</span><br><span class="line">			&#125;</span><br><span class="line">			i = i % processNum;</span><br><span class="line">			<span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">				temp = truefinished;</span><br><span class="line">				<span class="keyword">if</span> (temp == temp0)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					temp0 = temp;</span><br><span class="line">			&#125;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = truefinished;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (truefinished == processNum) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n系统安全,\n\n安全序列为：&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; processNum; i++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, safeSeries[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;******系统不安全******\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Safeinfo</span><span class="params">(<span class="keyword">int</span>* work, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; P%d\t&quot;</span>, i);</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, work[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\t&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, need[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t &quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, allocation[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\t&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, allocation[i][j] + work[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, curProcess;</span><br><span class="line">	<span class="keyword">int</span> wheInit = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (wheInit)</span><br><span class="line">		<span class="comment">//Init();</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;---------------------------------------------------------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">showin</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n系统安全情况分析\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; PID\t Work\t\tNeed\tAllocation\tWork+Allocation\n&quot;</span>);</span><br><span class="line">	<span class="built_in">isSafe</span>();</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n---------------------------------------------------------\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n输入要分配的进程：&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;curProcess);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n输入要分配给进程P%d的资源：&quot;</span>, curProcess);</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;request[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (request[j] &lt;= need[curProcess][j])<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;ERROR！\n&quot;</span>); <span class="keyword">break</span>; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (j == resourceNum) &#123;</span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (request[j] &lt;= need[curProcess][j])<span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;资源不足，等待中！\n&quot;</span>); <span class="keyword">break</span>; &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (j == resourceNum) &#123;</span><br><span class="line">				<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">					avaliable[j] -= request[j];</span><br><span class="line">					allocation[curProcess][j] += request[j];</span><br><span class="line">					need[curProcess][j] -= request[j];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;\n系统安全情况分析\n&quot;</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot; PID\t Work\t\tNeed\tAllocation\tWork+Allocation\n&quot;</span>);</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">isSafe</span>()) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;分配成功！\n&quot;</span>);</span><br><span class="line">					<span class="built_in">showin</span>();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; resourceNum; j++) &#123;</span><br><span class="line">						avaliable[j] += request[j];</span><br><span class="line">						allocation[curProcess][j] -= request[j];</span><br><span class="line">						need[curProcess][j] += request[j];</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;分配失败！\n&quot;</span>);</span><br><span class="line">					<span class="built_in">showin</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、结果测试与分析"><a href="#五、结果测试与分析" class="headerlink" title="五、结果测试与分析"></a>五、结果测试与分析</h1><p>&ensp;&ensp;&ensp;&ensp;以下为部分运行结果截图：</p>
<p><img src="/2021/05/06/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/%E5%88%86%E9%85%8D%E6%88%90%E5%8A%9F.png" alt="分配成功"><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;图1 分配成功<br><img src="/2021/05/06/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/%E5%88%86%E9%85%8D%E5%A4%B1%E8%B4%A5.png" alt="分配失败"><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;图2 分配失败   </p>
<p>&ensp;&ensp;&ensp;&ensp;分析略</p>
<h1 id="六、心得体会"><a href="#六、心得体会" class="headerlink" title="六、心得体会"></a>六、心得体会</h1><p>&ensp;&ensp;&ensp;&ensp;以上文字和代码仅供参考，请勿直接复制用于完成作业。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>实验课作业</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记——第二章（绝赞完结）</title>
    <url>/2021/05/08/os-2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>个人操作系统笔记整理，欢迎参考，时不时更新。  </p>
<span id="more"></span>

<h1 id="第二章-进程管理"><a href="#第二章-进程管理" class="headerlink" title="第二章 进程管理"></a>第二章 进程管理</h1><h2 id="2-1-前趋图和程序执行"><a href="#2-1-前趋图和程序执行" class="headerlink" title="2.1 前趋图和程序执行"></a>2.1 前趋图和程序执行</h2><h3 id="2-1-1-前趋图"><a href="#2-1-1-前趋图" class="headerlink" title="2.1.1 前趋图"></a>2.1.1 前趋图</h3><p>&ensp;&ensp;&ensp;&ensp;前趋图定义<br>&ensp;&ensp;&ensp;&ensp;定义：前趋图是一个有向无循环图,记为 DAG(Directed Acyclic Graph) ，用于描述进程之间执行的前后顺序。<br>&ensp;&ensp;&ensp;&ensp;表示方式：<br>&ensp;&ensp;&ensp;&ensp;（1）p1–&gt;p2<br>&ensp;&ensp;&ensp;&ensp;（2）–&gt;={(p1,p2)| p1 必须在p2开始前完成}<br>&ensp;&ensp;&ensp;&ensp;节点表示：一条语句，一个程序段，一个进程，节点上的权重表示该进程的程序量或执行时间。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%871.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;下图就不是前趋图，<strong>前趋图中不应出现循环</strong><br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%872.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;因为存在前趋关系: S2→S3 和 S3 →S2  </p>
<h3 id="2-1-2-程序的顺序执行及其特征"><a href="#2-1-2-程序的顺序执行及其特征" class="headerlink" title="2.1.2 程序的顺序执行及其特征"></a>2.1.2 程序的顺序执行及其特征</h3><p>&ensp;&ensp;&ensp;&ensp;单道程序环境下，程序段执行有固定的时序，仅当前一操作完成后，才能执行后继操作。<br>&ensp;&ensp;&ensp;&ensp;例如，进行计算时，总需要首先输入数据，然后进行计算，最后才能打印计算结果。假如用I表示输入，C表示计算，P表示打印，并且用箭头表示操作的先后次序。则输入数据，计算数据，打印计算结果这样一段程序。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%873.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;对于程序段中的多条语句来说，也有一个执行顺序问题，如对于包含下述三条语句的程序段：<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%874.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;一切顺序执行的程序都具有下列特性：<br>&ensp;&ensp;&ensp;&ensp;（1）顺序性。即每一操作都必须在上一个操作结束之后开始。<br>&ensp;&ensp;&ensp;&ensp;（2）封闭性。程序运行时独占全机资源；资源的状态（除初始状态外）只有本程序才能改变它。程序一旦开始运行，其执行结果不受外界因素影响。<br>&ensp;&ensp;&ensp;&ensp;（3）可再现性。只要执行时的环境和初始条件相同，程序不论是连续执行还是“走走停停”地执行，都将获得相同的结果。  </p>
<h3 id="2-1-3-程序的并发执行及其特征"><a href="#2-1-3-程序的并发执行及其特征" class="headerlink" title="2.1.3 程序的并发执行及其特征"></a>2.1.3 程序的并发执行及其特征</h3><p>&ensp;&ensp;&ensp;&ensp;程序的两种执行方式：顺序执行、并发执行。<br>&ensp;&ensp;&ensp;&ensp;现在的操作系统多为并发执行（多道处理系统），具有许多新的特征。<br>&ensp;&ensp;&ensp;&ensp;引入并发执行的目的是为了<strong>提高资源利用率</strong>。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>并发</strong>与<strong>并行</strong>概念的区别：<br>&ensp;&ensp;&ensp;&ensp;concurrency,parallel</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.程序的并发执行</strong><br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%875.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;该例中存在下述前趋关系：<br>&ensp;&ensp;&ensp;&ensp;Ii→Ci ，Ii→Ii+1 ， Ci→Pi， Ci→Ci+1， Pi→Pi+1<br>&ensp;&ensp;&ensp;&ensp;而Ii+1和Ci及Pi-1是重迭的，亦即Ii+1和Ci及Pi-1可以并发执行。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.并发程序的特征</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）间断性：进程“时走时停”<br>&ensp;&ensp;&ensp;&ensp;（2）非封闭性：多个程序共享资源<br>&ensp;&ensp;&ensp;&ensp;（3）不可再现性：由于失去了封闭性，也失去了可在现性  </p>
<p>&ensp;&ensp;&ensp;&ensp;例：有2个循环程序A和B，它们共享变量N；<br>&ensp;&ensp;&ensp;&ensp;程序A：N=N+1；程序B: Print(N)；N=0<br>&ensp;&ensp;&ensp;&ensp;若程序A,B以不同的速度运行有以下三种不同的结果（假定某时刻变量Ｎ的值为ｎ）  </p>
<p>&ensp;&ensp;&ensp;&ensp;N:=N+1在Print(N)和N=0之前，得到的N值分别为：n+1, n+1, 0<br>&ensp;&ensp;&ensp;&ensp;N:=N+1在Print(N)和N=0之后，得到的N值分别为：n, 0, 1<br>&ensp;&ensp;&ensp;&ensp;N:=N+1在Print(N)和N=0之间，得到的N值分别为：n, n+1, 0  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.顺序执行与并发执行特征对比</strong><br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%876.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;程序的并发执行引发的问题  </p>
<ul>
<li>如何协调各程序的执行顺序？</li>
<li>多个执行程序共享系统资源，程序之间可能会相互影响，甚至影响输出结果。</li>
<li>选择哪些、多少个程序进入内存执行？</li>
<li>内存中的执行程序谁先执行？</li>
<li>内存如何有效分配？           </li>
</ul>
<h2 id="2-2-进程的描述"><a href="#2-2-进程的描述" class="headerlink" title="2.2 进程的描述"></a>2.2 进程的描述</h2><h3 id="2-2-1-进程的定义和特征"><a href="#2-2-1-进程的定义和特征" class="headerlink" title="2.2.1 进程的定义和特征"></a>2.2.1 进程的定义和特征</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.进程的定义</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;通常的<strong>程序</strong>不能参与并发执行，为了让程序能并发执行，人们引入<strong>进程</strong>的概念对并发执行的程序加以描述和控制。<br>&ensp;&ensp;&ensp;&ensp;比较典型的进程定义有：<br>&ensp;&ensp;&ensp;&ensp;⑴进程是程序的一次执行。<br>&ensp;&ensp;&ensp;&ensp;⑵进程是一个程序及其数据在处理机上顺序执行时所发生的活动。<br>&ensp;&ensp;&ensp;&ensp;⑶进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。<br>&ensp;&ensp;&ensp;&ensp;本教材定义进程为：<strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</strong><br>&ensp;&ensp;&ensp;&ensp;资源分配：获得除了处理机以外的资源<br>&ensp;&ensp;&ensp;&ensp;资源调度：获得处理机资源  </p>
<p>&ensp;&ensp;&ensp;&ensp;进程与程序<br>&ensp;&ensp;&ensp;&ensp;程序：静态概念，是指令和数据的集合，可长期存储。<br>&ensp;&ensp;&ensp;&ensp;进程与程序对应关系：<br>&ensp;&ensp;&ensp;&ensp;一个程序可以对应一个进程或多个进程。<br>&ensp;&ensp;&ensp;&ensp;一个进程可以对应一个程序，或者一段程序。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%877.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;引入进程带来的问题<br>&ensp;&ensp;&ensp;&ensp;1）增加了空间开销：为进程建立数据结构<br>&ensp;&ensp;&ensp;&ensp;2）额外的时间开销：管理和协调、跟踪、填写和更新有关数据结构、切换进程、保护现场。<br>&ensp;&ensp;&ensp;&ensp;3）更难控制：<br>&ensp;&ensp;&ensp;&ensp;①协调多个进程竞争和共享资源。<br>&ensp;&ensp;&ensp;&ensp;②预防解决多个进程因为竞争资源而出现故障。<br>&ensp;&ensp;&ensp;&ensp;③处理机的竞争尤为突出。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.进程的特征</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）动态性：动态性是进程的最基本特征。表现在，进程由创建而产生，由调度而执行，由撤销而消亡。即进程具有一定的生命周期。（而程序是静态的）。<br>&ensp;&ensp;&ensp;&ensp;2）独立性：各进程的地址空间相互独立，互不干扰。<br>&ensp;&ensp;&ensp;&ensp;3）并发性：指多个进程实体同存于内存中，且能在一段时间内同时运行。并发性是进程的重要特征。<br>&ensp;&ensp;&ensp;&ensp;4）异步性：指进程按各自独立的、不可预知的速度向前推进  </p>
<p>&ensp;&ensp;&ensp;其它：<br>&ensp;&ensp;&ensp;&ensp;1）为使程序能独立运行，为之配置一进程控制块，即PCB（Process Control Block)。<br>&ensp;&ensp;&ensp;&ensp;2）进程是一个动态的实体，随着程序中指令的执行而不断地变化。在某个时刻进程的内容被称为进程映像。<br>&ensp;&ensp;&ensp;&ensp;3）进程由程序段、相关数据段和PCB三部分构成。  </p>
<h3 id="2-2-2-进程的基本状态及其转换"><a href="#2-2-2-进程的基本状态及其转换" class="headerlink" title="2.2.2 进程的基本状态及其转换"></a>2.2.2 进程的基本状态及其转换</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.进程的三种基本状态</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）就绪状态：进程已分配到除CPU以外的所有必要资源，只要获得CPU，便可立即执行，此时的状态称为就绪状态。一个系统中处于就绪状态的进程有多个，通常排成一个就绪队列。<br>&ensp;&ensp;&ensp;&ensp;2）执行状态：进程已获得CPU，其程序正在执行。单处理机系统中，只有一个进程在执行；多处理机系统中，可以是多个进程在同时执行。<br>&ensp;&ensp;&ensp;&ensp;3）阻塞状态：正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，这种状态称为阻塞状态（等待状态或封锁状态）。处于阻塞状态的进程也可排成队列。导致进程阻塞的事件有：请求I/O，申请缓冲空间等。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.三种基本状态的转换</strong> </p>
<p>&ensp;&ensp;&ensp;&ensp;进程在运行过程中灰经常发生状态的转换。例如，处于就绪状态的进程，在调度程序为之分配了处理及之后便可执行，相应地，其状态就由就绪态转变为执行态；正在执行的进程如果因分配给它的时间片已完而被剥夺处理机暂停执行时，其状态便由执行态转为就绪；如果因发生某事件，致使当前进程的执行受阻（如进程访问某临界资源，而该资源正在被其它进程访问时），则该进程状态将由执行变为阻塞。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%878.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.进程的创建状态和终止状态</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）创建状态  </p>
<p>&ensp;&ensp;&ensp;&ensp;创建过程一般包括多个步骤：①首先，为一个新进程创建PCB，并填写必要的管理信息；②然后为该进程分配运行时必须的资源；③最后把该进程转让就绪状态并插入就绪队列中。当新进程被创建时，如果该进程所必需的资源或其它信息，如主存资源尚未分配等。此时，<strong>进程已拥有了自己的PCB，但进程自身还未进入主存</strong>，即创建工作尚未完成，进程还不能被调度运行。<strong>该状态即为创建状态</strong>。  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）终止状态<br>&ensp;&ensp;&ensp;&ensp;进程的终止包含两个步骤：①首先，等待操作系统进行善后处理，②然后将其PCB清零，并将PCB空间返还系统。<br>&ensp;&ensp;&ensp;&ensp;如果进程到达了自然结束点，或出现了无法克服的错误，或被操作系统所终结，或是被其他有终止权的进程所终结，将进入终止状态。<br>&ensp;&ensp;&ensp;&ensp;虽然进入终止状态的进程不能再执行，但是在操作系统中依然保留一个记录，其中保持状态码和一些计时统计数据，供其他进程收集。一旦其他进程完成了对终止状态进程的信息提取之后，操作系统将删除该进程。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%879.png">   </p>
<h3 id="2-2-3-挂起操作和进程状态的转换"><a href="#2-2-3-挂起操作和进程状态的转换" class="headerlink" title="2.2.3 挂起操作和进程状态的转换"></a>2.2.3 挂起操作和进程状态的转换</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.挂起操作的引入</strong>  </p>
<p>挂起：当该操作作用于某个进程时，该进程将被挂起，意味着此时此刻该进程处于静止状态。如果进程正在执行。它将暂停执行。若原本处于就绪状态，则该进程此时暂不接受调度。与挂起操作相对应的操作是激活操作。<br>&ensp;&ensp;&ensp;&ensp;引入挂起操作的原因：  </p>
<ul>
<li>终端用户的请求：终端用户在自己的程序运行期间发现有可疑问题时，希望暂时使自己的程序静止下来。这种静止状态就是挂起状态。</li>
<li>父进程请求：父进程要求挂起自己的子进程，以便考查和修改；</li>
<li>负荷调节的需要：实时系统中负荷较重时，系统会把一些不重要的进程挂起；</li>
<li>操作系统的需要：操作系统希望挂起一些进程，以便检查运行中的资源使用情况。</li>
</ul>
<p>&ensp;&ensp;&ensp;&ensp;挂起（Suspend）：把一个进程从内存转到外存；<br>&ensp;&ensp;&ensp;&ensp;激活（Activate）：把一个进程从外存转到内存；  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.引入挂起原语操作后三个进程状态的转换</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;活动就绪：进程在主存中并可以执行<br>&ensp;&ensp;&ensp;&ensp;活动阻塞：进程在主存中并等待一个事件<br>&ensp;&ensp;&ensp;&ensp;静止就绪：进程在辅存中，只要被载入主存就可以执行<br>&ensp;&ensp;&ensp;&ensp;静止阻塞：进程在辅存中并等待一个事件  </p>
<p>&ensp;&ensp;&ensp;&ensp;进程状态的转换<br>&ensp;&ensp;&ensp;&ensp;活动就绪 -&gt; 静止就绪<br>&ensp;&ensp;&ensp;&ensp;活动阻塞 -&gt; 静止阻塞<br>&ensp;&ensp;&ensp;&ensp;静止就绪 -&gt; 活动就绪<br>&ensp;&ensp;&ensp;&ensp;静止阻塞 -&gt; 活动阻塞<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8710.png">    </p>
<p><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8711.png">  </p>
<h3 id="2-2-4-进程管理中的数据结构"><a href="#2-2-4-进程管理中的数据结构" class="headerlink" title="2.2.4 进程管理中的数据结构"></a>2.2.4 进程管理中的数据结构</h3><p>&ensp;&ensp;&ensp;&ensp;一方面为了<strong>便于管理计算机资源，OS将它们抽象为各种数据结构</strong>，以及提供一组对资源进行<strong>操作</strong>的命令，用户可以通过这些数据结构和命令来执行相关操作。<br>&ensp;&ensp;&ensp;&ensp;另一方面，OS作为计算机资源的管理者，为了协调用户共享资源，它还<strong>需记录和查询各种资源的使用以及各类进程的运行情况信息。</strong>OS对于这些信息的组织和维护也是通过建立和维护各种数据结构的方式实现的。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.操作系统中用于管理控制的数据结构</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;计算机系统对每个资源和进程都设置了一个数据结构，称之为资源信息表或进程信息表，其中包含了资源或进程的标识，描述，状态等信息以及一批指针。<br>&ensp;&ensp;&ensp;&ensp;OS管理的这些数据结构一般可分为四类：内存表，设备表、文件表和进程表，其中进程表又称作进程控制块PCB。本章着重介绍PCB。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.进程控制块PCB的作用</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）<strong>作为独立运行的基本单位的标志。</strong>当一个程序配置了PCB后，就表示它是一个能在多道环境下独立运行的基本单位。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）<strong>能实现间断性运行方式。</strong>当程序阻塞时，保存现场，进程被再度调用时恢复现场。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（3）<strong>提供进程管理所需要的信息。</strong>在进程的整个生命周期，OS根据PCB实施对进程的控制和管理。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（4）<strong>提供进程调度所需要的信息。</strong>PCB提供了进程处于何种状态的信息，供进程调度使用。   </p>
<p>&ensp;&ensp;&ensp;&ensp;（5）<strong>实现与其它进程的同步与通信。</strong>PCB中具有用于实现进程同步的信号量和进程通信的区域或通信队列指针。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.进程管理块中的信息</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;（1）进程标识符。用于唯一的标识一个进程。<br>&ensp;&ensp;&ensp;&ensp;内部标识符：方便系统对进程的使用。在所有的操作系统中，都为每一个进程赋予一个唯一的数字标识符，它通常是一个进程的序号。<br>&ensp;&ensp;&ensp;&ensp;外部标识符：方便用户对进程的访问。由创建者提供，通常由字母数字组成。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（2）处理机状态信息。主要是由处理机的各种寄存器中的内容组成的。 处理机运行时，许多信息都存放在寄存器中。当处理机被中断时，所有这些信息都必须保存在PCB中，以便该进程重新执行时，能从断点继续执行。这些寄存器包括：①<strong>通用寄存器</strong>：用户可视寄存器，用于暂存信息，用户程序可以访问（8-32）②<strong>指令计数器</strong>：存放了要访问的下一条指令的地址；③<strong>程序状态字PSW</strong>:  其中包含了状态信息，如条件码、执行方式、终端屏蔽标志等；④<strong>用户栈指针</strong>：每个用户进程都有一个或若干个与之相关的系统栈，用于存放过程和系统调用参数及调用地址。栈指针指向栈顶。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（3）进程调度信息。在PCB中还存放一些与进程调度的信息，包括：①<strong>进程状态</strong>：指明进程的当前状态，作为进程调度和对换时的依据；②<strong>进程优先级</strong>：优先级高的进程应先获得处理机③<strong>进程调度所需的其它信息</strong>：与所采用的进程调度算法有关，比如，进程已等待CPU的时间总和、进程已执行的时间总和等；④<strong>事件</strong>：即阻塞原因，指进程由执行状态转变为阻塞状态所等待发生的事件。  </p>
<p>&ensp;&ensp;&ensp;&ensp;（4）进程控制信息。①<strong>程序和数据的地址</strong>: 指进程的程序和数据所在的内存或外存地址，以便再调度到该程序执行时，能从PCB中找到其程序和数据；②<strong>进程同步和通信机制</strong>:指实现进程同步和通信必需的机制，如消息队列指针、信号量等；③<strong>资源清单</strong>：是一张列出了使用CPU以外的、进程所需的全部资源及已经分配到该进程的资源的清单；④<strong>链接指针</strong>：它给出了本进程（PCB）所在队列中的下一个进程的PCB的首地址。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.进程控制块的组织方式</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;为了能对系统中多个PCB有效的管理，应该用适当的方式将这些PCB组织起来。目前常用的方式有三种：  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）线性方式，即将所有的PCB组织在一张线性表中，将该表的首地址放在内存的一个专用区域中。<br>&ensp;&ensp;&ensp;&ensp;（2）链接方式，把具有相同状态进程的PCB链接成一个队列，诸如就绪队列，阻塞队列等。<br>&ensp;&ensp;&ensp;&ensp;（3）索引方式，根据所有进程状态的不同，建立几张索引表，例如就绪索引表，阻塞索引表等，并把各个索引表在内存的首地址记录在内存的一些专用单元中。在每个索引表的表项中，记录具有相应状态的某个PCB在PCB表中的地址。</p>
<h2 id="2-3-进程控制"><a href="#2-3-进程控制" class="headerlink" title="2.3 进程控制"></a>2.3 进程控制</h2><p>&ensp;&ensp;&ensp;&ensp;进程控制是进程管理中最基本的功能。它用于创建一个新进程，终止一个进程，还有负责进程运行中的状态转换。进程控制一般由OS的内核来完成。<br>&ensp;&ensp;&ensp;&ensp;进程控制一般由OS的内核中的原语来实现。<br>&ensp;&ensp;&ensp;&ensp;原语（Primitive）：是由若干条指令组成的，用于完成一定功能的一个过程。它是原子操作（Action Operation），指一个操作中的所有动作要么全做，要么全不做。是一个不可分割的基本单位，执行过程中不允许中断。原子操作需要常驻内存。  </p>
<h3 id="2-3-1-操作系统内核"><a href="#2-3-1-操作系统内核" class="headerlink" title="2.3.1 操作系统内核"></a>2.3.1 操作系统内核</h3><p>&ensp;&ensp;&ensp;&ensp;现代操作系统一般分为若干层次，通常将与硬件关系紧密的模块，各种常用设备的驱动以及运行频率较高的模块安排在紧靠硬件的软件层次中，将它们常驻内存，即所谓的OS内核。<br>&ensp;&ensp;&ensp;&ensp;安排原因：<br>&ensp;&ensp;&ensp;&ensp;对这些软件进行保护，防止遭受其它应用程序的破坏<br>&ensp;&ensp;&ensp;&ensp;可以提高OS的运行效率  </p>
<p>&ensp;&ensp;&ensp;&ensp;对应内核，处理机的执行状态分为系统态和用户态。<br>&ensp;&ensp;&ensp;&ensp;系统态：又称为管态，也称为内核态。它具有较高的特权，能执行一切指令，访问所有寄存器和存储区，传统的OS都在系统态运行。<br>&ensp;&ensp;&ensp;&ensp;用户态：又称为目态。它具有较低的特权，仅能执行规定的指令，访问指定的寄存器和存储区。<br>&ensp;&ensp;&ensp;&ensp;一般情况下，应用程序只能在<strong>用户态</strong>运行。  </p>
<p>&ensp;&ensp;&ensp;&ensp;OS内核功能：<br>&ensp;&ensp;&ensp;&ensp;1）支撑功能：提供给OS其它众多模块所需的一些基本功能，以便支撑这些模块工作。三种最基本的支撑功能是：①中断处理，②时钟管理和③原语操作。<br>&ensp;&ensp;&ensp;&ensp;2）资源管理功能：包含①进程管理，存储器管理和设备管理。  </p>
<h3 id="2-3-2-进程的创建"><a href="#2-3-2-进程的创建" class="headerlink" title="2.3.2 进程的创建"></a>2.3.2 进程的创建</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.进程的层次结构</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;在OS中，允许一个进程创建子进程，通常把创建进程的进程称为父进程，而被创建的进程称为子进程。子进程可以继续创建更多的孙进程，由此形成进程的层次结构。（Unix系统）<br>&ensp;&ensp;&ensp;&ensp;在windows中不存在进程的层次结构概念，所有的进程具有相同地位。一个进程创建另外进程时获得了一个句柄用来控制被创建的进程。但句柄是可以传递的。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.进程图</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;进程图：进程图是一个有向树，用来描述进程的家族关系<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8712.png"><br>&ensp;&ensp;&ensp;&ensp;子进程可继承父进程所分配到的资源；<br>&ensp;&ensp;&ensp;&ensp;子进程运行完毕后，将资源归还给父进程；<br>&ensp;&ensp;&ensp;&ensp;撤销父进程时，其所有的子进程也随之撤销。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.引起进程创建的事件</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）用户登录 在分时系统中，用户在终端键入登录命令后，如果是合法用户，系统将为该终端建立一个进程，并把它插入到就绪队列中。  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）作业调度 在批处理系统中，当作业调度程序按一定的算法调度到某作业时，便将该作业装入内存，为它分配必要的资源，并立即为它创建进程，再插入到就绪队列中。  </p>
<p>&ensp;&ensp;&ensp;&ensp;3）提供服务 当运行中的用户程序提出某种请求后，系统将专门创建一个进程来提供用户所需要的服务。例如，运行过程中要求打印，系统会创建一个打印进程与该用户进程并发执行。  </p>
<p>&ensp;&ensp;&ensp;&ensp;4）应用请求 指的是基于应用程序的需求，为它创建一个新进程，以便使新进程以并发运行方式完成特定任务。通过这种方式可以使得几个操作并发执行，以加速任务的完成。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.进程创建</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;一旦操作系统发现了要求创建进程的事件后，便调用进程创建原语Creat( )来创建进程。进程的创建需要经历以下步骤：<br>&ensp;&ensp;&ensp;&ensp;①申请空白PCB：为新进程分配一个唯一的进程ID,并申请一个空白的PCB。<br>&ensp;&ensp;&ensp;&ensp;②为新进程分配资源：为进程的程序代码、数据用户栈分配内存空间。<br>&ensp;&ensp;&ensp;&ensp;③初始化进程控制块：<br>&ensp;&ensp;&ensp;&ensp;（1）初始化标识信息，将系统分配的进程ID、父进程ID写入PCB。<br>&ensp;&ensp;&ensp;&ensp;（2）初始化处理机状态信息，将程序计数器指向程序的入口地址、栈指针指向栈顶。<br>&ensp;&ensp;&ensp;&ensp;（3）初始化处理机控制信息，设置进程状态、优先级等。  </p>
<p>&ensp;&ensp;&ensp;&ensp;④将新进程插入到就绪队列<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8713.png">   </p>
<h3 id="2-3-3-进程的终止"><a href="#2-3-3-进程的终止" class="headerlink" title="2.3.3 进程的终止"></a>2.3.3 进程的终止</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.引起进程终止的事件</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）正常结束<br>&ensp;&ensp;&ensp;&ensp;2）异常结束 指的是出现某些错误和故障而迫使进程终止。常见的异常有：越界错误；保护错；非法指令；特权指令错；运行超时；等待超时；算术运算错和I/O故障。<br>&ensp;&ensp;&ensp;&ensp;3）外界干预   指的是进程应外界的请求而终止执行。常见的干预包括：操作员或操作系统干预；父进程请求；父进程终止等。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.进程终止过程</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;1）根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态；  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度；  </p>
<p>&ensp;&ensp;&ensp;&ensp;3）若该进程还有子孙进程，还应将其所有子孙进程予以终止，以防他们成为不可控制的进程；  </p>
<p>&ensp;&ensp;&ensp;&ensp;4）将被终止进程所拥有的全部资源，或者归还给父进程，或者归还给系统；  </p>
<p>&ensp;&ensp;&ensp;&ensp;5）将被终止进程（它的PCB）从所在队列（或链表）中移出，等待其他程序来搜集信息。  </p>
<h3 id="2-3-4-进程的阻塞与唤醒"><a href="#2-3-4-进程的阻塞与唤醒" class="headerlink" title="2.3.4 进程的阻塞与唤醒"></a>2.3.4 进程的阻塞与唤醒</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.引起进程阻塞和唤醒的事件</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;1）请求共享资源失败 由于操作系统不能马上满足进程的请求，导致进程只能转变为阻塞状态等待；<br>&ensp;&ensp;&ensp;&ensp;2）等待某种操作的完成 如果某进程必须在一个已启动的操作完成后才能继续执行，则必须先将该进程阻塞，以等待该操作的完成；<br>&ensp;&ensp;&ensp;&ensp;3）新数据尚未到达；<br>&ensp;&ensp;&ensp;&ensp;4）等待新任务的到达 系统往往设置一些具有某种特定功能的系统进程，每当这种进程完成任务后，便把自己阻塞起来以等待新任务到来  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.进程阻塞过程</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;进程可通过调用阻塞原语block把自己阻塞。阻塞过程为：<br>&ensp;&ensp;&ensp;&ensp;1）调用block原语；<br>&ensp;&ensp;&ensp;&ensp;2）停止当前进程的执行；把PCB中的状态由“执行”改为“阻塞”；<br>&ensp;&ensp;&ensp;&ensp;3）将PCB插入到阻塞队列；<br>&ensp;&ensp;&ensp;&ensp;4）转调度程序进行重新调度，保留被阻塞进程的处理机状态<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8714.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.进程唤醒过程</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;当被阻塞进程所期待的事件出现时，如I/O完成或其所期待的数据已经到达，则由有关进程（比如，用完并释放了该I/O设备的进程）调用唤醒原语wakeup( )，将等待该事件的进程唤醒。其执行过程为：  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）把被阻塞进程从等待该事件的阻塞队列中移出，将其PCB中的现行状态由阻塞改为就绪；<br>&ensp;&ensp;&ensp;&ensp;2）将该PCB插入到就绪队列中。  </p>
<h3 id="2-3-5-进程的挂起与激活"><a href="#2-3-5-进程的挂起与激活" class="headerlink" title="2.3.5 进程的挂起与激活"></a>2.3.5 进程的挂起与激活</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.进程的挂起</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;当出现了引起进程挂起的事件时，系统将利用挂起原语suspend( )将指定进程或处于阻塞状态的进程挂起。其执行过程为：  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）检查被挂起进程的状态，若处于活动就绪状态，则将其改为静止就绪；对于活动阻塞状态的进程，则将其改为静止阻塞。<br>&ensp;&ensp;&ensp;&ensp;2)把该进程的PCB复制到某指定的内存区域；<br>&ensp;&ensp;&ensp;&ensp;3)若被挂起的进程正在执行，则转向调度程序重新调度。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8715.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.进程的激活</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;当发生激活进程的事件时，则可将在外存上处于静止就绪状态的进程换入内存。系统利用激活原语active( )将指定进程激活。其激活过程如下：  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）将进程从外存调入内存；<br>&ensp;&ensp;&ensp;&ensp;2）检查该进程的现行状态，若是静止就绪，便将之改为活动就绪；若为静止阻塞，则将其改为活动阻塞。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8716.png">     </p>
<h2 id="2-4-进程同步"><a href="#2-4-进程同步" class="headerlink" title="2.4 进程同步"></a>2.4 进程同步</h2><p>&ensp;&ensp;&ensp;&ensp;同步：并发进程在执行次序上的协调，以达到有效的资源共享和相互合作，使程序执行有可再现性。  </p>
<h3 id="2-4-1-进程同步的基本概念"><a href="#2-4-1-进程同步的基本概念" class="headerlink" title="2.4.1 进程同步的基本概念"></a>2.4.1 进程同步的基本概念</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.两种形式的制约关系</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在多道程序环境下，当程序并发执行时，可能存在以下两种形式的制约关系：</p>
<p>&ensp;&ensp;&ensp;&ensp;①间接制约关系：同处于一个系统的进程，必然共享着某种系统资源，如CPU, I/O等。间接制约关系源于这种资源共享。</p>
<p>&ensp;&ensp;&ensp;&ensp;②直接制约关系：这种制约关系主要源于进程间的合作。</p>
<p>&ensp;&ensp;&ensp;&ensp;间接制约：进行竞争－－独占分配到的部分或全部的共享资源，“互斥”<br>&ensp;&ensp;&ensp;&ensp;直接制约：进行协作－－等待来自其他进程的信息，“同步”  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.临界资源(Critical Resouce)</strong> </p>
<p>&ensp;&ensp;&ensp;&ensp;在一段时间内只允许一个进程访问的资源，即仅当一个进程访问完并释放该资源后，才允许另一个进程访问的资源，称为临界资源或独占资源。如：打印机、磁带机、共享变量、队列等。  </p>
<p>&ensp;&ensp;&ensp;&ensp;生产者－消费者问题：<br>&ensp;&ensp;&ensp;&ensp;生产者投放一个产品后，输入指针in加1：in = ( in + 1 ) % n （n是缓冲区个数，整型常量），in初值为0； 消费者每取出一个产品，输出指针out加1：out = ( out + 1 ) % n，out初值为0；<br>&ensp;&ensp;&ensp;&ensp;引入一个共享变量counter,初值为0。<br>&ensp;&ensp;&ensp;&ensp;▲生产者投放一个产品，counter加1，counter = n时不能再投放产品<br>&ensp;&ensp;&ensp;&ensp;▲消费者每取一个产品，counter减1，counter = 0时不能再取出产品   </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Var n： integer;   缓冲区的个数</span><br><span class="line">Type item=…;</span><br><span class="line">var buffer:<span class="built_in">array</span>[<span class="number">0</span>,<span class="number">1</span>,…,n<span class="number">-1</span>] of item;</span><br><span class="line">in, out: <span class="number">0</span>,<span class="number">1</span>, …, n<span class="number">-1</span>;</span><br><span class="line">counter: <span class="number">0</span>,<span class="number">1</span>,…,n; </span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">producer()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		produce an item in nextp;</span><br><span class="line">              …</span><br><span class="line">		<span class="keyword">while</span>(counter==n) no-op;</span><br><span class="line">		buffer[in]=nextp;</span><br><span class="line">		in:=(in+<span class="number">1</span>)% n;</span><br><span class="line">		counter++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(counter==<span class="number">0</span>) no-op;</span><br><span class="line">		nextc=buffer[out];</span><br><span class="line">		out=(out+<span class="number">1</span>) % n;</span><br><span class="line">		counter--;</span><br><span class="line">		consumer the item in nextc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>&ensp;&ensp;&ensp;&ensp;<strong>3.临界区(Critical Section)</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;Critical section:把每个进程中访问临界资源的那段<strong>代码</strong>叫临界区(Critical Section)。只要每个进程互斥进入临界区、便可以实现对临界资源的互斥访问。<br>算法:  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	entry section; <span class="comment">//进入区：用于检查临界资源是否空闲，有无进程进入</span></span><br><span class="line">	critical section;</span><br><span class="line">	<span class="built_in">exit</span> section; <span class="comment">//退出区：用于释放临界资源，将访问标志复位</span></span><br><span class="line">	remainder section;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;<strong>4.同步机制遵循的规则（进入临界区的准则）</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）空闲让进：当临界资源空闲时，允许一个进程进入临界区。<br>&ensp;&ensp;&ensp;&ensp;2）忙则等待：临界资源正被访问时，其它进程必须等待，以保证对临界资源的互斥访问。<br>&ensp;&ensp;&ensp;&ensp;3）有限等待：应保证进程能在有限时间内能进入自己的临界区，以免陷入“死等”。<br>&ensp;&ensp;&ensp;&ensp;4）让权等待：如果进程不能进入自己的临界区、应立即释放处理机，以免陷入“忙等”。  </p>
<h3 id="2-4-2-硬件同步机制"><a href="#2-4-2-硬件同步机制" class="headerlink" title="2.4.2 硬件同步机制"></a>2.4.2 硬件同步机制</h3><p>&ensp;&ensp;&ensp;&ensp;虽然可以利用软件方法解决诸进程互斥进入临界区的问题，但有一定难度，并且存在很大的局限性，因而现在已很少采用。相应地，目前许多计算机已提供了一些特殊的硬件指令，允许对一个字中的内容进行检测和修正，或者是对两个字的内容进行交换等。可利用这些特殊的指令来解决临界区问题。实际上，在对临界区进行管理时，可以将标志看作一个锁，“锁开”进入，“锁关”等待，初始时锁是打开的。每个要进入临界区的进程必须先对锁进行测试，当锁未开时，则必须等待，直至锁被打开。反之，当锁是打开的时候，则应立即把其锁上，以阻止其它进程进入临界区。显然，为防止多个进程同时测试到锁为打开的情况，测试和关锁操作必须是连续的，不允许分开进行。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.关中断</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;实现方法：<br>&ensp;&ensp;&ensp;&ensp;在单处理机环境下，在进入临界区之后，关闭中断，直到离开临界区再打开中断。  </p>
<p>&ensp;&ensp;&ensp;&ensp;优点：<br>&ensp;&ensp;&ensp;&ensp;①进程在临界区执行期间，计算机不响应中断，不会引发调度，不会发生进程切换或线程切换。<br>&ensp;&ensp;&ensp;&ensp;②保证了对锁的测试和关锁操作的连续性和完整性，有效地保证了互斥。<br>&ensp;&ensp;&ensp;&ensp;缺点：<br>&ensp;&ensp;&ensp;&ensp;①滥用关中断权力可能导致严重后果；<br>&ensp;&ensp;&ensp;&ensp;②关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力；<br>&ensp;&ensp;&ensp;&ensp;③关中断方法也不适用于多CPU系统，因为，在一个处理器上关中断，并不能防止进程在其它处理器上执行相同临界段代码。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.利用Test-and-Set指令实现互斥</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;方法：<br>&ensp;&ensp;&ensp;&ensp;借助一条硬件指令“测试并建立”指令TS（Test-and-Set），该指令看作为一条原语。为每个临界资源设置一个布尔变量lock，lock初值为false，表示该临界资源空闲。TS指令的一般性描述：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">TS</span><span class="params">(boolean *lock)</span></span>&#123;</span><br><span class="line">    boolean old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock = TRUE;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;如果不能进入临界区，进行循环测试，TS指令实现互斥的循环结构描述：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="function"><span class="keyword">while</span> <span class="title">TS</span><span class="params">(&amp;lock)</span></span>;</span><br><span class="line">    cirtical section;</span><br><span class="line">    lock=FALSE;</span><br><span class="line">…</span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE)</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;<strong>3. 利用Swap指令实现进程互斥</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;含义:对换指令，在Intel 80x86又称为XCHG指令，用于交换两个字的内容。其处理过程描述如下：  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(boolean *a, boolean *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	boolean temp;</span><br><span class="line">	temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;互斥访问临界资源的方法:<br>&ensp;&ensp;&ensp;&ensp;为每个临界资源设置一个全局的布尔变量lock，其初值为false，在每个进程中再利用一个局部布尔变量key。利用Swap指令实现进程互斥的循环进程:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    key=TRUE;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        swap(&amp;lock, &amp;key);</span><br><span class="line">       &#125; <span class="keyword">while</span> (key!=FALSE)</span><br><span class="line">   critical section;</span><br><span class="line">   lock=FALSE;</span><br><span class="line">   …</span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;利用硬件指令的出现的问题:<br>&ensp;&ensp;&ensp;&ensp;“忙等”，即进程在进入不了临界区时，不放弃处理器，而不断地进行测试。<br>&ensp;&ensp;&ensp;&ensp;结果:<br>&ensp;&ensp;&ensp;&ensp;不符合“让权等待”，造成处理机浪费<br>&ensp;&ensp;&ensp;&ensp;解决方法:<br>&ensp;&ensp;&ensp;&ensp;信号量机制    </p>
<h3 id="2-4-3-信号量机制"><a href="#2-4-3-信号量机制" class="headerlink" title="2.4.3 信号量机制"></a>2.4.3 信号量机制</h3><p>&ensp;&ensp;&ensp;&ensp;原理：进程通过传递信号进行合作，可迫使某进程在某个位置暂时停止执行（阻塞等待），直到它收到一个可以“向前推进”的信号（被唤醒）。<br>&ensp;&ensp;&ensp;&ensp;信号量(Semaphores)是一种卓越的进程同步工具。目前有：整型信号量、记录型信号量和信号量集。<br>&ensp;&ensp;&ensp;&ensp;信号量可以用于单处理机、多处理机和网络中的互斥访问问题。<br>&ensp;&ensp;&ensp;&ensp;信号量机制是由Dijkstra提出的一种实现进程同步与互斥的通用方法，包括信号量s以及对信号量的两个原子操作wait和signal。早期这两个原语被称为P(s),V(s)操作。（P、V分别是荷兰语的pass(passeren)和increment(verhoog) 。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1. 整型信号量</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;最初由Dijkstra把整型信号量定义为一个用于表示资源数目的整型量S，它与一般整型量不同，除初始化外，仅能通过两个标准的原子操作wait和signal来访问（即P、V）。</p>
<p>&ensp;&ensp;&ensp;&ensp;(1)定义一个信号量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">var s:semaphore=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;(2)等待信号量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Wait(s)&#123;</span><br><span class="line">	<span class="keyword">while</span>(s&lt;= <span class="number">0</span>) ;</span><br><span class="line">	s--;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;(3)通知信号量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">signal(s)&#123;</span><br><span class="line">	s++;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 记录型信号量</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;因整型机制不断测试不满足“让权等待”而引入  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span> value;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">process_control_block</span>  *<span class="title">list</span>;</span></span><br><span class="line">&#125;semaphore;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;list:为进程链表，用于链接所有等待该类资源的进程。<br>&ensp;&ensp;&ensp;&ensp;用wait(s)和signal(s)实现同步与互斥。<br>&ensp;&ensp;&ensp;&ensp;在记录型信号量机制中：<br>&ensp;&ensp;&ensp;&ensp;s-&gt;value初值：表示系统中某类资源的数目。<br>&ensp;&ensp;&ensp;&ensp;s-&gt;value&lt;0:无可用资源，其绝对值表示系统中因请求该类资源而被阻塞的进程数目。  </p>
<p>等待：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">wait(semaphore *S)&#123;</span><br><span class="line">	S-&gt;value --;</span><br><span class="line">	<span class="keyword">if</span>(S-&gt;value &lt; <span class="number">0</span>)</span><br><span class="line">		block(S-&gt;<span class="built_in">list</span>);<span class="comment">//让权等待</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通知：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">signal(semaphore *S)&#123;</span><br><span class="line">	S-&gt;value ++;</span><br><span class="line">	<span class="keyword">if</span>(S-&gt;value &lt;= <span class="number">0</span>)</span><br><span class="line">		wakeup(S-&gt;<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;关于记录型信号量的说明<br>&ensp;&ensp;&ensp;&ensp;每次执行完S-&gt;value–操作后，若S-&gt;value&lt;0时，说明该类资源已分配完毕，因此进程应调用block原语，进行自我阻塞，放弃处理机，并插入到信号量链表S.list中。<br>&ensp;&ensp;&ensp;&ensp;每次执行完S-&gt;value++操作后，若S-&gt;value≤0时，则表示在该信号量链表中，仍有等待该资源的进程被阻塞，故还应调用wakeup原语，将S.list链表中的第一个等待进程唤醒。<br>&ensp;&ensp;&ensp;&ensp;若S-&gt;value的初值为1，表示只允许一个进程访问临界资源，此时的信号量转化为互斥信号量。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3. AND型信号量</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;AND型信号量集用于同时需要多种资源且每种资源占用一个信号量时的信号量操作；<br>&ensp;&ensp;&ensp;&ensp;基本思想：在一个原语中，将一段代码同时需要的多个临界资源，要么全部分配给它，要么一个都不分配。为Swait(Simultaneous Wait)。<br>&ensp;&ensp;&ensp;&ensp;在Swait时，各个信号量的次序并不重要，虽然会影响进程归入哪个阻塞队列，但是由于是对资源全部分配或不分配。<br>&ensp;&ensp;&ensp;&ensp;所以总有进程获得全部资源，并在执行完毕之后释放资源，因此不会死锁。   </p>
<p>等待操作Swait()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Swait(S1,S2,…Sn)&#123;</span><br><span class="line">   <span class="keyword">while</span>( TRUE)</span><br><span class="line">    &#123;      </span><br><span class="line">		 <span class="keyword">if</span>(S1&gt;=<span class="number">1</span> &amp;&amp; S2&gt;=<span class="number">1</span>…&amp;&amp; Sn&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)  Si--;   / /满足资源要求时的处理；</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">			&#125;<span class="comment">//if</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//某些资源不够时的处理；调用进程进入第一个小于1信号量的等待队列Sj;并把该进程的程序计数器指向swait操作的开始。 </span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通知操作Ssignal()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Ssignal(S1,S2,…Sn)&#123;</span><br><span class="line">   <span class="keyword">while</span>(TRUE)</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        Si++;<span class="comment">//释放资源</span></span><br><span class="line">  把 Si等待队列中的进程调入就绪队列。</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;<strong>4. 信号量集</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;思想：若进程一次需要申请多类临界资源，则在进行临界资源分配时，先测试各类临界资源是否大于其下限值。若低于下限值，则不予分配。<br>&ensp;&ensp;&ensp;&ensp;对应的Swait 和Ssignal格式为：<br>&ensp;&ensp;&ensp;&ensp;Swait(S1,t1,d1,…,Sn,tn,dn)    Ssignal(S1,d1,…,Sn,dn)<br>这里S为信号量，d为需求值，t为下限值  </p>
<p>&ensp;&ensp;&ensp;&ensp;用于同时需要多种资源、每种资源的占用数目不同、且可分配的资源还存在一个临界值时的处理；<br>&ensp;&ensp;&ensp;&ensp;临界值，就是指在某些情况下，当资源数量低于某一下限值时，便不予分配。这个下限值称作临界值。<br>&ensp;&ensp;&ensp;&ensp;一次需要N个某类临界资源，就要进行N次wait操作－－低效又可能死锁<br>&ensp;&ensp;&ensp;&ensp;基本思想：在AND型信号量集的基础上进行扩充：进程对信号量Si的下限值为ti（用于信号量的判断，即Si &lt;= ti，表示资源数量低于ti时，便不予分配），需求值为di（用于信号量的增减，即Si = Si - di和Si = Si + di）  </p>
<p>等待操作Swait()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Swait(S1，t1，d1，…，Sn，tn，dn)</span><br><span class="line">　　　　<span class="keyword">if</span> (Si&gt;=t1 &amp;&amp; … &amp;&amp; Sn&gt;=tn )&#123;</span><br><span class="line">　　　　　　<span class="keyword">for</span> (i=<span class="number">1</span> ;i&lt;= n;i++)</span><br><span class="line">　　　　　　　　Si:=Si-di；</span><br><span class="line">　　　　　　<span class="keyword">else</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;三种特例：<br>&ensp;&ensp;&ensp;&ensp;（1）Swait(S,d,d)：允许每次申请d个资源。当资源数少于d时，不予分配。<br>&ensp;&ensp;&ensp;&ensp;（2）Swait (s,1,1)：S&gt;1，资源信号量。S=1时，互斥信号量。<br>&ensp;&ensp;&ensp;&ensp;（3）Swait(s,1,0)，可控开关，当s&gt;=1时，允许进入，当s变为0后，阻止任何进程不能进入。  </p>
<h3 id="2-4-4-信号量的应用"><a href="#2-4-4-信号量的应用" class="headerlink" title="2.4.4 信号量的应用"></a>2.4.4 信号量的应用</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1. 利用信号量实现互斥</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）为临界资源设置一个互斥信号量mutex，其初值为1，取值为（-1，0，1）；在每个进程中将临界区代码置于wait(mutex)和signal(mutex)原语之间。</p>
<p>&ensp;&ensp;&ensp;&ensp;2）代码描述   </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>;</span><br><span class="line">Pa()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		wait(mutex);</span><br><span class="line">		临界区；</span><br><span class="line">		signal(mutex);</span><br><span class="line">		剩余区；</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Pb()&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		wait(mutex);</span><br><span class="line">		临界区；</span><br><span class="line">		signal(mutex);</span><br><span class="line">		剩余区；</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;必须成对使用wait和signal原语,不能次序错误、重复或遗漏.遗漏wait原语则不能保证互斥访问，遗漏signal原语则不能在使用临界资源之后将其释放（给其他等待的进程）。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2. 利用信号量来描述前趋关系</strong>   </p>
<p><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8717.png">   </p>
<p>代码描述框架如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p1()&#123; S1; signal(a); signal(b); &#125;</span><br><span class="line">p2()&#123; wait(a); S2; signal(c); signal(d); &#125;</span><br><span class="line">p3()&#123; wait(b);S3; signal(e); &#125;</span><br><span class="line">p4()&#123; wait(c);S4; signal(f); &#125;</span><br><span class="line">p5()&#123; wait(d);S1; signal(g); &#125;</span><br><span class="line">p6()&#123; wait(e); wait(f);wait(g);S6; &#125;</span><br><span class="line">main()&#123;</span><br><span class="line">semaphore a,b,c,d,e,f,g;</span><br><span class="line">a.value=b.value=c.value=d.value=e.value=f.value=g.value=<span class="number">0</span>;</span><br><span class="line">cobegin</span><br><span class="line">    p1();p2();p3();p4();p5();p6();</span><br><span class="line">coend  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-5-管程机制"><a href="#2-4-5-管程机制" class="headerlink" title="2.4.5 管程机制"></a>2.4.5 管程机制</h3><p>&ensp;&ensp;&ensp;&ensp;信号量同步的缺点<br>&ensp;&ensp;&ensp;&ensp;1）同步操作分散：信号量机制中，同步操作分散在各个进程中，使用不当就可能导致各进程死锁（如P、V操作的次序错误、重复或遗漏）；<br>&ensp;&ensp;&ensp;&ensp;2）易读性差：要了解对于一组共享变量及信号量的操作是否正确，必须通读整个系统或者并发程序；<br>&ensp;&ensp;&ensp;&ensp;3）不利于修改和维护：各模块的独立性差，任一组变量或一段代码的修改都可能影响全局；<br>&ensp;&ensp;&ensp;&ensp;4）正确性难以保证：操作系统或并发程序通常很大，很难保证这样一个复杂的系统没有逻辑错误。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>1.管程的定义</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;管程（Mointors）：一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。<br>&ensp;&ensp;&ensp;&ensp;管程组成：① 局部于管程的共享变量说明；② 对该数据结构进行操作的一组过程；③ 对局部于管程的数据设置初始值的语句。④还须为管程赋予一个名字。<br>&ensp;&ensp;&ensp;&ensp;代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，共同构成了一个操作系统的资源管理模块，我们称之为管程。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8718.png">   </p>
<p>管程语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  Monitor monitor-name&#123;</span><br><span class="line">  share variable declarations;</span><br><span class="line">  cond declarations;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">(…)</span>  </span>&#123;….&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">(…)</span>  </span>&#123;….&#125;;</span><br><span class="line">  ….</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Pn</span><span class="params">(…)</span>  </span>&#123;….&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">        initialization code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;管程的主要特性<br>&ensp;&ensp;&ensp;&ensp;1）模块化：一个管程是一个基本程序单位，可以单独编译；<br>&ensp;&ensp;&ensp;&ensp;2）抽象数据类型：管程是一种特殊的数据类型，其中不仅有数据，而且有对数据进行操作的代码；<br>&ensp;&ensp;&ensp;&ensp;3）信息封装：管程是半透明的，管程中的过程（函数）实现了某些功能，至于这些功能是怎样实现的，在其外部则是不可见的。  </p>
<p>&ensp;&ensp;&ensp;&ensp;管程与进程的区别<br>&ensp;&ensp;&ensp;&ensp;1）进程定义的是私有数据结构PCB，管程定义的是公共数据结构；<br>&ensp;&ensp;&ensp;&ensp;2）都有对各自数据结构的操作。进程的操作由对应的代码段决定，管程的操作主要是同步操作和初始化操作；<br>&ensp;&ensp;&ensp;&ensp;3）设置进程的目的是为了实现并发，管程的目的是解决临界资源的互斥使用；  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.条件变量</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;管程的设计：<br>&ensp;&ensp;&ensp;&ensp;必须设置同步工具，如操作原语wait和signal，来保证对临界资源的正确访问；<br>&ensp;&ensp;&ensp;&ensp;引入条件变量condition，解决进程调用管程过程中被阻塞或挂起时，释放管程的相关控制；<br>&ensp;&ensp;&ensp;&ensp;通常，进程被挂起或阻塞的原因可能有多个，为了区别它们，需设置多个条件变量condition。<br>&ensp;&ensp;&ensp;&ensp;对条件变量的操作仅仅是wait和signal，因此条件变量也是一种抽象数据类型，每个条件变量保存了一个链表，用于记录因该条件变量而阻塞的所有进程。同时提供的两个操作即可表示为x.wait和x.signal。<br>&ensp;&ensp;&ensp;&ensp;x.wait的作用是：正在调用管程的进程因x条件需要被阻塞或挂起，则调用x.wait将自己插入到x条件的等待对列上，并释放管程，直到x条件变化。此时其它进程可以使用该管程。<br>&ensp;&ensp;&ensp;&ensp;x.signal的作用是：正在调用管程的进程发现x条件发生了变化，则调用x.signal重新启动一个因x条件而被阻塞或挂起的进程。如果存在多个这样的进程，则选择其中的一个，但如果没有被阻塞的进程，则x.signal操作不产生任何后果。如果有进程Q因x条件处于阻塞状态，当进程P执行了x.signal操作后，进程Q被重新启动，此时两个进程P和Q，怎样决定哪个进程执行，哪个等待，可采用下述两种方式之一：<br>&ensp;&ensp;&ensp;&ensp;（1） P等待，直至Q离开管程或等待另一条件；<br>&ensp;&ensp;&ensp;&ensp;（2） Q等待，直至P离开管程或等待另一条件。  </p>
<h2 id="2-5-经典进程的同步问题"><a href="#2-5-经典进程的同步问题" class="headerlink" title="2.5 经典进程的同步问题"></a>2.5 经典进程的同步问题</h2><h3 id="2-5-1-生产者——消费者问题"><a href="#2-5-1-生产者——消费者问题" class="headerlink" title="2.5.1 生产者——消费者问题"></a>2.5.1 生产者——消费者问题</h3><p>书p65<br>记录型信号量、AND型信号量、管程  </p>
<h3 id="2-5-2-哲学家进餐问题"><a href="#2-5-2-哲学家进餐问题" class="headerlink" title="2.5.2 哲学家进餐问题"></a>2.5.2 哲学家进餐问题</h3><p>书p69<br>记录型信号量、AND型信号量</p>
<h3 id="2-5-3-读者——写者问题"><a href="#2-5-3-读者——写者问题" class="headerlink" title="2.5.3 读者——写者问题"></a>2.5.3 读者——写者问题</h3><p>书p71<br>记录型信号量、信号量集</p>
<h2 id="2-6-进程通信"><a href="#2-6-进程通信" class="headerlink" title="2.6 进程通信"></a>2.6 进程通信</h2><p>&ensp;&ensp;&ensp;&ensp;进程通信的方式<br>&ensp;&ensp;&ensp;&ensp;进程之间的通信内容包含两种类型：控制信息和大批量数据。<br>&ensp;&ensp;&ensp;&ensp;低级通信：进程之间交换控制信息的过程<br>&ensp;&ensp;&ensp;&ensp;高级通信：进程之间交换批量数据的过程<br>&ensp;&ensp;&ensp;&ensp;进程之间同步与互斥是一种低级通信来控制进程的执行速度。</p>
<p>&ensp;&ensp;&ensp;&ensp;高级通信：利用操作系统提供的通信命令，高效传送大量数据的一种通信方式。<br>&ensp;&ensp;&ensp;&ensp;高级通讯方式有：<br>&ensp;&ensp;&ensp;&ensp;1、共享存储器系统，<br>&ensp;&ensp;&ensp;&ensp;2、管道通信系统<br>&ensp;&ensp;&ensp;&ensp;3、消息传递系统<br>&ensp;&ensp;&ensp;&ensp;4、C/S系统  </p>
<h3 id="2-6-1-进程通信的类型"><a href="#2-6-1-进程通信的类型" class="headerlink" title="2.6.1 进程通信的类型"></a>2.6.1 进程通信的类型</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.共享存储器系统（Shared-Memory System）</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在共享存储器系统中，相互通信的进程共享某些数据结构或共享存储区，进程之间能够通过这些空间进行通信。又可以分为以下两种类型：  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）基于共享数据结构的通信方式（低级通信）<br>&ensp;&ensp;&ensp;&ensp;该种通信方式中，要求诸进程公用某些数据结构，借以实现诸进程间的信息交换。如生产者-消费者问题中的共享缓冲池。这种通信方式仅适于传递相对少量的数据，通信效率低下，属于低级通信。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8719.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）基于共享存储区的通信方式（高级通信）<br>&ensp;&ensp;&ensp;&ensp;为了传输大量数据，在存储器中划出了一块共享存储区，诸进程可通过对共享存储区中数据的读和写来实现通信。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8720.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;步骤：<br>&ensp;&ensp;&ensp;&ensp;（1）申请共享存储区。<br>&ensp;&ensp;&ensp;&ensp;（2）连接共享存储区到进程的存储空间。<br>&ensp;&ensp;&ensp;&ensp;（3）互斥访问共享存储区。<br>&ensp;&ensp;&ensp;&ensp;（4）归还共享存储区。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.管道（pipe）通信系统</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。<br>&ensp;&ensp;&ensp;&ensp;向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入管道；<br>&ensp;&ensp;&ensp;&ensp;而接受管道输出的接收进程（即读进程），则从管道中接收（读）数据。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8721.png">     </p>
<p>&ensp;&ensp;&ensp;&ensp;管道机制须提供的协调能力<br>&ensp;&ensp;&ensp;&ensp;①互斥 即当一个进程正在对pipe执行读/写操作时，其他进程必须等待；<br>&ensp;&ensp;&ensp;&ensp;②同步  指当写（输入）进程把一定数量的数据写入pipe，便去睡眠等待，直到读（输出）进程取走数据后，再把它唤醒。当读进程读一空pipe时，也应睡眠等待，直至写进程将数据写入管道后，才将之唤醒；<br>&ensp;&ensp;&ensp;&ensp;③确定对方是否存在，只有确定了对方已存在时，才能进行通信。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.消息传递系统（Message passing system）</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在消息传递系统中，进程间的数据交换，是以格式化的消息（Message）为单位的。程序员直接利用系统提供的一组通信命令进行通信。<br>&ensp;&ensp;&ensp;&ensp;当今最为流行的微内核操作系统中，微内核与服务器之间的通信，无一例外地都采用了消息传递机制。<br>&ensp;&ensp;&ensp;&ensp;当基于消息传递系统的通信方式属于高级通信方式，因其实现方式的不同，可进一步分成两类：<br>&ensp;&ensp;&ensp;&ensp;1）直接通信方式：发送进程利用OS所提供的发送命令，直接把消息发送给目标进程；<br>&ensp;&ensp;&ensp;&ensp;2）间接通信方式：进程之间的通信，通过中间实体（也称为信箱）来暂存发送进程发送给目标进程的消息，接收进程则从该实体中接收发送给自己的消息。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.客户机-服务器系统（Client-server system）</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;客户机-服务器系统的通信机制，在网络环境下的各种应用领域以成为当前主流的通信实现机制。<br>&ensp;&ensp;&ensp;&ensp;其主要的实现方法有三类：①套接字，②远程方法调用和③远程过程调用。  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）套接字：起源于BSD Unix,最初用于同一台主机上多个应用程序之间的通信，随着网络技术和Unix操作系统的广泛使用，套接字已经逐渐成为最流行的网络程序接口之一。通常包括两类：<br>&ensp;&ensp;&ensp;&ensp;（1）基于文件型：通信进程运行在同一台机器的环境中，套接字是基于本地文件系统支持的，一个套接字关联到一个特殊的文件，通信双方通过对这个特殊文件的读写实现通信，原理类似于管道。<br>&ensp;&ensp;&ensp;&ensp;（2）基于网络型：采用非对称方式通信，即发送者需要提供接收者命名。通信双方的进程运行在不同主机的网络环境下，被分配了一对套接字，分别属于发送者和接收者。  </p>
<p>&ensp;&ensp;&ensp;&ensp;套接字的优势在于，它不仅适用于同一台计算机内部的通信，也适用于网络环境中不同计算机间的进程通信。由于每个套接字拥有唯一标识符，因而可以方便加以区分。  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）远程过程调用和远程方法调用：远程过程调用RPC是一个通信协议，允许一台主机（本地）系统上的进程调用另一台主机（远程）系统上的进程。如果涉及的软件采用面向对象编程，那么RPC亦可称为远程方法调用。<br>&ensp;&ensp;&ensp;&ensp;负责RPC的进程有两个，一个是本地客户进程，另一个是远程服务进程。它们通常也被称为网络守护进程，主要负责网络间的消息传递，一般都处于阻塞状态，等待消息。  </p>
<h3 id="2-6-2-消息传递通信的实现方式"><a href="#2-6-2-消息传递通信的实现方式" class="headerlink" title="2.6.2 消息传递通信的实现方式"></a>2.6.2 消息传递通信的实现方式</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.直接消息传递系统</strong>：发送进程利用OS提供的发送命令（原语），直接把消息发送给目标进程。  </p>
<p>&ensp;&ensp;&ensp;&ensp;1）直接通信原语<br>&ensp;&ensp;&ensp;&ensp;a.对称寻址方式<br>&ensp;&ensp;&ensp;&ensp;send(Receiver, message)   send(P2,m1)<br>&ensp;&ensp;&ensp;&ensp;receive(Sender, message)  receive(P1,m1)<br>&ensp;&ensp;&ensp;&ensp;b.非对称寻址方式<br>&ensp;&ensp;&ensp;&ensp;send(P,message)  receive     </p>
<p>&ensp;&ensp;&ensp;&ensp;2）消息格式:传递的消息要有统一的格式<br>&ensp;&ensp;&ensp;&ensp;①单机系统环境下，由于发送者和接收者处于同一台机器中，所以消息的格式采用比较短的定长消息格式。<br>&ensp;&ensp;&ensp;&ensp;（系统开销小，用户不便）<br>&ensp;&ensp;&ensp;&ensp;②对于发送较长消息的用户，可采用变长消息格式，即进程所发送的消息长度是可变的。<br>&ensp;&ensp;&ensp;&ensp;（开销大，用户方便）  </p>
<p>&ensp;&ensp;&ensp;&ensp;3）进程间的同步方式：通信进程之间需要协调通信。<br>&ensp;&ensp;&ensp;&ensp;①发送和接收进程阻塞（汇合）：用于紧密同步，无缓冲区时。<br>&ensp;&ensp;&ensp;&ensp;②发送进程不阻塞，接收进程阻塞：相当于接收进程（可能是多个）一直等待发送进程，如：打印进程等待打印任务。<br>&ensp;&ensp;&ensp;&ensp;③发送/接收进程均不阻塞：一般在发、收进程间有多个缓冲区时。  </p>
<p>&ensp;&ensp;&ensp;&ensp;4）通信链路<br>&ensp;&ensp;&ensp;&ensp;两种方式建立通信链路<br>&ensp;&ensp;&ensp;&ensp;显式建立：（使用“建立连接”原语）由发送进程在通信之前，用显式的“建立连接”命令（原语），请求系统为之建立一条通信链路，在链路使用完后拆除链路。<br>&ensp;&ensp;&ensp;&ensp;隐式建立：（使用发送原语）发送进程无须明确提出建立链路的请求，只须利用系统提供的发送命令（原语），系统会自动地为之建立一条链路。（多用于单机系统）   </p>
<p>&ensp;&ensp;&ensp;&ensp;根据通信方式的不同，则又可把链路分成两种<br>&ensp;&ensp;&ensp;&ensp;①单向通信链路，只允许发送进程向接收进程发送消息，或者相反；<br>&ensp;&ensp;&ensp;&ensp;②双向通信链路，既允许由进程A向进程B发送消息，也允许进程B同时向进程A发送消息。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.信箱通信（间接通信）</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;基本方式：通过邮箱发送、接收、回答信件通信发送进程申请建立一个与接收进程链接的邮箱。发送进程的消息送往邮箱，接收进程可在任何时候从邮箱中取出消息，从而完成进程间信息交换。</p>
<p>&ensp;&ensp;&ensp;&ensp;1）信箱的结构<br>&ensp;&ensp;&ensp;&ensp;信箱是一种数据结构，由信箱头和信箱体组成。<br>&ensp;&ensp;&ensp;&ensp;①信箱头：描述信箱名、大小及拥有该信箱的进程名称等<br>&ensp;&ensp;&ensp;&ensp;②信箱体：包含多个格子，用于存放消息正文<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8722.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）信箱的类型  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）私用信箱：<br>&ensp;&ensp;&ensp;&ensp;用户进程可为自己建立一个新信箱，并作为该进程的一部分，当拥有该信箱的进程结束时，信箱也随之消失；<br>&ensp;&ensp;&ensp;&ensp;（2）公用信箱：<br>&ensp;&ensp;&ensp;&ensp;由操作系统创建，并提供给系统中的所有核准进程使用，核准进程既可把消息发送到该信箱中，也可从信箱中读取发送给自己的消息；<br>&ensp;&ensp;&ensp;&ensp;（3）共享信箱：<br>&ensp;&ensp;&ensp;&ensp;由某进程创建，在创建时或创建后，指明它是可共享的，同时须指出共享进程（用户）的名字。  </p>
<h3 id="2-6-3-直接消息传递系统实例"><a href="#2-6-3-直接消息传递系统实例" class="headerlink" title="2.6.3 直接消息传递系统实例"></a>2.6.3 直接消息传递系统实例</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.消息缓冲队列通信系统中的数据结构</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;1）消息缓冲区  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type <span class="class"><span class="keyword">struct</span> <span class="title">message_buffer</span>&#123;</span></span><br><span class="line">　　<span class="keyword">int</span> sender； 发送者进程标识符</span><br><span class="line">　　<span class="keyword">int</span> size；   消息长度</span><br><span class="line">　　<span class="keyword">char</span> *text；   消息正文</span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">message_buffer</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;2）PCB中有关通信的数据项   </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type <span class="class"><span class="keyword">struct</span> <span class="title">processcontrol_block</span>&#123;</span></span><br><span class="line">	…</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">message_buffer</span> *<span class="title">mq</span>； 消息队列队首指针</span></span><br><span class="line"><span class="class">	<span class="title">semaphore</span> <span class="title">mutex</span>；  消息队列互斥信号量</span></span><br><span class="line"><span class="class">	<span class="title">semaphore</span> <span class="title">sm</span>；     消息队列资源信号量</span></span><br><span class="line"><span class="class">	…</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;&ensp;&ensp;<strong>2.发送原语</strong>   </p>
<p><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8723.png">  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(receiver, a)</span></span>&#123;</span><br><span class="line">	 getbuf(a.size, i);向系统申请一个消息缓冲区</span><br><span class="line">	 i.sender=a.sender;</span><br><span class="line">	 i.size=a.size;</span><br><span class="line">	 i.text=a.text;</span><br><span class="line">	 i.next=<span class="number">0</span>;将发送的消息送消息缓冲区</span><br><span class="line">	 getid(PCBset, receiver.j);</span><br><span class="line">	 wait(j.mutex);</span><br><span class="line">	 insert(j.mq, i);将消息缓冲区插入消息队列     </span><br><span class="line">     signal(j.mutex);</span><br><span class="line">	 signal(j.sm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.接收原语</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">(b)</span></span>&#123;</span><br><span class="line">	 j=internal name;</span><br><span class="line">	 wait(j.sm);</span><br><span class="line">	 wait(j.mutex);</span><br><span class="line">	 remove(j.mq, i);取消息队列中的消息</span><br><span class="line">	 signal(j.mutex);</span><br><span class="line">	 b.sender=i.sender;</span><br><span class="line">	 b.size=i.size;</span><br><span class="line">	 b.text=i.text;将消息从缓冲区复制到接收区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-7-线程（THREAD）的基本概念"><a href="#2-7-线程（THREAD）的基本概念" class="headerlink" title="2.7 线程（THREAD）的基本概念"></a>2.7 线程（THREAD）的基本概念</h2><p>&ensp;&ensp;&ensp;&ensp;在20世纪60年代中期，人们设计多道OS时引入了进程的概念，从而解决了程序并发性的问题。此后的20多年时间里，进程一直作为资源分配和调度的基本单位。<br>&ensp;&ensp;&ensp;&ensp;80年代中期，为了进一步提高程序的并发度，引入了线程这一更小的基本单位。它特别适用于多处理机OS。  </p>
<h3 id="2-7-1-线程的引入"><a href="#2-7-1-线程的引入" class="headerlink" title="2.7.1 线程的引入"></a>2.7.1 线程的引入</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.程序并发执行所付出的时空开销</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）创建进程。系统在创建进程时，必须为之分配其所必需的、除处理机以外的所有资源。如内存空间、I/O设备以及建立相应的PCB。<br>&ensp;&ensp;&ensp;&ensp;（2）撤消进程。系统在撤消进程时，又必须先对这些资源进行回收操作，然后再撤消PCB。<br>&ensp;&ensp;&ensp;&ensp;（3）进程切换。在对进程进行切换时，由于要保留当前进程的CPU环境和设置新选中进程的CPU环境，为此需花费不少处理机时间。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.线程——作为调度和分派的基本单位</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;由于进程是一个资源的拥有者，所以在创建、撤销和切换中，系统必须付出较大的时空开销。正因如此，系统中设置的进程数目不宜过多，进程切换频率也不宜过高，这就限制了并发程度的进一步提高。<br>&ensp;&ensp;&ensp;&ensp;引入线程，以线程作为调度、分派和切换的基本单位，则可以有效地改善系统性能。  </p>
<h3 id="2-7-2-线程与进程的比较"><a href="#2-7-2-线程与进程的比较" class="headerlink" title="2.7.2 线程与进程的比较"></a>2.7.2 线程与进程的比较</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.调度的基本单位</strong>：在传统的操作系统中，拥有资源的基本单位和独立调度、分派的基本单位都是进程，因而调度时，开销较大。引入线程则把它作为独立运行的基本单位，切换线程时，仅需保存和设置少量的寄存器内容，代价较低。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.并发性</strong>：在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，因而使操作系统具有更好的并发性，从而能更有效地使用系统资源和提高系统吞吐量。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.拥有资源</strong>：不论是传统的操作系统，还是设有线程的操作系统，进程都是拥有资源的一个独立单位，它可以拥有自己的资源。线程本身并不拥有系统资源，而是仅有一点必需，保证独立运行的资源。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4.独立性</strong>：同一进程中的不同线程之间的独立性比不同进程之间的独立性低得多。   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>5.系统开销</strong>：由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等。因此，操作系统所付出的开销将明显地大于在创建或撤消线程时的开销。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>6.支持多处理机系统</strong>：在多处理机系统中，传统的进程只能运行在一个处理机上。对于多线程进程，可将多个线程分配到多个处理机上，使它们并行执行。     </p>
<h3 id="2-7-3-线程的状态和线程控制块"><a href="#2-7-3-线程的状态和线程控制块" class="headerlink" title="2.7.3 线程的状态和线程控制块"></a>2.7.3 线程的状态和线程控制块</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.线程运行的三个状态</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;与传统进程一样，线程之间也存在着相互制约关系，使得线程运行时出现间断性，因而线程也有三种基本状态：<br>&ensp;&ensp;&ensp;&ensp;（1）执行状态。线程获得处理机正在运行。<br>&ensp;&ensp;&ensp;&ensp;（2）就绪状态。线程已具备了各种执行条件，只需再获得CPU便可执行。<br>&ensp;&ensp;&ensp;&ensp;（3）阻塞状态。线程因某个事件而处于暂停状态。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.线程控制块TCB</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;线程控制块通常包含以下几项内容：<br>&ensp;&ensp;&ensp;&ensp;①线程标识符；②一组寄存器，包括程序计数器，状态寄存器和通用寄存器；③线程运行状态；④线程优先级；⑤线程专有存储区；⑥信号屏蔽；⑦堆栈指针。</p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.多线程OS中的进程属性</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）作为系统资源分配的单位。（线程是资源调度的基本单位）<br>&ensp;&ensp;&ensp;&ensp;（2）可包括多个线程。一个进程都含有多个相对独立的线程，其数目可多可少，但至少要有一个线程，由进程为这些线程提供资源及运行环境，使这些线程可并发执行。<br>&ensp;&ensp;&ensp;&ensp;（3）进程不是一个可执行的实体。在多线程OS中，线程作为独立运行的基本单位。虽然如此，进程仍具有与执行相关的状态。所谓进程处于“执行”状态，实际上是指该进程中的<strong>某线程正在执行</strong>。把某<strong>进程挂起</strong>，该进程中的<strong>所有线程都将被挂起</strong>。    </p>
<h2 id="2-8-线程的实现"><a href="#2-8-线程的实现" class="headerlink" title="2.8 线程的实现"></a>2.8 线程的实现</h2><h3 id="2-8-1-线程的实现方式"><a href="#2-8-1-线程的实现方式" class="headerlink" title="2.8.1 线程的实现方式"></a>2.8.1 线程的实现方式</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.内核支持线程KST（Kernel Supported Threads）</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;内核支持线程KST（Kernel Supported Threads），指的是在内核支持下运行的，即无论是用户进程中的线程，还是系统进程中的线程，他们的创建、撤销和切换等也是依靠内核，在内核空间实现的。线程管理的所有工作都由内核完成。 </p>
<p>&ensp;&ensp;&ensp;&ensp;优点：<br>&ensp;&ensp;&ensp;&ensp;1）在多处理器系统中，内核能同时调度同一进程中的多个线程并行执行；<br>&ensp;&ensp;&ensp;&ensp;2）如果进程中的一个线程被阻塞了，内核可以调度该进程中的其他线程或运行其他进程中的线程；<br>&ensp;&ensp;&ensp;&ensp;3）内核支持线程具有很小的数据结构和堆栈，线程的切换比较快，切换开销小；<br>&ensp;&ensp;&ensp;&ensp;4）内核本身也可以采用多线程技术，可以提高系统的执行速度和效率。  </p>
<p>&ensp;&ensp;&ensp;&ensp;缺点：对于用户的线程切换而言，其切换的开销较大，在同一个进程中，从一个线程切换到另一个线程时，需要从用户态转到内核态进行。这是因为用户进程的线程在用户态运行，而线程调度和管理在内核实现，系统开销较大。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.用户级线程ULT（User Level Threads）</strong>    </p>
<p>&ensp;&ensp;&ensp;用户级线程ULT(User Level Threads)仅存在于用户空间中。对于这种线程的创建、撤销、线程之间的同步与通信等功能，都无须利用系统调用来实现。线程的管理由应用程序完成，在用户空间中实现，内核无需感知线程的存在。<br>&ensp;&ensp;&ensp;对于用户级线程的切换，通常发生在一个应用进程的诸多线程之间，这时，也同样无须内核的支持。  </p>
<p>&ensp;&ensp;&ensp;&ensp;优点：<br>&ensp;&ensp;&ensp;&ensp;1）线程切换不需要转换到内核空间；<br>&ensp;&ensp;&ensp;&ensp;2）调度算法可以是线程专用的；<br>&ensp;&ensp;&ensp;&ensp;3）用户级线程的实现与操作系统平台无关；  </p>
<p>&ensp;&ensp;&ensp;&ensp;缺点：<br>&ensp;&ensp;&ensp;&ensp;1）系统调用的阻塞问题。用户级线程执行系统调用时，不仅该线程阻塞，而且进程内的所有线程都会阻塞，而内核支持线程方式中，进程中的其它线程仍然可以运行；<br>&ensp;&ensp;&ensp;&ensp;2）单纯的用户级线程实现方式中，多线程应用不能利用多处理机进行多重处理的优点。内核每次分配给进程的只有一个CPU，因此进程中仅有一个线程能执行。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8724.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3.组合方式</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;在该方式中，内核支持多个内核支持线程的建立，调度和管理，同时，也允许用户应用程序建立，调度和管理用户级线程。线程的创建是在用户层进行线程的调度和同步在用户层进行选择一部分用户级线程映射到一些内核级线程上。<br>&ensp;&ensp;&ensp;&ensp;它能够结合KST和ULT两者的优点，并克服了各自的不足。  </p>
<p>&ensp;&ensp;&ensp;&ensp;三种不同模型：<br>&ensp;&ensp;&ensp;&ensp;（1）多对一模型。即将多个用户线程映射到一个内核控制线程。这些用户线程一般属于一个进程，运行在该进程的用户空间，对这些线程的调度和管理也是在该进程的用户空间完成。仅当用户线程需要访问内核时，才将其映射到内核线程，每次只允许一个线程进行映射。<br>&ensp;&ensp;&ensp;&ensp;（2）一对一模型。即将每个用户线程映射到一个内核控制线程。当一个线程阻塞时允许另一个线程运行。此外，它允许多个线程并行运行在多处理机系统中。<br>&ensp;&ensp;&ensp;&ensp;（3）多对多模型。将多个用户线程映射到同样数量或更少数量的内核线程上。结合了上述两种模型的优点。  </p>
<h3 id="2-8-2-线程的实现"><a href="#2-8-2-线程的实现" class="headerlink" title="2.8.2 线程的实现"></a>2.8.2 线程的实现</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.内核支持线程的实现</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;在仅设置了内核支持线程的OS中，一种可能的线程控制方法是，系统在创建一个进程时，便为它分配一个任务数据区PTDA（Per Task Data Area）其中包括若干个线程控制块TCB。TCB中可保存线程标识符、优先级、线程运行的CPU状态等信息。这些信息是被保存在内核空间中的。<br>&ensp;&ensp;&ensp;&ensp;之后对线程的创建、撤销均与进程的相类似；<br>&ensp;&ensp;&ensp;&ensp;内核支持线程的调度和切换与进程的调度和切换也类似  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.用户级线程的实现</strong>    </p>
<p>&ensp;&ensp;&ensp;&ensp;用户级线程是在用户空间实现的。所有的用户级线程都具有相同的结构，它们都运行在一个中间系统的上面。<br>&ensp;&ensp;&ensp;&ensp;1）运行时系统：实质上是用于管理和控制线程的函数（过程）的集合，其中包括用于创建和撤销线程的函数、线程同步和通信的函数以及实现线程调度的函数等。<br>&ensp;&ensp;&ensp;&ensp;运行时系统的所有函数都驻留在用户空间，作为用户级线程和内核之间的接口。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8725.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;2）内核控制线程（组合方式）：这种线程又称为轻型进程LWP（Light Weight Process）。每一个进程都可拥有多个LWP，每个LWP都有自己的数据结构（如TCB）。LWP可以通过系统调用来获得内核提供的服务。<br><img src="/2021/05/08/os-2/%E5%9B%BE%E7%89%8726.png">   </p>
<h3 id="2-8-3-线程的创建和终止"><a href="#2-8-3-线程的创建和终止" class="headerlink" title="2.8.3 线程的创建和终止"></a>2.8.3 线程的创建和终止</h3><p>&ensp;&ensp;&ensp;&ensp;<strong>1.线程的创建</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;应用程序在启动时，通常仅有一个线程在执行，人们把线程称为“初始化线程”，它的主要功能是用于创建新线程。在创建新线程时，需要利用一个线程创建函数（或系统调用），并提供相应的参数。创建函数执行完成后，返回一个线程标识符供以后使用。  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2.线程的终止</strong>   </p>
<p>&ensp;&ensp;&ensp;&ensp;当一个线程完成了自己的任务后，或是线程在运行中出现异常情况而须被强行终止时，由终止线程通过调用相应的函数对它执行终止操作。在大多数OS中，线程被中止后并不立即释放它所占有的资源，只有当进程中的其它线程执行了分离函数后，被终止的线程才与资源分离，此时的资源才能被其它线程利用。<br>&ensp;&ensp;&ensp;&ensp;虽已被终止但尚未释放资源的线程，仍可以被需要它的线程所调用，以使被终止线程重新恢复运行。为此，调用者线程须调用一条被称为“等待线程终止”的连接命令，来与该线程进行连接。如果在一个调用者线程调用“等待线程终止”的连接命令试图与指定线程相连接时，若指定线程尚未被终止，则调用连接命令的线程将会阻塞，直至指定线程被终止后才能实现它与调用者线程的连接并继续执行；若指定线程已被终止，则调用者线程不会被阻塞而是继续执行。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记——第三章（绝赞更新中）</title>
    <url>/2021/05/09/os-3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>个人操作系统笔记整理，欢迎参考，时不时更新。  </p>
<span id="more"></span>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>课堂笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实验课作业四——动态分区内存管理</title>
    <url>/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&ensp;&ensp;&ensp;&ensp;用C语言模拟动态分区分配算法。本篇实验报告用于上交期末课程作业，图文请勿抄袭，谢谢配合。一经发现，必定追究。</p>
<span id="more"></span>

<h1 id="一、实验目的及要求"><a href="#一、实验目的及要求" class="headerlink" title="一、实验目的及要求"></a>一、实验目的及要求</h1><p>&ensp;&ensp;&ensp;&ensp;本实验要求用高级语言编写模拟内存的动态分区分配和回收算法（不考虑紧凑），以便加深理解。<br>&ensp;&ensp;&ensp;&ensp;1.分配：实现首次适应算法（FF）、循环首次适应算法(NF)、最佳适应算法（BF），最坏适应算法(WF)的具体实现。<br>&ensp;&ensp;&ensp;&ensp;2.空闲分区的回收，需考虑合并问题。  </p>
<h1 id="二、基本理论介绍"><a href="#二、基本理论介绍" class="headerlink" title="二、基本理论介绍"></a>二、基本理论介绍</h1><h2 id="2-1-动态分区分配"><a href="#2-1-动态分区分配" class="headerlink" title="2.1 动态分区分配"></a>2.1 动态分区分配</h2><p> &ensp;&ensp;&ensp;&ensp;动态分区是指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。<br> &ensp;&ensp;&ensp;&ensp;动态分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分。这种存储管理技术是固定式分区的改进，既可以获得较大的灵活性，又能提高内存的利用率。<br> &ensp;&ensp;&ensp;&ensp;特点：分区的大小是可变的，分区的数目也是可变的。  </p>
<h2 id="2-2-空闲分区表"><a href="#2-2-空闲分区表" class="headerlink" title="2.2 空闲分区表"></a>2.2 空闲分区表</h2><p>&ensp;&ensp;&ensp;&ensp;空闲分区表为每个尚未分配的分区设置一个表项，包括分区的序号、大小、始址和状态。如下表：  </p>
<table>
<thead>
<tr>
<th>序号</th>
<th>大小</th>
<th>起址</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>48k</td>
<td>116k</td>
<td>空闲</td>
</tr>
<tr>
<td>2</td>
<td>252k</td>
<td>260k</td>
<td>空闲</td>
</tr>
</tbody></table>
<h2 id="2-3-空闲分区链"><a href="#2-3-空闲分区链" class="headerlink" title="2.3 空闲分区链"></a>2.3 空闲分区链</h2><p>&ensp;&ensp;&ensp;&ensp;为了实现对空闲分区的分配和链接，在每个分区的起始部分，设置一些用于控制分区分配的信息以及用于链接其它分区的前向指针；在分区尾部，则设置了一个后向指针。通过前、后向指针将所有的分区链接成一个双向链表。</p>
<h2 id="2-4-所涉及到的各个算法"><a href="#2-4-所涉及到的各个算法" class="headerlink" title="2.4 所涉及到的各个算法"></a>2.4 所涉及到的各个算法</h2><p><strong>1）首次适应算法（FF）</strong><br>&ensp;&ensp;&ensp;&ensp;空闲分区表(链)按低址―&gt;高址链接；<br>&ensp;&ensp;&ensp;&ensp;从表首顺序查找，找到第一个适合的空闲区，从该分区划出适当空间分配给请求者，余下的空闲分区更新数据后，仍然留空闲分区表(链)中。<br>&ensp;&ensp;&ensp;&ensp;回收过程：若有相邻空闲区，则合并；否则，将释放区按首地址升序的规则插入到空闲区表适当的位置。  </p>
<p>&ensp;&ensp;&ensp;&ensp;优点：<br>&ensp;&ensp;&ensp;&ensp;保留高地址大空闲区，利于大作业。<br>&ensp;&ensp;&ensp;&ensp;缺点：<br>&ensp;&ensp;&ensp;&ensp;a）容易产生碎片；<br>&ensp;&ensp;&ensp;&ensp;b）低地址端过多小空闲区，增加查找开销  </p>
<p><strong>2）循环首次适应算法(NF)</strong><br>&ensp;&ensp;&ensp;&ensp;按地址递增的顺序链接，从上一次分配的下一个地址开始查找，找到第一个适合的空闲区。划出适当空间分配给请求者，余下的空闲分区更新数据后，仍然留空闲分区表(链)中。</p>
<p>&ensp;&ensp;&ensp;&ensp;优点：使存储空间更均衡，便于查找<br>&ensp;&ensp;&ensp;&ensp;缺点：缺乏大的空闲分区，不利于大作业。  </p>
<p><strong>3）最佳适应算法（BF）</strong><br>&ensp;&ensp;&ensp;&ensp;以容量递增的次序链接，从表(链)首开始顺序查找，直到找到第一个适合的空闲分区。若该空闲区大于作业，则划出适当空间分配出去，剩余空闲区仍留在空闲分区表(链)中。</p>
<p>&ensp;&ensp;&ensp;&ensp;优点：找到的空闲区总既满足要求又是最小的。<br>&ensp;&ensp;&ensp;&ensp;缺点：留下较小的无法利用的外碎片。</p>
<p><strong>4）最坏适应算法(WF)</strong><br>&ensp;&ensp;&ensp;&ensp;要求空闲分区按容量递减排列，从表(链)首开始顺序查找，若第一个表目都不能满足要求，分配失败，否则，划出适当分区给申请者，剩余空闲区插入空闲区表适当位置。  </p>
<p>&ensp;&ensp;&ensp;&ensp;优点：基本不留小分区<br>&ensp;&ensp;&ensp;&ensp;缺点：较大的空闲分区不被保留。  </p>
<h1 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h1><p>&ensp;&ensp;&ensp;&ensp;本实验主要针对操作系统中内存管理相关理论进行实验，要求实验者编写一个程序，该程序管理一块虚拟内存，实现内存分配和回收功能  </p>
<p>&ensp;&ensp;&ensp;&ensp;（1）设计内存分配的数据结构（空闲分区表/空闲分区链），模拟管理64M的内存块；<br>&ensp;&ensp;&ensp;&ensp;（2）设计内存分配函数；<br>&ensp;&ensp;&ensp;&ensp;（3）设计内存回收函数；<br>&ensp;&ensp;&ensp;&ensp;（4）实现动态分配和回收操作；<br>&ensp;&ensp;&ensp;&ensp;（5）可动态显示每个内存块信息。  </p>
<h1 id="四、功能实现"><a href="#四、功能实现" class="headerlink" title="四、功能实现"></a>四、功能实现</h1><h2 id="4-1-设计内存分配的数据结构"><a href="#4-1-设计内存分配的数据结构" class="headerlink" title="4.1 设计内存分配的数据结构"></a>4.1 设计内存分配的数据结构</h2><p> <strong>1）定义空闲分区表</strong><br>&ensp;&ensp;&ensp;&ensp;由空闲分区表的定义可知，该数据结构包含以下几项：分区的序号、大小、始址和状态。<br>&ensp;&ensp;&ensp;&ensp;在程序中定义如下所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%88%86%E5%8C%BA%E8%A1%A8.png"> </p>
<p>&ensp;&ensp;&ensp;&ensp;其中id表示序号，base表示该分区的起始地址，size表示该分区的起始地址，status表示该分区的状态，用-1表示该分区空闲。<br><strong>2）定义空闲分区链</strong><br>&ensp;&ensp;&ensp;&ensp;由空闲分区链的定义可知，该数据结构包含以下几项：前向指针、后向指针，指向该分区块的指针（即能够包含该节点指向的分区块的信息）。空闲分区链图示如下：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9B%BE%E7%89%8713.png">  </p>
<p>在程序中定义如下：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%88%86%E5%8C%BA%E9%93%BE.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;其中，node指向该分区，包含该分区的信息，front和next分别为前向指针和后向指针。</p>
<h2 id="4-2-实现内存分配函数"><a href="#4-2-实现内存分配函数" class="headerlink" title="4.2 实现内存分配函数"></a>4.2 实现内存分配函数</h2><p><strong>1）首次适应算法（FF）</strong><br>&ensp;&ensp;&ensp;&ensp;根据首次适应算法的思想，程序实现的流程图如下所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/ff%E6%B5%81%E7%A8%8B%E5%9B%BE.png"> </p>
<p>&ensp;&ensp;&ensp;&ensp;首先从已建立好的数组中顺序查找，直至找到第一个大小能满足的空闲分区为止，然后按照作业大小，从该分区中划出一块内存空间分配给请求者，余下的空间开辟一块新的地址，大小为原来的大小减去作业大小，若查找结束都不能找到一个满足要求的分区，则此次内存分配失败。</p>
<p><strong>2）循环首次适应算法（NF）</strong><br>&ensp;&ensp;&ensp;&ensp;根据循环首次适应算法的思想，程序实现的流程图如下所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/nf%E6%B5%81%E7%A8%8B%E5%9B%BE.png">   </p>
<p>&ensp;&ensp;&ensp;&ensp;在为进程分配内存空间时，从上次找到的空闲分区的下一个空闲分区开始查找，直至找到第一个能满足要求的空闲分区，从中划出一块与请求大小相等的内存空间分配给作业。具体实现本算法时，除了将首次适应算法的开始地址从第一个空闲区的起始地址变为上次找到的空闲区的下个地址外，还要设置一个标志量，只有当全部空闲区都查找完毕，仍旧找不到一个满足要求的分区时，此次内存才分配失败。</p>
<p><strong>3）最佳适应算法（BF）</strong><br>&ensp;&ensp;&ensp;&ensp;根据最佳适应算法的思想，程序实现的流程图如下所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/bf%E6%B5%81%E7%A8%8B%E5%9B%BE.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;当使用最佳适应算法分配时，先遍历一遍空闲区，将大于作业大小的空闲区放入数组，取出其中最小的分区，从中划出一块与作业大小相等的空间分配给该作业。</p>
<p><strong>4）最坏适应算法(WF)</strong><br>&ensp;&ensp;&ensp;&ensp;根据最坏适应算法的思想，程序实现的流程图如下所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/wf%E6%B5%81%E7%A8%8B%E5%9B%BE.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;和最佳适应算法相类似，同样是在分配前先遍历一遍空闲区，找出大于该作业大小的空闲区，并将其放入数组，在其中取出空间最大的分区，从中划出一块与作业大小相等的空间分配给该作业。</p>
<h2 id="4-3-实现内存分配回收功能"><a href="#4-3-实现内存分配回收功能" class="headerlink" title="4.3 实现内存分配回收功能"></a>4.3 实现内存分配回收功能</h2><p>&ensp;&ensp;&ensp;&ensp;内存分配回收有四种情况，前一个分区空闲后一个分区不空闲，前一个分区不空闲后一个分区空闲，前后分区都不空闲，前后分区都空闲。可以将其合并为两种情况，即如果回收分区不是最后一个分区并且后一个分区空闲，则与后一个分区合并（前一个分区不空闲后一个分区空闲，前后分区都空闲），如果分区不是第一个空闲分区且前一个分区为空闲，则与前一个分区合并（前一个分区空闲后一个分区不空闲，前后分区都空闲）。<br>&ensp;&ensp;&ensp;&ensp;根据该思路的内存回收策略流程图如下所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;在程序中用四个if语句实现该流程图，除了上面提到的两种分类方式外，还需要特判该分区号的存在与否和该分区是否已被分配。</p>
<h1 id="五、结果测试与分析"><a href="#五、结果测试与分析" class="headerlink" title="五、结果测试与分析"></a>五、结果测试与分析</h1><h2 id="5-1-测试数据的选取"><a href="#5-1-测试数据的选取" class="headerlink" title="5.1 测试数据的选取"></a>5.1 测试数据的选取</h2><table>
<thead>
<tr>
<th>序号</th>
<th>操作</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Req</td>
<td>40M</td>
</tr>
<tr>
<td>2</td>
<td>Req</td>
<td>10M</td>
</tr>
<tr>
<td>3</td>
<td>Release</td>
<td>40M</td>
</tr>
<tr>
<td>4</td>
<td>Req</td>
<td>12M</td>
</tr>
<tr>
<td>5</td>
<td>Req</td>
<td>8M</td>
</tr>
<tr>
<td>6</td>
<td>Req</td>
<td>6M</td>
</tr>
<tr>
<td>7</td>
<td>Req</td>
<td>4M</td>
</tr>
<tr>
<td>8</td>
<td>Release</td>
<td>6M</td>
</tr>
</tbody></table>
<p>&ensp;&ensp;&ensp;&ensp;选取以上八个操作作为测试数据，来检验代码能否正确采取某一种分配策略和回收内存。下面依次将各个算法的运行结果与应得的结果进行比较。</p>
<h2 id="5-2-结果比较与分析"><a href="#5-2-结果比较与分析" class="headerlink" title="5.2 结果比较与分析"></a>5.2 结果比较与分析</h2><p><strong>1）首次适应算法</strong><br>&ensp;&ensp;&ensp;&ensp;由首次适应算法的思想，测试案例各个步骤在系统内如下所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/FF%E7%B3%BB%E7%BB%9F.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;即在最后的结果中，系统一共有7个区块，其中0-12M为12M大小的作业区，12-20M为8M大小的作业区，20-26M为6M大小的空闲区，26-30M为4M大小的作业区，30-40M为10M大小的空闲区，40-50M为10M大小的作业区，50-64M为14M大小的空闲区。<br>&ensp;&ensp;&ensp;&ensp;将相应数据输入到程序中，得到结果如下图所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/FF%E7%BB%93%E6%9E%9C%E5%9B%BE.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;可以看到内存分配策略和回收的功能都可以正确执行，程序最后得到的结果与预先得到的结果相一致，说明实验正确。</p>
<p><strong>2）循环首次适应算法</strong><br>&ensp;&ensp;&ensp;&ensp;由循环首次适应算法的思想，测试案例各个步骤在系统内如下所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/NF%E7%B3%BB%E7%BB%9F.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;即在最后的结果中，系统一共有7个区块，其中0-8M为8M大小的作业区，8-14M为6M大小的空闲区，14-18M为4M大小的作业区，18-40M为22M大小的空闲区，40-50M为10M大小的作业区，50-62M为12M大小的空闲区。<br>&ensp;&ensp;&ensp;&ensp;用该算法将相应数据输入到程序中，得到结果如下：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/BF%E7%BB%93%E6%9E%9C%E5%9B%BE.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;同样将该结果与预先得到的结果进行比较，发现能够得到理想的结果。</p>
<p><strong>3）最佳适应算法</strong><br>&ensp;&ensp;&ensp;&ensp;由最佳适应算法的思想，测试案例各个步骤在系统内如下所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/BF%E7%B3%BB%E7%BB%9F.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;即在最后的结果中，系统一共有7个区块，其中0-8M为8M大小的作业区，8-14M为6M大小的空闲区，14-18M为4M大小的作业区，18-40M为22M大小的空闲区，40-50M为10M大小的作业区，50-62M为12M大小的空闲区。<br>&ensp;&ensp;&ensp;&ensp;用该算法将相应数据输入到程序中，得到结果如下：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/BF%E7%BB%93%E6%9E%9C%E5%9B%BE.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;同样将该结果与预先得到的结果进行比较，发现能够得到理想的结果，并且发现该结果与循环首次适应算法得到的结果相同，于是重复多次修改了案例，也能得到正确的结果，证明实验是可行的。</p>
<p><strong>4）最坏适应算法</strong><br>&ensp;&ensp;&ensp;&ensp;由最坏适应算法的思想，测试案例各个步骤在系统内如下所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/FF%E7%B3%BB%E7%BB%9F.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;即在最后的结果中，系统一共有7个区块，其中0-12M为12M大小的作业区，12-20M为8M大小的作业区，20-26M为6M大小的空闲区，26-30M为4M大小的作业区，30-40M为10M大小的空闲区，40-50M为10M大小的作业区，50-64M为14M大小的空闲区。<br>&ensp;&ensp;&ensp;&ensp;将相应数据输入到程序中，得到结果如下图所示：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/WF%E7%BB%93%E6%9E%9C%E5%9B%BE.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;发现在该组测试样例下，得到的结果与首次适应算法相一致，尝试在原本的测试样例上再多加入一个5M大小的请求，由于最坏适应算法优先寻找最大的空闲区，所以会在最后一块（即大小为14M）的空闲区划分出相应大小的区域，而首次适应算法会将其分配于最前面，（即大小为6M）的空闲区。加入测试样例后，WF算法得到结果如下：<br><img src="/2021/05/22/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/WF%E7%BB%93%E6%9E%9C%E5%9B%BE2.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;得到的结果与由该算法思想得到的结果相一致，说明WF算法可以按照正确的分配策略运行，实验结果理想。</p>
<h1 id="六、心得体会"><a href="#六、心得体会" class="headerlink" title="六、心得体会"></a>六、心得体会</h1><p>&ensp;&ensp;&ensp;&ensp;本次实验要求模拟动态分区分配算法，在开始该实验前，首先要做的是理解并实现动态分区分配算法所涉及到的数据结构。该种分配方式下主要有空闲分区表和空闲分区链两种数据结构，在程序中前者用于存储各个分区的状态，包括大小，起始地址，序号和该区块空闲与否，后者则用来实现区块的划分和分配。只有理解了数据结构的原理，才能在后续具体的算法实现中，灵活的应用不同的数据结构得到我们想要的功能。<br>&ensp;&ensp;&ensp;&ensp;在各个算法具体实现之前，我结合算法的思想和分配策略，作出了每个算法的流程图，后续的程序都按照流程图的思路来设计，这其中也有不断发现错误返工修改流程图和程序的过程，最终是参考了网上的一些思路，将流程图和程序进行了完善。在具体实现算法时，我先完成了首次适应算法和最佳适应算法，因为循环首次适应算法和最坏适应算法的分配策略与前两者的分配策略相似，在以首次适应和最佳适应为基础框架后，略作修改便能实现循环首次适应算法和最坏适应算法。<br>&ensp;&ensp;&ensp;&ensp;实现资源回收时主要涉及到的问题是分类问题，一开始将情况想的太复杂，对于四个不一样的情况（详情见4.3）都进行特判，导致程序冗杂并且不能正确实现相关功能，后来将其分为两个大类，问题才迎刃而解，这也加深了我对算法的应用，以及资源回收及合并的理解。<br>&ensp;&ensp;&ensp;&ensp;在最后的结果测试方面，为了体现出各个算法分配策略的不同，我作出了系统中不同算法的图示，但由于测试所用的数据是根据作业4略作修改得来的，因此在实际的执行过程中，发现最坏适应算法和首次适应算法得到的结果相一致，为了体现出这两种算法分配策略的区别，我在使用最坏适应算法的程序样例中多加了一个测试点，发现能够得到理想的结果，后续修改多组数据进行测试也能得到正确的结果，说明该实验是成功的。<br>&ensp;&ensp;&ensp;&ensp;本次实验中，我对各个分配算法有了更加深刻的认识，加深了对算法的应用和技巧，在探索的过程中也加强了自主学习的能力和兴趣。</p>
<h1 id="七、附录代码"><a href="#七、附录代码" class="headerlink" title="七、附录代码"></a>七、附录代码</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lei_item</span>       </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> id;                </span><br><span class="line">	<span class="keyword">int</span> base;              </span><br><span class="line">	<span class="keyword">int</span> size;              </span><br><span class="line">	<span class="keyword">int</span> status;             </span><br><span class="line">&#125;Item;</span><br><span class="line"><span class="keyword">typedef</span> Item datatype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lei_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	datatype* node;      </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lei_list</span>* <span class="title">front</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lei_list</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;List;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max 64</span></span><br><span class="line"><span class="keyword">int</span> memory = Max;       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">init</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">	List <span class="built_in">list</span>;</span><br><span class="line">	<span class="built_in">list</span>.node = (datatype *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(datatype));</span><br><span class="line">	<span class="built_in">list</span>.node-&gt;base = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">list</span>.node-&gt;id = <span class="number">-1</span>;                    </span><br><span class="line">	<span class="built_in">list</span>.node-&gt;size = memory;</span><br><span class="line">	<span class="built_in">list</span>.node-&gt;status = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">list</span>.front = <span class="built_in">list</span>.next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">datatype* <span class="title">input</span><span class="params">()</span> </span>&#123;          </span><br><span class="line">	datatype* item = (datatype *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(datatype));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入作业号：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;item-&gt;id);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入所需要的内存的大小：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;item-&gt;size);</span><br><span class="line">	item-&gt;status = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Momery_state</span><span class="params">(List *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">	List* temp = <span class="built_in">list</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-----------------------------------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;内存分配状况\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-----------------------------------\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (temp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (temp-&gt;node-&gt;status == <span class="number">0</span> &amp;&amp; temp-&gt;node-&gt;id == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;分区号：0\n&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;起始地址：%d\n&quot;</span>, temp-&gt;node-&gt;base);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;内存大小：%d\n&quot;</span>, temp-&gt;node-&gt;size);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;分区状态：空闲\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;分区号：%d\t起始地址：%d\n&quot;</span>, temp-&gt;node-&gt;id, temp-&gt;node-&gt;base);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;内存大小：%d\n&quot;</span>, temp-&gt;node-&gt;size);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;分区状态：已分配\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-----------------------------------\n&quot;</span>);</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">First_fit</span><span class="params">(List *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">	datatype* item = input();</span><br><span class="line">	List* temp = <span class="built_in">list</span>;                     </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (temp)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (temp-&gt;node-&gt;status == <span class="number">0</span> &amp;&amp; temp-&gt;node-&gt;size &gt; item-&gt;size) &#123;       </span><br><span class="line">			List *front = temp-&gt;front;                                         </span><br><span class="line">			List *next = temp-&gt;next;                                            </span><br><span class="line">			<span class="keyword">int</span> base = temp-&gt;node-&gt;base;                                     </span><br><span class="line"></span><br><span class="line">			datatype* new_node = (datatype*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(datatype));        </span><br><span class="line">			new_node-&gt;id = <span class="number">-1</span>;                                                </span><br><span class="line">			new_node-&gt;size = temp-&gt;node-&gt;size - item-&gt;size;         </span><br><span class="line"></span><br><span class="line">			temp-&gt;node = item;                                </span><br><span class="line">			temp-&gt;node-&gt;status = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			new_node-&gt;status = <span class="number">0</span>;</span><br><span class="line">			new_node-&gt;base = base + temp-&gt;node-&gt;size;             </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			List* temp_next = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));           </span><br><span class="line">			temp_next-&gt;node = new_node;                             </span><br><span class="line">			temp_next-&gt;front = temp_next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (front == <span class="literal">NULL</span> &amp;&amp; next == <span class="literal">NULL</span>) &#123;                      </span><br><span class="line">				temp-&gt;node-&gt;base = <span class="number">0</span>;                               </span><br><span class="line">				temp-&gt;next = temp_next;</span><br><span class="line">				temp_next-&gt;front = temp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (front == <span class="literal">NULL</span> &amp;&amp; next != <span class="literal">NULL</span>) &#123;                 </span><br><span class="line">				temp-&gt;node-&gt;base = <span class="number">0</span>;</span><br><span class="line">				temp-&gt;node-&gt;status = <span class="number">1</span>;</span><br><span class="line">				temp_next-&gt;next = temp-&gt;next;</span><br><span class="line">				temp-&gt;next = temp_next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (front != <span class="literal">NULL</span>) &#123;                      </span><br><span class="line">				temp-&gt;node-&gt;base = temp-&gt;front-&gt;node-&gt;base + temp-&gt;front-&gt;node-&gt;size;       </span><br><span class="line">				temp_next-&gt;next = temp-&gt;next;                                       </span><br><span class="line">				temp_next-&gt;front = temp;                            </span><br><span class="line">				temp-&gt;next = temp_next;                             </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (temp-&gt;node-&gt;status == <span class="number">0</span> &amp;&amp; temp-&gt;node-&gt;size == item-&gt;size)</span><br><span class="line">		&#123;</span><br><span class="line">			item-&gt;base = temp-&gt;front-&gt;node-&gt;base + temp-&gt;front-&gt;node-&gt;size;               </span><br><span class="line">			item-&gt;status = <span class="number">1</span>;                                           </span><br><span class="line">			temp-&gt;node = item;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">next_fit</span><span class="params">(List *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">	datatype* item = input();</span><br><span class="line">	List* temp = <span class="built_in">list</span>;                      </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (temp)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (temp-&gt;node-&gt;status == <span class="number">0</span> &amp;&amp; temp-&gt;node-&gt;size &gt; item-&gt;size) &#123;       </span><br><span class="line">			List *front = temp-&gt;front;                                         </span><br><span class="line">			List *next = temp-&gt;next;                                            </span><br><span class="line">			<span class="keyword">int</span> base = temp-&gt;node-&gt;base;                                     </span><br><span class="line"></span><br><span class="line">			datatype* new_node = (datatype*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(datatype));          </span><br><span class="line">			new_node-&gt;id = <span class="number">-1</span>;                                                 </span><br><span class="line">			new_node-&gt;size = temp-&gt;node-&gt;size - item-&gt;size;         </span><br><span class="line"></span><br><span class="line">			temp-&gt;node = item;                                 </span><br><span class="line">			temp-&gt;node-&gt;status = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			new_node-&gt;status = <span class="number">0</span>;</span><br><span class="line">			new_node-&gt;base = base + temp-&gt;node-&gt;size;            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			List* temp_next = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));           </span><br><span class="line">			temp_next-&gt;node = new_node;                             </span><br><span class="line">			temp_next-&gt;front = temp_next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">   </span><br><span class="line">			<span class="keyword">if</span> (front == <span class="literal">NULL</span> &amp;&amp; next == <span class="literal">NULL</span>) &#123;                      </span><br><span class="line">				temp-&gt;node-&gt;base = <span class="number">0</span>;                              </span><br><span class="line">				temp-&gt;next = temp_next;</span><br><span class="line">				temp_next-&gt;front = temp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (front == <span class="literal">NULL</span> &amp;&amp; next != <span class="literal">NULL</span>) &#123;                </span><br><span class="line">				temp-&gt;node-&gt;base = <span class="number">0</span>;</span><br><span class="line">				temp-&gt;node-&gt;status = <span class="number">1</span>;</span><br><span class="line">				temp_next-&gt;next = temp-&gt;next;</span><br><span class="line">				temp-&gt;next = temp_next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (front != <span class="literal">NULL</span>) &#123;                      </span><br><span class="line">				temp-&gt;node-&gt;base = <span class="number">0</span>;									</span><br><span class="line">				temp_next-&gt;next = temp-&gt;next;                               </span><br><span class="line">				temp_next-&gt;front = temp;                              </span><br><span class="line">				temp-&gt;next = temp_next;                             </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (temp-&gt;node-&gt;status == <span class="number">0</span> &amp;&amp; temp-&gt;node-&gt;size == item-&gt;size)</span><br><span class="line">		&#123;</span><br><span class="line">			item-&gt;base = temp-&gt;front-&gt;node-&gt;base + temp-&gt;front-&gt;node-&gt;size;            </span><br><span class="line">			item-&gt;status = <span class="number">1</span>;                                          </span><br><span class="line">			temp-&gt;node = item;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Momory_recycle</span><span class="params">(List *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">	List* temp = <span class="built_in">list</span>;                      </span><br><span class="line">	<span class="keyword">int</span> number;                         </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入需要回收的ID号：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line">	<span class="keyword">while</span> (temp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (temp-&gt;node-&gt;id == number)             </span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (temp-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">				temp-&gt;node-&gt;status = <span class="number">0</span>;</span><br><span class="line">				temp-&gt;node-&gt;id = <span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">if</span> (temp-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">					temp-&gt;node-&gt;size = temp-&gt;node-&gt;size + temp-&gt;next-&gt;node-&gt;size;</span><br><span class="line">					temp-&gt;next = temp-&gt;next;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (temp-&gt;next-&gt;node-&gt;id == <span class="number">-1</span> &amp;&amp; temp-&gt;next-&gt;node-&gt;status == <span class="number">0</span>) &#123;</span><br><span class="line">					List* next = temp-&gt;next; </span><br><span class="line">					temp-&gt;node-&gt;size = temp-&gt;node-&gt;size + next-&gt;node-&gt;size;</span><br><span class="line">					temp-&gt;node-&gt;status = <span class="number">0</span>;</span><br><span class="line">					temp-&gt;node-&gt;id = <span class="number">-1</span>;</span><br><span class="line">					temp-&gt;next = next-&gt;next;</span><br><span class="line">					<span class="keyword">if</span> (next-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">						<span class="built_in">free</span>(next);</span><br><span class="line">						<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						next-&gt;next-&gt;front = temp;</span><br><span class="line">						<span class="built_in">free</span>(next);</span><br><span class="line">						<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="keyword">if</span> (temp-&gt;front-&gt;node-&gt;id != <span class="number">-1</span> &amp;&amp; temp-&gt;front-&gt;node-&gt;status != <span class="number">0</span> &amp;&amp; temp-&gt;next-&gt;node-&gt;id != <span class="number">-1</span> &amp;&amp; temp-&gt;next-&gt;node-&gt;status != <span class="number">0</span>) &#123;</span><br><span class="line">				temp-&gt;node-&gt;status = <span class="number">0</span>;</span><br><span class="line">				temp-&gt;node-&gt;id = <span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp-&gt;front-&gt;node-&gt;id == <span class="number">-1</span> &amp;&amp; temp-&gt;front-&gt;node-&gt;status == <span class="number">0</span> &amp;&amp; temp-&gt;next-&gt;node-&gt;id == <span class="number">-1</span> &amp;&amp; temp-&gt;next-&gt;node-&gt;status == <span class="number">0</span>) &#123;</span><br><span class="line">				List* front = temp-&gt;front;</span><br><span class="line">				List* next = temp-&gt;next;</span><br><span class="line">				front-&gt;node-&gt;size = front-&gt;node-&gt;size + temp-&gt;node-&gt;size + next-&gt;node-&gt;size;</span><br><span class="line">				front-&gt;next = next-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (next-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">					<span class="built_in">free</span>(temp);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line"></span><br><span class="line">					next-&gt;next-&gt;front = front;</span><br><span class="line">					<span class="built_in">free</span>(temp);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (temp-&gt;front-&gt;node-&gt;id == <span class="number">-1</span> &amp;&amp; temp-&gt;front-&gt;node-&gt;status == <span class="number">0</span>) &#123;</span><br><span class="line">				List* front = temp-&gt;front;</span><br><span class="line">				front-&gt;next = temp-&gt;next;</span><br><span class="line">				temp-&gt;next-&gt;front = front;</span><br><span class="line">				front-&gt;node-&gt;size += temp-&gt;node-&gt;size;</span><br><span class="line">				<span class="built_in">free</span>(temp);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (temp-&gt;next-&gt;node-&gt;id == <span class="number">-1</span> &amp;&amp; temp-&gt;next-&gt;node-&gt;status == <span class="number">0</span>) &#123;</span><br><span class="line">				List* next = temp-&gt;next;</span><br><span class="line">				temp-&gt;node-&gt;size = temp-&gt;node-&gt;size + next-&gt;node-&gt;size;</span><br><span class="line">				temp-&gt;node-&gt;status = <span class="number">0</span>;</span><br><span class="line">				temp-&gt;node-&gt;id = <span class="number">-1</span>;</span><br><span class="line">				temp-&gt;next = next-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (next-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">					<span class="built_in">free</span>(next);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					next-&gt;next-&gt;front = temp;</span><br><span class="line">					<span class="built_in">free</span>(next);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Best_fit</span><span class="params">(List *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> min = <span class="number">0</span>;      </span><br><span class="line">	<span class="keyword">int</span> base_min = <span class="number">0</span>;      </span><br><span class="line">	List* temp = <span class="built_in">list</span>;</span><br><span class="line">	datatype* item = input();             </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (temp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (temp-&gt;node-&gt;status == <span class="number">0</span> &amp;&amp; temp-&gt;node-&gt;id == <span class="number">-1</span> &amp;&amp; temp-&gt;node-&gt;size &gt; item-&gt;size) &#123;</span><br><span class="line">			<span class="keyword">if</span> (min == <span class="number">0</span>) &#123;          </span><br><span class="line">				min = temp-&gt;node-&gt;size;</span><br><span class="line">				base_min = temp-&gt;node-&gt;base;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (temp-&gt;node-&gt;size &lt; min) &#123;     </span><br><span class="line">					min = temp-&gt;node-&gt;size;</span><br><span class="line">					base_min = temp-&gt;node-&gt;base;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (temp-&gt;node-&gt;status == <span class="number">0</span> &amp;&amp; temp-&gt;node-&gt;id == <span class="number">-1</span> &amp;&amp; temp-&gt;node-&gt;size == item-&gt;size) &#123;</span><br><span class="line">			<span class="keyword">int</span> base = temp-&gt;node-&gt;base;</span><br><span class="line">			temp-&gt;node = item;</span><br><span class="line">			temp-&gt;node-&gt;status = <span class="number">1</span>;</span><br><span class="line">			temp-&gt;node-&gt;base = base;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125; </span><br><span class="line">	temp = <span class="built_in">list</span>;</span><br><span class="line">	<span class="keyword">while</span> (temp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (temp-&gt;node-&gt;base == base_min) &#123;</span><br><span class="line"></span><br><span class="line">			datatype* temp_node = (datatype*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(datatype));      </span><br><span class="line">			temp_node-&gt;id = <span class="number">-1</span>;</span><br><span class="line">			temp_node-&gt;status = <span class="number">0</span>;</span><br><span class="line">			temp_node-&gt;base = base_min + item-&gt;size;</span><br><span class="line">			temp_node-&gt;size = temp-&gt;node-&gt;size - item-&gt;size;</span><br><span class="line"></span><br><span class="line">			temp-&gt;node = item;                    </span><br><span class="line">			temp-&gt;node-&gt;base = base_min;</span><br><span class="line">			temp-&gt;node-&gt;status = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			List* temp_list_node = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));         </span><br><span class="line">			temp_list_node-&gt;node = temp_node;</span><br><span class="line">			temp_list_node-&gt;front = temp;</span><br><span class="line">			temp_list_node-&gt;next = temp-&gt;next;</span><br><span class="line">			<span class="keyword">if</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				temp-&gt;next-&gt;front = temp_list_node;</span><br><span class="line">			&#125;</span><br><span class="line">			temp-&gt;next = temp_list_node;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Worst_fit</span><span class="params">(List *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> max = <span class="number">0</span>;       </span><br><span class="line">	<span class="keyword">int</span> base_max = <span class="number">0</span>;      </span><br><span class="line">	List* temp = <span class="built_in">list</span>;</span><br><span class="line">	datatype* item = input();            </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (temp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (temp-&gt;node-&gt;status == <span class="number">0</span> &amp;&amp; temp-&gt;node-&gt;id == <span class="number">-1</span> &amp;&amp; temp-&gt;node-&gt;size &gt; item-&gt;size) &#123;</span><br><span class="line">			<span class="keyword">if</span> (max == <span class="number">0</span>) &#123;         </span><br><span class="line">				max = temp-&gt;node-&gt;size;</span><br><span class="line">				base_max = temp-&gt;node-&gt;base;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (temp-&gt;node-&gt;size &gt; max) &#123;      </span><br><span class="line">					max = temp-&gt;node-&gt;size;</span><br><span class="line">					base_max = temp-&gt;node-&gt;base;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (temp-&gt;node-&gt;status == <span class="number">0</span> &amp;&amp; temp-&gt;node-&gt;id == <span class="number">-1</span> &amp;&amp; temp-&gt;node-&gt;size == item-&gt;size) &#123;</span><br><span class="line">			<span class="keyword">int</span> base = temp-&gt;node-&gt;base;</span><br><span class="line">			temp-&gt;node = item;</span><br><span class="line">			temp-&gt;node-&gt;status = <span class="number">1</span>;</span><br><span class="line">			temp-&gt;node-&gt;base = base;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	temp = <span class="built_in">list</span>;</span><br><span class="line">	<span class="keyword">while</span> (temp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (temp-&gt;node-&gt;base == base_max) &#123;</span><br><span class="line"></span><br><span class="line">			datatype* temp_node = (datatype*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(datatype));     </span><br><span class="line">			temp_node-&gt;id = <span class="number">-1</span>;</span><br><span class="line">			temp_node-&gt;status = <span class="number">0</span>;</span><br><span class="line">			temp_node-&gt;base = base_max + item-&gt;size;</span><br><span class="line">			temp_node-&gt;size = temp-&gt;node-&gt;size - item-&gt;size;</span><br><span class="line"></span><br><span class="line">			temp-&gt;node = item;                         </span><br><span class="line">			temp-&gt;node-&gt;base = base_max;</span><br><span class="line">			temp-&gt;node-&gt;status = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			List* temp_list_node = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));         </span><br><span class="line">			temp_list_node-&gt;node = temp_node;</span><br><span class="line">			temp_list_node-&gt;front = temp;</span><br><span class="line">			temp_list_node-&gt;next = temp-&gt;next;</span><br><span class="line">			<span class="keyword">if</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				temp-&gt;next-&gt;front = temp_list_node;</span><br><span class="line">			&#125;</span><br><span class="line">			temp-&gt;next = temp_list_node;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;分区模拟\n&quot;</span>);</span><br><span class="line">	List <span class="built_in">list</span> = init();</span><br><span class="line">	<span class="keyword">int</span> select;</span><br><span class="line">	<span class="keyword">int</span> insert_state, recycle_state;</span><br><span class="line">	<span class="keyword">int</span> insert_state_best;</span><br><span class="line">	<span class="keyword">int</span> insert_state_worst;</span><br><span class="line">	<span class="keyword">int</span> insert_state_next;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入要进行的操作\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;1-首次适应算法\n2-最佳适应算法\n3-最坏适应算法\n4-循环首次适应算法\n5-内存回收\n6-退出\n&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;select);</span><br><span class="line">		<span class="keyword">switch</span> (select)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:              </span><br><span class="line">			insert_state = First_fit(&amp;<span class="built_in">list</span>);</span><br><span class="line">			<span class="keyword">if</span> (insert_state == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;分配失败\n&quot;</span>);</span><br><span class="line">				Momery_state(&amp;<span class="built_in">list</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;分配成功！\n&quot;</span>);</span><br><span class="line">				Momery_state(&amp;<span class="built_in">list</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;首次适应算法\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:             </span><br><span class="line">			insert_state_best = Best_fit(&amp;<span class="built_in">list</span>);</span><br><span class="line">			<span class="keyword">if</span> (insert_state_best == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;分配成功\n&quot;</span>);</span><br><span class="line">				Momery_state(&amp;<span class="built_in">list</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;最佳适应算法\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;分配失败\n&quot;</span>);</span><br><span class="line">				Momery_state(&amp;<span class="built_in">list</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			insert_state_worst = Worst_fit(&amp;<span class="built_in">list</span>);</span><br><span class="line">			<span class="keyword">if</span> (insert_state_worst == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;分配成功\n&quot;</span>);</span><br><span class="line">				Momery_state(&amp;<span class="built_in">list</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;最坏适应算法\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;分配失败\n&quot;</span>);</span><br><span class="line">				Momery_state(&amp;<span class="built_in">list</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			insert_state_next = next_fit(&amp;<span class="built_in">list</span>);</span><br><span class="line">			<span class="keyword">if</span> (insert_state_next == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;分配成功\n&quot;</span>);</span><br><span class="line">				Momery_state(&amp;<span class="built_in">list</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;循环首次适应算法\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;分配失败\n&quot;</span>);</span><br><span class="line">				Momery_state(&amp;<span class="built_in">list</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:             </span><br><span class="line">			recycle_state = Momory_recycle(&amp;<span class="built_in">list</span>);</span><br><span class="line">			<span class="keyword">if</span> (recycle_state == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;回收成功！\n&quot;</span>);</span><br><span class="line">				Momery_state(&amp;<span class="built_in">list</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;回收失败\n&quot;</span>);</span><br><span class="line">				Momery_state(&amp;<span class="built_in">list</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (select != <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>实验课作业</tag>
      </tags>
  </entry>
  <entry>
    <title>第十一届蓝桥杯C/C++ B组国赛部分题解</title>
    <url>/2021/05/31/lanqiao/</url>
    <content><![CDATA[<p>填空题和部分编程题（因为太菜了，没有全部题目的题解</p>
<span id="more"></span>

<h1 id="试题-A-美丽的-2"><a href="#试题-A-美丽的-2" class="headerlink" title="试题 A: 美丽的 2"></a>试题 A: 美丽的 2</h1><p><strong>【问题描述】</strong><br>小蓝特别喜欢 2，今年是公元 2020 年，他特别高兴。<br>他很好奇，在公元 1 年到公元 2020 年（包含）中，有多少个年份的数位中包含数字 2？</p>
<p>答案：563</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2020</span>; i ++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x = i;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">while</span>(x)&#123;</span><br><span class="line">			<span class="keyword">int</span> t = x % <span class="number">10</span>;</span><br><span class="line">			<span class="keyword">if</span>(t == <span class="number">2</span>)&#123;</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			x /= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag) cnt ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="试题-B-扩散"><a href="#试题-B-扩散" class="headerlink" title="试题 B: 扩散"></a>试题 B: 扩散</h1><p><strong>【问题描述】</strong><br>小蓝在一张无限大的特殊画布上作画。<br>这张画布可以看成一个方格图，每个格子可以用一个二维的整数坐标表示。<br>小蓝在画布上首先点了一下几个点：(0, 0), (2020, 11), (11, 14), (2000, 2000)。<br>只有这几个格子上有黑色，其它位置都是白色的。<br>每过一分钟，黑色就会扩散一点。具体的，如果一个格子里面是黑色，它就会扩散到上、下、左、右四个相邻的格子中，使得这四个格子也变成黑色（如果原来就是黑色，则还是黑色）。<br>请问，经过 2020 分钟后，画布上有多少个格子是黑色的。  </p>
<p>简单的bfs  </p>
<p>答案：20312088</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2500</span>;</span><br><span class="line"><span class="keyword">bool</span> st[<span class="number">8000</span>][<span class="number">8000</span>];</span><br><span class="line">ll res = <span class="number">4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="keyword">int</span> step;</span><br><span class="line">&#125;node[<span class="number">8000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">	<span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">	q.push(&#123;<span class="number">0</span> + N, <span class="number">0</span> + N, <span class="number">0</span>&#125;), q.push(&#123;<span class="number">2020</span> + N, <span class="number">11</span> + N, <span class="number">0</span>&#125;), q.push(&#123;<span class="number">11</span> + N, <span class="number">14</span> + N, <span class="number">0</span>&#125;), q.push(&#123;<span class="number">2000</span> + N, <span class="number">2000</span> + N, <span class="number">0</span>&#125;);</span><br><span class="line">	st[<span class="number">0</span> + N][<span class="number">0</span> + N] = <span class="literal">true</span>;</span><br><span class="line">	st[<span class="number">2020</span> + N][<span class="number">11</span> + N] = <span class="literal">true</span>;</span><br><span class="line">	st[<span class="number">11</span> + N][<span class="number">14</span> + N] = <span class="literal">true</span>;</span><br><span class="line">	st[<span class="number">2000</span> + N][<span class="number">2000</span> + N] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">		Node t = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span>(t.step == <span class="number">2020</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )&#123;</span><br><span class="line">			<span class="keyword">int</span> a = t.x + dx[i];</span><br><span class="line">			<span class="keyword">int</span> b = t.y + dy[i];</span><br><span class="line">			<span class="keyword">if</span>(st[a][b]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				st[a][b] = <span class="literal">true</span>;</span><br><span class="line">				q.push(&#123;a, b, t.step + <span class="number">1</span>&#125;);</span><br><span class="line">				res ++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	bfs();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-C-阶乘约数"><a href="#试题-C-阶乘约数" class="headerlink" title="试题 C: 阶乘约数"></a>试题 C: 阶乘约数</h1><p><strong>【问题描述】</strong><br>定义阶乘 n! = 1 × 2 × 3 × · · · × n。<br>请问 100! （100 的阶乘）有多少个约数。  </p>
<p>数论问题  </p>
<p>答案：39001250856960000</p>
<p><strong>代码实现：</strong>   </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> minp[N];</span><br><span class="line"><span class="keyword">int</span> primes[N];</span><br><span class="line"><span class="keyword">int</span> st[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> sum[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">			primes[cnt ++] = i;</span><br><span class="line">			minp[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; i * primes[j] &lt;= n; j ++)&#123;</span><br><span class="line">			<span class="keyword">int</span> t = i * primes[j];</span><br><span class="line">			st[t] = <span class="literal">true</span>;</span><br><span class="line">			minp[t] = primes[j];</span><br><span class="line">			<span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ll res;</span><br><span class="line">	get_primes(<span class="number">1000</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">100</span>; i ++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x = i;</span><br><span class="line">		<span class="keyword">while</span>(x &gt; <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> p = minp[x];</span><br><span class="line">			<span class="keyword">while</span>(x % p == <span class="number">0</span>)&#123;</span><br><span class="line">				x /= p;</span><br><span class="line">				sum[p] ++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i ++)</span><br><span class="line">		<span class="keyword">if</span>(sum[i] != <span class="number">0</span>) res *= (<span class="number">1</span> + sum[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, res);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="试题-D-本质上升序列"><a href="#试题-D-本质上升序列" class="headerlink" title="试题 D: 本质上升序列"></a>试题 D: 本质上升序列</h1><p><strong>【问题描述】</strong><br>小蓝特别喜欢单调递增的事物。<br>在一个字符串中,如果取出若干个字符,将这些字符按照在字符串中的顺序排列后是单调递增的,则成为这个字符串中的一个单调递增子序列。<br>例如,在字符串 lanqiao 中,如果取出字符 n 和 q,则 nq 组成一个单调递增子序列。类似的单调递增子序列还有 lnq、i、ano 等等。<br>小蓝发现,有些子序列虽然位置不同,但是字符序列是一样的,例如取第二个字符和最后一个字符可以取到 ao,取最后两个字符也可以取到 ao。小蓝认为他们并没有本质不同。<br>对于一个字符串,小蓝想知道,本质不同的递增子序列有多少个?<br>例如,对于字符串 lanqiao,本质不同的递增子序列有 21 个。它们分别是 l、a、n、q、i、o、ln、an、lq、aq、nq、ai、lo、ao、no、io、lnq、anq、lno、ano、aio。<br>请问对于以下字符串(共 200 个小写英文字母,分四行显示):(如果你把以下文字复制到文本文件中,请务必检查复制的内容是否与文档中的一致。在试题目录下有一个文件 inc.txt,内容与下面的文本相同)<br>tocyjkdzcieoiodfpbgcncsrjbhmugdnojjddhllnofawllbhfiadgdcdjstemphmnjihecoapdjjrprrqnhgccevdarufmliqijgihhfgdcmxvicfauachlifhafpdccfseflcdgjncadfclvfmadvrnaaahahndsikzssoywakgnfjjaihtniptwoulxbaeqkqhfwl<br>本质不同的递增子序列有多少个?  </p>
<p>类似于最长子序列的dp问题  </p>
<p>答案：3616159</p>
<p><strong>代码实现：</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">3000</span>][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">210</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i ++)&#123;</span><br><span class="line">		dp[i][s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i ++)&#123;</span><br><span class="line">		<span class="keyword">int</span> curr = s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; curr; j ++)</span><br><span class="line">			dp[i][curr] += dp[i - <span class="number">1</span>][j];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">26</span>; j ++)</span><br><span class="line">			dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i ++)	res += dp[len][i];</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="试题-E-玩具蛇"><a href="#试题-E-玩具蛇" class="headerlink" title="试题 E: 玩具蛇"></a>试题 E: 玩具蛇</h1><p><strong>【问题描述】</strong><br>小蓝有一条玩具蛇,一共有 16 节,上面标着数字 1 至 16。每一节都是一个正方形的形状。相邻的两节可以成直线或者成 90 度角。<br>小蓝还有一个 4 × 4 的方格盒子,用于存放玩具蛇,盒子的方格上依次标着字母 A 到 P 共 16 个字母。<br>小蓝可以折叠自己的玩具蛇放到盒子里面。他发现,有很多种方案可以将玩具蛇放进去。<br>下图给出了两种方案:<br><img src="/2021/05/31/lanqiao/she1.png">  </p>
<p>深搜搞定  </p>
<p>答案：552  </p>
<p><strong>代码实现：</strong>   </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> st[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">ll res;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(step == <span class="number">16</span>)&#123;</span><br><span class="line">		res ++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++)&#123;</span><br><span class="line">		<span class="keyword">int</span> a = x + dx[i];</span><br><span class="line">		<span class="keyword">int</span> b = y + dy[i];</span><br><span class="line">		<span class="keyword">if</span>(a &lt;= <span class="number">0</span> || a &gt; <span class="number">4</span> || b &lt;= <span class="number">0</span> || b &gt; <span class="number">4</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(st[a][b]) <span class="keyword">continue</span>;</span><br><span class="line">		st[a][b] = <span class="literal">true</span>;</span><br><span class="line">		dfs(a, b, step + <span class="number">1</span>);</span><br><span class="line">		st[a][b] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i ++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; j ++)&#123;</span><br><span class="line">			st[i][j] = <span class="literal">true</span>;</span><br><span class="line">			dfs(i, j, <span class="number">1</span>);</span><br><span class="line">			st[i][j] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-F-皮亚诺曲线距离"><a href="#试题-F-皮亚诺曲线距离" class="headerlink" title="试题 F: 皮亚诺曲线距离"></a>试题 F: 皮亚诺曲线距离</h1><p><strong>【问题描述】</strong><br>皮亚诺曲线是一条平面内的曲线。<br>下图给出了皮亚诺曲线的 1 阶情形，它是从左下角出发，经过一个 3×3 的<br>方格中的每一个格子，最终到达右上角的一条曲线。<br><img src="/2021/05/31/lanqiao/f1.png">  </p>
<p>下图给出了皮亚诺曲线的 2 阶情形，它是经过一个 3 2 × 3 2 的方格中的每一 个格子的一条曲线。它是将 1 阶曲线的每个方格由 1 阶曲线替换而成。<br><img src="/2021/05/31/lanqiao/f2.png">  </p>
<p>下图给出了皮亚诺曲线的 3 阶情形，它是经过一个 3 3 × 3 3 的方格中的每一个格子的一条曲线。它是将 2 阶曲线的每个方格由 1 阶曲线替换而成。<br><img src="/2021/05/31/lanqiao/f3.png">  </p>
<p>皮亚诺曲线总是从左下角开始出发，最终到达右上角。<br>我们将这些格子放到坐标系中，对于 k 阶皮亚诺曲线，左下角的坐标是<br>(0,0)，右上角坐标是 (3 k − 1,3 k − 1)，右下角坐标是 (3 k − 1,0)，左上角坐标是(0,3 k − 1)。<br>给定 k 阶皮亚诺曲线上的两个点的坐标，请问这两个点之间，如果沿着皮亚诺曲线走，距离是到少？  </p>
<p><strong>输入格式</strong><br>输入的第一行包含一个正整数 k，皮亚诺曲线的阶数。<br>第二行包含两个整数 x 1 , y 1 ，表示第一个点的坐标。<br>第三行包含两个整数 x 2 , y 2 ，表示第二个点的坐标。  </p>
<p><strong>输出格式</strong><br>输出一个整数，表示给定的两个点之间的距离。  </p>
<p><strong>输入样例1：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0 0</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>

<p><strong>输出样例1：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>

<p><strong>输入样例2：</strong>   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">0 2</span><br><span class="line">0 3</span><br></pre></td></tr></table></figure>

<p><strong>输出样例2：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure>

<p><strong>评测用例规模与约定</strong><br>对于 30% 的评测用例，0 ≤ k ≤ 10。<br>对于 50% 的评测用例，0 ≤ k ≤ 20。<br>对于所有评测用例，0 ≤ k ≤ 100, 0 ≤ x 1 ,y 1 , x 2 ,y 2 &lt; 3 k , x 1 ,y 1 , x 2 ,y 2 ≤ 10 18 。<br>数据保证答案不超过 10 18 。  </p>
<p><strong>代码实现：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">呜呜呜不会</span><br></pre></td></tr></table></figure>

<h1 id="试题-G-游园安排"><a href="#试题-G-游园安排" class="headerlink" title="试题 G: 游园安排"></a>试题 G: 游园安排</h1><p><strong>【问题描述】</strong><br>L 星球游乐园非常有趣，吸引着各个星球的游客前来游玩。小蓝是 L 星球游乐园的管理员。<br>为了更好的管理游乐园，游乐园要求所有的游客提前预约，小蓝能看到系<br>统上所有预约游客的名字。每个游客的名字由一个大写英文字母开始，后面跟0 个或多个小写英文字母。游客可能重名。<br>小蓝特别喜欢递增的事物。今天，他决定在所有预约的游客中，选择一部分游客在上午游玩，其他的游客都在下午游玩，在上午游玩的游客要求按照预约的顺序排列后，名字是单调递增的，即排在前面的名字严格小于排在后面的名字。<br>一个名字 A 小于另一个名字 B 是指：存在一个整数 i，使得 A 的前 i 个字母与 B 的前 i 个字母相同，且 A 的第 i+1 个字母小于 B 的第 i+1 个字母。（如果 A 不存在第 i + 1 个字母且 B 存在第 i + 1 个字母，也视为 A 的第 i + 1 个字母小于 B 的第 i + 1 个字母）<br>作为小蓝的助手，你要按照小蓝的想法安排游客，同时你又希望上午有尽量多的游客游玩，请告诉小蓝让哪些游客上午游玩。如果方案有多种，请输出上午游玩的第一个游客名字最小的方案。如果此时还有多种方案，请输出第一个游客名字最小的前提下第二个游客名字最小的方案。如果仍然有多种，依此类推选择第三个、第四个……游客名字最小的方案。  </p>
<p><strong>输入格式</strong><br>输入包含一个字符串，按预约的顺序给出所有游客的名字，相邻的游客名<br>字之间没有字符分隔。  </p>
<p><strong>输出格式</strong><br>按预约顺序输出上午游玩的游客名单，中间不加任何分隔字符。  </p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WoAiLanQiaoBei</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AiLanQiao</span><br></pre></td></tr></table></figure>

<p><strong>评测用例规模与约定</strong><br>对于 20% 的评测数据，输入的总长度不超过 20 个字母。<br>对于 50% 的评测数据，输入的总长度不超过 300 个字母。<br>对于 70% 的评测数据，输入的总长度不超过 10000 个字母。<br>对于所有评测数据，每个名字的长度不超过 10 个字母，输入的总长度不超过 1000000 个字母。  </p>
<p><strong>代码实现：</strong><br>最长子序列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="built_in">string</span> str[N];</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans[<span class="number">10000</span>];</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i] &lt;= <span class="string">&#x27;Z&#x27;</span> &amp;&amp; s[i] &gt;= <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">			str[++ cnt].push_back(s[i]);</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">else</span> str[cnt].push_back(s[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//for(int i = 1; i &lt;= cnt; i ++) cout &lt;&lt; str[i] &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i ++)&#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; temp;</span><br><span class="line">		dp[i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j ++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(str[i] &gt; str[j])&#123;</span><br><span class="line">				<span class="keyword">if</span>(dp[i] &lt; dp[j] + <span class="number">1</span>)&#123;</span><br><span class="line">					dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">					temp = ans[j];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(dp[i] == dp[j] + <span class="number">1</span>)&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; ans[j].size(); k ++)&#123;</span><br><span class="line">						<span class="keyword">if</span>(ans[j].at(k) &lt; temp.at(k))&#123;</span><br><span class="line">							temp = ans[j];</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		temp.push_back(str[i]);</span><br><span class="line">		ans[i] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i ++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dp[i] &gt; res)&#123;</span><br><span class="line">			res = dp[i];</span><br><span class="line">			r = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(dp[i] == res)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ans[i].size(); j ++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(ans[i].at(j) &lt; ans[r].at(j))&#123;</span><br><span class="line">					res = dp[i];</span><br><span class="line">					r = i;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans[r].size(); i ++) <span class="built_in">cout</span> &lt;&lt; ans[r].at(i);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-H-答疑"><a href="#试题-H-答疑" class="headerlink" title="试题 H: 答疑"></a>试题 H: 答疑</h1><p><strong>【问题描述】</strong><br>有 n 位同学同时找老师答疑。每位同学都预先估计了自己答疑的时间。<br>老师可以安排答疑的顺序，同学们要依次进入老师办公室答疑。<br>一位同学答疑的过程如下：<br>首先进入办公室，编号为 i 的同学需要 si 毫秒的时间。<br>然后同学问问题老师解答，编号为 i 的同学需要 ai 毫秒的时间。<br>答疑完成后，同学很高兴，会在课程群里面发一条消息，需要的时间可以忽略。<br>最后同学收拾东西离开办公室，需要 ei 毫秒的时间。一般需要 10秒、20 秒或 30 秒，即 ei 取值为 10000，20000 或 30000。<br>一位同学离开办公室后，紧接着下一位同学就可以进入办公室了。<br>答疑从 0 时刻开始。老师想合理的安排答疑的顺序，使得同学们在课程群里面发消息的时刻之和最小。  </p>
<p><strong>输入格式</strong><br>输入第一行包含一个整数 n，表示同学的数量。<br>接下来 n 行，描述每位同学的时间。其中第 i 行包含三个整数 s i , a i , e i ，意义如上所述。  </p>
<p><strong>输出格式</strong><br>输出一个整数，表示同学们在课程群里面发消息的时刻之和最小是多少。    </p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">10000 10000 10000</span><br><span class="line">20000 50000 20000</span><br><span class="line">30000 20000 30000</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">280000</span><br></pre></td></tr></table></figure>

<p><strong>评测用例规模与约定</strong><br>对于 30% 的评测用例，1 ≤ n ≤ 20。<br>对于 60% 的评测用例，1 ≤ n ≤ 200。<br>对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ s i ≤ 60000，1 ≤ a i ≤ 1000000,e i ∈ {10000,20000,30000}，即 e i 一定是 10000、20000、30000 之一。  </p>
<p><strong>代码实现：</strong><br>贪心实现 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> s;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> e;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Stu &amp;t)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum1 = s + a + e;</span><br><span class="line">		<span class="keyword">int</span> sum2 = t.s + t.a + t.e;</span><br><span class="line">		<span class="keyword">return</span> sum1 &lt; sum2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;student[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">	ll time = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">		<span class="keyword">int</span> s, a, e;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; a &gt;&gt; e;</span><br><span class="line">		student[i] = &#123;s, a, e&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(student, student + n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">		time += student[i].s + student[i].a;</span><br><span class="line">		res += time;</span><br><span class="line">		time += student[i].e;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-I-出租车"><a href="#试题-I-出租车" class="headerlink" title="试题 I: 出租车"></a>试题 I: 出租车</h1><p><strong>【问题描述】</strong><br>小蓝在 L 市开出租车。<br>L 市的规划很规整，所有的路都是正东西向或者正南北向的，道路都可以看成直线段。东西向的道路互相平行，南北向的道路互相平行，任何一条东西向道路垂直于任何一条南北向道路。<br>从北到南一共有 n 条东西向道路，依次标号为 H 1 , H 2 , ···, H n 。从西到东一共有 m 条南北向的道路，依次标号为 S 1 , S 2 , ···, S m 。<br>每条道路都有足够长，每一条东西向道路和每一条南北向道路都相交，H i与 S j 的交叉路口记为 (i, j)。<br>从 H 1 和 S 1 的交叉路口 (1,1) 开始，向南遇到的路口与 (1,1) 的距离分别是 h 1 , h 2 , ···, h n−1 ，向东遇到路口与 (1,1) 的距离分别是 w 1 , w 2 , ···, w m−1 。道路的每个路口都有一个红绿灯。<br>时刻 0 的时候，南北向绿灯亮，东西向红灯亮，南北向的绿灯会持续一段时间（每个路口不同），然后南北向变成红灯，东西向变成绿灯，持续一段时间后，再变成南北向绿灯，东西向红灯。<br>已知路口 (i, j) 的南北向绿灯每次持续的时间为 g ij ，东西向的绿灯每次持续的时间为 r ij ，红绿灯的变换时间忽略。<br>当一辆车走到路口时，如果是绿灯，可以直行、左转或右转。如果是红灯，可以右转，不能直行或左转。如果到路口的时候刚好由红灯变为绿灯，则视为看到绿灯，如果刚好由绿灯变为红灯，则视为看到红灯。<br>每段道路都是双向道路，道路中间有隔离栏杆，在道路中间不能掉头，只能在红绿灯路口掉头。掉头时不管是红灯还是绿灯都可以直接掉头。掉头的时间可以忽略。<br>小蓝时刻 0 从家出发。今天，他接到了 q 个预约的订单，他打算按照订单的顺序依次完成这些订单，就回家休息。中途小蓝不准备再拉其他乘客。<br>小蓝的家在两个路口的中点，小蓝喜欢用 x 1 , y 1 , x 2 , y 2 来表示自己家的位置，即路口 (x 1 ,y 1 ) 到路口 (x 2 ,y 2 ) 之间的道路中点的右侧，保证两个路口相邻（中间没有其他路口）。请注意当两个路口交换位置时，表达的是路的不同两边，路中间有栏杆，因此这两个位置实际要走比较远才能到达。<br>小蓝的订单也是从某两个路口间的中点出发，到某两个路口间的中点结束。小蓝必须按照给定的顺序处理订单，而且一个时刻只能处理一个订单，不能图省时间而同时接两位乘客，也不能插队完成后面的订单。<br>小蓝只对 L 市比较熟，因此他只会在给定的 n 条东西向道路和 m 条南北向道路上行驶，而且不会驶出 H 1 , H n , S 1 , S m 这几条道路所确定的矩形区域（可以到边界）。小蓝行车速度一直为 1，乘客上下车的时间忽略不计。请问，小蓝最早什么时候能完成所有订单回到家。  </p>
<p><strong>输入格式</strong><br>输入第一行包含两个整数 n, m，表示东西向道路的数量和南北向道路的数量。<br>第二行包含 n − 1 个整数 h 1 , h 2 , ···, h n−1 。<br>第三行包含 m − 1 个整数 w 1 , w 2 , ···, w m−1 。<br>接下来 n 行，每行 m 个整数，描述每个路口南北向绿灯的时间，其中的第i 行第 j 列表示 g ij 。<br>接下来 n 行，每行 m 个整数，描述每个路口东西向绿灯的时间，其中的第i 行第 j 列表示 r ij 。<br>接下来一行包含四个整数 x 1 , y 1 , x 2 , y 2 ，表示小蓝家的位置在路口 (x 1 ,y 1 )到路口 (x 2 ,y 2 ) 之间的道路中点的右侧。<br>接下来一行包含一个整数 q，表示订单数量。<br>接下来 q 行，每行描述一个订单，其中第 i 行包含八个整数 x i1 , y i1 , x i2 , y i2 ,x i3 , y i3 , x i4 , y i4 ，表示第 i 个订单的起点为路口 (x i1 ,y i1 ) 到路口 (x i2 ,y i2 ) 之间的道路中点的右侧，第 i 个订单的终点为路口 (x i3 ,y i3 ) 到路口 (x i4 ,y i4 ) 之间的道路中点的右侧。  </p>
<p><strong>输出格式</strong><br>输出一个实数，表示小蓝完成所有订单最后回到家的最早时刻。四舍五入保留一位小数。    </p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3</span><br><span class="line">200</span><br><span class="line">100 400</span><br><span class="line">10 20 10</span><br><span class="line">20 40 30</span><br><span class="line">20 20 20</span><br><span class="line">20 20 20</span><br><span class="line">2 1 1 1</span><br><span class="line">1</span><br><span class="line">2 2 1 2 1 2 1 3</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1620.0</span><br></pre></td></tr></table></figure>

<p><strong>样例说明</strong><br>小蓝有一个订单，他的行车路线如下图所示。其中 H 表示他家的位置，S表示订单的起点，T 表示订单的终点。小明在最后回家时要在直行的红绿灯路口等绿灯，等待时间为 20。<br><img src="/2021/05/31/lanqiao/i.png">  </p>
<p><strong>代码实现：</strong>   </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">太长不看（明明是不会</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>practise</category>
      </categories>
      <tags>
        <tag>算法练习</tag>
      </tags>
  </entry>
  <entry>
    <title>第十届蓝桥杯C/C++ B组国赛部分题解</title>
    <url>/2021/06/01/lanqiao2/</url>
    <content><![CDATA[<p>填空题和部分编程题（因为太菜了，没有全部题目的题解</p>
<span id="more"></span>  

<h1 id="试题-A-平方序列"><a href="#试题-A-平方序列" class="headerlink" title="试题 A: 平方序列"></a>试题 A: 平方序列</h1><p><strong>【问题描述】</strong><br>小明想找到两个正整数 X 和 Y，满足<br>• 2019 &lt; X &lt; Y;<br>• 2019^2 , X^2 , Y^2<br>组成等差数列。 请你求出在所有可能的解中，X + Y 的最小值是多少？  </p>
<p>暴力<br>答案：7020</p>
<p><strong>代码实现：</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="keyword">for</span>(x = <span class="number">2020</span>; x &lt; <span class="number">10000</span>; x ++ )&#123;</span><br><span class="line">		<span class="keyword">for</span>(y = x + <span class="number">1</span>; y &lt; <span class="number">10000</span>; y ++ )&#123;</span><br><span class="line">			<span class="keyword">if</span>(x * x - <span class="number">2019</span> * <span class="number">2019</span> == y * y - x * x)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(x * x - <span class="number">2019</span> * <span class="number">2019</span> == y * y - x * x)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; x + y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-B-质数拆分"><a href="#试题-B-质数拆分" class="headerlink" title="试题 B: 质数拆分"></a>试题 B: 质数拆分</h1><p><strong>【问题描述】</strong><br>将 2019 拆分为若干个两两不同的质数之和，一共有多少种不同的方法？ 注意交换顺序视为同一种方法，例如 2 + 2017 = 2019 与 2017 + 2 = 2019 视为同一种方法。  </p>
<p>暴力<br>答案：1</p>
<p><strong>代码实现：</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; i ++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">2019</span> / <span class="number">2</span>); i ++ )&#123;</span><br><span class="line">		<span class="keyword">if</span>(is_prime(i) &amp;&amp; is_prime(<span class="number">2019</span> - i))</span><br><span class="line">			cnt ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="试题-C-拼接"><a href="#试题-C-拼接" class="headerlink" title="试题 C: 拼接"></a>试题 C: 拼接</h1><p><strong>【问题描述】</strong><br>小明要把一根木头切成两段，然后拼接成一个直角。 如下图所示，他把中间部分分成了 n × n 的小正方形，他标记了每个小正方 形属于左边还是右边。然后沿两边的分界线将木头切断，将右边旋转向上后拼接在一起。<br><img src="/2021/06/01/lanqiao2/c.png">  </p>
<p>要求每个小正方形都正好属于左边或右边，而且同一边的必须是连通的。 在拼接时，拼接的部位必须保持在原来大正方形里面。 请问，对于 7 × 7 的小正方形，有多少种合法的划分小正方形的方式。</p>
<p>答案：14</p>
<p><strong>代码实现：</strong>  </p>
<h1 id="试题-D-求值"><a href="#试题-D-求值" class="headerlink" title="试题 D: 求值"></a>试题 D: 求值</h1><p><strong>【问题描述】</strong><br>学习了约数后，小明对于约数很好奇，他发现，给定一个正整数 t，总是可 以找到含有 t 个约数的整数。小明对于含有 t 个约数的最小数非常感兴趣，并 把它定义为 S t 。 例如 S 1 = 1, S 2 = 2, S 3 = 4, S 4 = 6，· · · 。 现在小明想知道，当 t = 100 时，S t 是多少？即 S 100 是多少？</p>
<p>答案：45360</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> minp[N];</span><br><span class="line"><span class="keyword">int</span> primes[N];</span><br><span class="line"><span class="keyword">int</span> st[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> sum[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x; i ++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">			primes[cnt ++] = i;</span><br><span class="line">			minp[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; i * primes[j] &lt;= x; j ++)&#123;</span><br><span class="line">			<span class="keyword">int</span> p = i * primes[j];</span><br><span class="line">			st[p] = <span class="literal">true</span>;</span><br><span class="line">			minp[p] = primes[j];</span><br><span class="line">			<span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	get_primes(<span class="number">100000</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">100000</span>; i ++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x = i;</span><br><span class="line">		<span class="keyword">int</span> cnt2 = <span class="number">0</span>;</span><br><span class="line">		res = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">		<span class="keyword">while</span>(x &gt; <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> p = minp[x];</span><br><span class="line">			<span class="keyword">while</span>(x % p == <span class="number">0</span>)&#123;</span><br><span class="line">				x /= p;</span><br><span class="line">				sum[cnt2] ++;</span><br><span class="line">			&#125;</span><br><span class="line">			cnt2 ++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= cnt2; j ++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(sum[j] != <span class="number">0</span>)</span><br><span class="line">				res *= (<span class="number">1</span> + sum[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(res == <span class="number">100</span>)&#123;</span><br><span class="line">			ans = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-E-求值"><a href="#试题-E-求值" class="headerlink" title="试题 E: 求值"></a>试题 E: 求值</h1><p><strong>【问题描述】</strong><br>从一个 5x5 的方格矩阵的左上角出发，沿着方格的边走，满足以下条件的路线有多少种？<br>• 总长度不超过 12；<br>• 最后回到左上角；<br>• 路线不自交；<br>• 不走出 5x5 的方格矩阵范围之外。<br>如下图所示，ABC 是三种合法的路线。注意 B 和 C 由于方向不同，所以 视为不同的路线。<br><img src="/2021/06/01/lanqiao2/e.png">  </p>
<p>答案：208</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">bool</span> st[N][N];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(step &gt; <span class="number">12</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span> &amp;&amp; st[<span class="number">0</span>][<span class="number">0</span>])&#123;</span><br><span class="line">		cnt ++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )&#123;</span><br><span class="line">		<span class="keyword">int</span> a = x + dx[i];</span><br><span class="line">		<span class="keyword">int</span> b = y + dy[i];</span><br><span class="line">		<span class="keyword">if</span>(a &lt; <span class="number">0</span> || a &gt; <span class="number">5</span> || b &lt; <span class="number">0</span> || b &gt; <span class="number">5</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(st[a][b]) <span class="keyword">continue</span>;</span><br><span class="line">		st[a][b] = <span class="literal">true</span>;</span><br><span class="line">		dfs(a, b, step + <span class="number">1</span>);</span><br><span class="line">		st[a][b] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="试题-F-最优包含"><a href="#试题-F-最优包含" class="headerlink" title="试题 F: 最优包含"></a>试题 F: 最优包含</h1><p><strong>【问题描述】</strong><br>我们称一个字符串 S 包含字符串 T 是指 T 是 S 的一个子序列，即可以从字符串 S 中抽出若干个字符，它们按原来的顺序组合成一个新的字符串与 T 完全一样。  </p>
<p>给定两个字符串 S 和 T，请问最少修改 S 中的多少个字符，能使 S 包含 T？  </p>
<p><strong>输入格式</strong><br>输入两行，每行一个字符串。</p>
<p>第一行的字符串为 S，第二行的字符串为 T。</p>
<p>两个字符串均非空而且只包含大写英文字母。</p>
<p><strong>输出格式</strong><br>输出一个整数，表示答案。    </p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ABCDEABCD</span><br><span class="line">XAABZ</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p><strong>评测用例规模与约定</strong><br>1≤|T|≤|S|≤1000  </p>
<p><strong>代码实现：</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s,t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="built_in">memset</span>(dp,INF,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= s.size() ;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">1</span>; j &lt;= i ;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>] == INF) dp[i][j] = min(dp[i][j],<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = min(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]== INF)</span><br><span class="line">                    dp[i][j] = min(<span class="number">1</span>,dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                <span class="keyword">else</span>  dp[i][j] = min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>,dp[i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[s.size()][t.size()]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="试题-G-排列数"><a href="#试题-G-排列数" class="headerlink" title="试题 G: 排列数"></a>试题 G: 排列数</h1><p><strong>【问题描述】</strong><br>在一个排列中，一个折点是指排列中的一个元素，它同时小于两边的元素，或者同时大于两边的元素。</p>
<p>对于一个 1∼n 的排列，如果可以将这个排列中包含 t 个折点，则它称为一个 t+1 单调序列。</p>
<p>例如，排列 (1,4,2,3) 是一个 3 单调序列，其中 4 和 2 都是折点。</p>
<p>给定 n 和 k，请问 1∼n 的所有排列中有多少个 k 单调队列？</p>
<p><strong>输入格式</strong><br>输入一行包含两个整数 n,k。</p>
<p><strong>输出格式</strong><br>输出一个整数，表示答案。</p>
<p>答案可能很大，你可需要输出满足条件的排列数量除以 123456 的余数即可。    </p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure>

<p><strong>评测用例规模与约定</strong><br>1≤k≤n≤500  </p>
<p><strong>代码实现：</strong>  </p>
<h1 id="试题-H-解谜游戏"><a href="#试题-H-解谜游戏" class="headerlink" title="试题 H: 解谜游戏"></a>试题 H: 解谜游戏</h1><p><strong>【问题描述】</strong><br>小明正在玩一款解谜游戏。</p>
<p>谜题由 24 根塑料棒组成，其中黄色塑料棒 4 根，红色 8 根，绿色 12 根 (后面用 Y 表示黄色、R 表示红色、G 表示绿色)。<br><img src="/2021/06/01/lanqiao2/h.png"><br>初始时这些塑料棒排成三圈，如上图所示，外圈 12 根，中圈 8 根，内圈 4 根。</p>
<p>小明可以进行三种操作：</p>
<p>①将三圈塑料棒都顺时针旋转一个单位。例如当前外圈从 0 点位置开始顺时针依次是 YRYGRYGRGGGG，中圈是 RGRGGRRY，内圈是 GGGR。那么顺时针旋转一次之后，外圈、中圈、内圈依次变为：GYRYGRYGRGGG、YRGRGGRR 和 RGGG。<br>②将三圈塑料棒都逆时针旋转一个单位。例如当前外圈从 0 点位置开始顺时针依次是 YRYGRYGRGGGG，中圈是 RGRGGRRY，内圈是 GGGR。那么逆时针旋转一次之后，外圈、中圈、内圈依次变为：RYGRYGRGGGGY、GRGGRRYR 和 GGRG。<br>③将三圈 0 点位置的塑料棒做一个轮换。具体来说：外圈 0 点塑料棒移动到内圈 0 点，内圈 0 点移动到中圈 0 点，中圈 0 点移动到外圈 0 点。例如当前外圈从 0 点位置开始顺时针依次是 YRYGRYGRGGGG，中圈是 RGRGGRRY，内圈是 GGGR。那么轮换一次之后，外圈、中圈、内圈依次变为：RRYGRYGRGGGG、GGRGGRRY 和 YGGR。<br>小明的目标是把所有绿色移动到外圈、所有红色移动中圈、所有黄色移动到内圈。</p>
<p>给定初始状态，请你判断小明是否可以达成目标？</p>
<p><strong>输入格式</strong><br>第一行包含一个整数 T，代表询问的组数。</p>
<p>每组询问包含 3 行：</p>
<p>第一行包含 12 个大写字母，代表外圈从 0 点位置开始顺时针每个塑料棒的颜色。</p>
<p>第二行包含 8 个大写字母，代表中圈从 0 点位置开始顺时针每个塑料棒的颜色。</p>
<p>第三行包含 4 个大写字母，代表内圈从 0 点位置开始顺时针每个塑料棒的颜色。</p>
<p><strong>输出格式</strong><br>对于每组询问，输出一行 YES 或者 NO，代表小明是否可以达成目标。</p>
<p><strong>输入样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">GYGGGGGGGGGG</span><br><span class="line">RGRRRRRR</span><br><span class="line">YRYY</span><br><span class="line">YGGGRRRRGGGY</span><br><span class="line">YGGGRRRR</span><br><span class="line">YGGG</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>

<p><strong>评测用例规模与约定</strong><br>1≤T≤100</p>
<p><strong>代码实现：</strong>  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">3</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++)  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> y = <span class="number">0</span>, r = <span class="number">0</span>, g = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = k; s[i][j]; j += <span class="number">4</span>)</span><br><span class="line">                    <span class="keyword">if</span>(s[i][j] == <span class="string">&#x27;Y&#x27;</span>)  y ++;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(s[i][j] == <span class="string">&#x27;R&#x27;</span>)  r ++;</span><br><span class="line">                    <span class="keyword">else</span>  g ++;</span><br><span class="line">            <span class="keyword">if</span>(!(y == <span class="number">1</span> <span class="keyword">and</span> r == <span class="number">2</span> <span class="keyword">and</span> g == <span class="number">3</span>))  flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag)  <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>  <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>practise</category>
      </categories>
      <tags>
        <tag>算法练习</tag>
      </tags>
  </entry>
</search>
